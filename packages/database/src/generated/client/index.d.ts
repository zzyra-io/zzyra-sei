
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model UserWallet
 * 
 */
export type UserWallet = $Result.DefaultSelection<Prisma.$UserWalletPayload>
/**
 * Model WorkflowTemplate
 * 
 */
export type WorkflowTemplate = $Result.DefaultSelection<Prisma.$WorkflowTemplatePayload>
/**
 * Model Workflow
 * 
 */
export type Workflow = $Result.DefaultSelection<Prisma.$WorkflowPayload>
/**
 * Model WorkflowExecution
 * 
 */
export type WorkflowExecution = $Result.DefaultSelection<Prisma.$WorkflowExecutionPayload>
/**
 * Model NodeExecution
 * 
 */
export type NodeExecution = $Result.DefaultSelection<Prisma.$NodeExecutionPayload>
/**
 * Model NodeLog
 * 
 */
export type NodeLog = $Result.DefaultSelection<Prisma.$NodeLogPayload>
/**
 * Model NodeInput
 * 
 */
export type NodeInput = $Result.DefaultSelection<Prisma.$NodeInputPayload>
/**
 * Model NodeOutput
 * 
 */
export type NodeOutput = $Result.DefaultSelection<Prisma.$NodeOutputPayload>
/**
 * Model ExecutionLog
 * 
 */
export type ExecutionLog = $Result.DefaultSelection<Prisma.$ExecutionLogPayload>
/**
 * Model WorkflowPause
 * 
 */
export type WorkflowPause = $Result.DefaultSelection<Prisma.$WorkflowPausePayload>
/**
 * Model BlockchainTransaction
 * 
 */
export type BlockchainTransaction = $Result.DefaultSelection<Prisma.$BlockchainTransactionPayload>
/**
 * Model TransactionAttempt
 * 
 */
export type TransactionAttempt = $Result.DefaultSelection<Prisma.$TransactionAttemptPayload>
/**
 * Model AiBlockchainOperation
 * 
 */
export type AiBlockchainOperation = $Result.DefaultSelection<Prisma.$AiBlockchainOperationPayload>
/**
 * Model BlockExecution
 * 
 */
export type BlockExecution = $Result.DefaultSelection<Prisma.$BlockExecutionPayload>
/**
 * Model BlockExecutionLog
 * 
 */
export type BlockExecutionLog = $Result.DefaultSelection<Prisma.$BlockExecutionLogPayload>
/**
 * Model BlockLibrary
 * 
 */
export type BlockLibrary = $Result.DefaultSelection<Prisma.$BlockLibraryPayload>
/**
 * Model BlockLibraryRating
 * 
 */
export type BlockLibraryRating = $Result.DefaultSelection<Prisma.$BlockLibraryRatingPayload>
/**
 * Model CustomBlock
 * 
 */
export type CustomBlock = $Result.DefaultSelection<Prisma.$CustomBlockPayload>
/**
 * Model ExecutionQueue
 * 
 */
export type ExecutionQueue = $Result.DefaultSelection<Prisma.$ExecutionQueuePayload>
/**
 * Model ExecutionNodeStatus
 * 
 */
export type ExecutionNodeStatus = $Result.DefaultSelection<Prisma.$ExecutionNodeStatusPayload>
/**
 * Model CircuitBreakerState
 * 
 */
export type CircuitBreakerState = $Result.DefaultSelection<Prisma.$CircuitBreakerStatePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>
/**
 * Model NotificationTemplate
 * 
 */
export type NotificationTemplate = $Result.DefaultSelection<Prisma.$NotificationTemplatePayload>
/**
 * Model NotificationLog
 * 
 */
export type NotificationLog = $Result.DefaultSelection<Prisma.$NotificationLogPayload>
/**
 * Model PricingTier
 * 
 */
export type PricingTier = $Result.DefaultSelection<Prisma.$PricingTierPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model SubscriptionInvoice
 * 
 */
export type SubscriptionInvoice = $Result.DefaultSelection<Prisma.$SubscriptionInvoicePayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model UsageLog
 * 
 */
export type UsageLog = $Result.DefaultSelection<Prisma.$UsageLogPayload>
/**
 * Model WalletTransaction
 * 
 */
export type WalletTransaction = $Result.DefaultSelection<Prisma.$WalletTransactionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const WorkflowStatus: {
  pending: 'pending',
  running: 'running',
  completed: 'completed',
  failed: 'failed',
  paused: 'paused'
};

export type WorkflowStatus = (typeof WorkflowStatus)[keyof typeof WorkflowStatus]


export const LogLevel: {
  info: 'info',
  error: 'error',
  warn: 'warn'
};

export type LogLevel = (typeof LogLevel)[keyof typeof LogLevel]


export const BlockStatus: {
  pending: 'pending',
  running: 'running',
  completed: 'completed',
  failed: 'failed'
};

export type BlockStatus = (typeof BlockStatus)[keyof typeof BlockStatus]

}

export type WorkflowStatus = $Enums.WorkflowStatus

export const WorkflowStatus: typeof $Enums.WorkflowStatus

export type LogLevel = $Enums.LogLevel

export const LogLevel: typeof $Enums.LogLevel

export type BlockStatus = $Enums.BlockStatus

export const BlockStatus: typeof $Enums.BlockStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.userWallet`: Exposes CRUD operations for the **UserWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserWallets
    * const userWallets = await prisma.userWallet.findMany()
    * ```
    */
  get userWallet(): Prisma.UserWalletDelegate<ExtArgs>;

  /**
   * `prisma.workflowTemplate`: Exposes CRUD operations for the **WorkflowTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowTemplates
    * const workflowTemplates = await prisma.workflowTemplate.findMany()
    * ```
    */
  get workflowTemplate(): Prisma.WorkflowTemplateDelegate<ExtArgs>;

  /**
   * `prisma.workflow`: Exposes CRUD operations for the **Workflow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workflows
    * const workflows = await prisma.workflow.findMany()
    * ```
    */
  get workflow(): Prisma.WorkflowDelegate<ExtArgs>;

  /**
   * `prisma.workflowExecution`: Exposes CRUD operations for the **WorkflowExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowExecutions
    * const workflowExecutions = await prisma.workflowExecution.findMany()
    * ```
    */
  get workflowExecution(): Prisma.WorkflowExecutionDelegate<ExtArgs>;

  /**
   * `prisma.nodeExecution`: Exposes CRUD operations for the **NodeExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NodeExecutions
    * const nodeExecutions = await prisma.nodeExecution.findMany()
    * ```
    */
  get nodeExecution(): Prisma.NodeExecutionDelegate<ExtArgs>;

  /**
   * `prisma.nodeLog`: Exposes CRUD operations for the **NodeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NodeLogs
    * const nodeLogs = await prisma.nodeLog.findMany()
    * ```
    */
  get nodeLog(): Prisma.NodeLogDelegate<ExtArgs>;

  /**
   * `prisma.nodeInput`: Exposes CRUD operations for the **NodeInput** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NodeInputs
    * const nodeInputs = await prisma.nodeInput.findMany()
    * ```
    */
  get nodeInput(): Prisma.NodeInputDelegate<ExtArgs>;

  /**
   * `prisma.nodeOutput`: Exposes CRUD operations for the **NodeOutput** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NodeOutputs
    * const nodeOutputs = await prisma.nodeOutput.findMany()
    * ```
    */
  get nodeOutput(): Prisma.NodeOutputDelegate<ExtArgs>;

  /**
   * `prisma.executionLog`: Exposes CRUD operations for the **ExecutionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExecutionLogs
    * const executionLogs = await prisma.executionLog.findMany()
    * ```
    */
  get executionLog(): Prisma.ExecutionLogDelegate<ExtArgs>;

  /**
   * `prisma.workflowPause`: Exposes CRUD operations for the **WorkflowPause** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowPauses
    * const workflowPauses = await prisma.workflowPause.findMany()
    * ```
    */
  get workflowPause(): Prisma.WorkflowPauseDelegate<ExtArgs>;

  /**
   * `prisma.blockchainTransaction`: Exposes CRUD operations for the **BlockchainTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockchainTransactions
    * const blockchainTransactions = await prisma.blockchainTransaction.findMany()
    * ```
    */
  get blockchainTransaction(): Prisma.BlockchainTransactionDelegate<ExtArgs>;

  /**
   * `prisma.transactionAttempt`: Exposes CRUD operations for the **TransactionAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionAttempts
    * const transactionAttempts = await prisma.transactionAttempt.findMany()
    * ```
    */
  get transactionAttempt(): Prisma.TransactionAttemptDelegate<ExtArgs>;

  /**
   * `prisma.aiBlockchainOperation`: Exposes CRUD operations for the **AiBlockchainOperation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiBlockchainOperations
    * const aiBlockchainOperations = await prisma.aiBlockchainOperation.findMany()
    * ```
    */
  get aiBlockchainOperation(): Prisma.AiBlockchainOperationDelegate<ExtArgs>;

  /**
   * `prisma.blockExecution`: Exposes CRUD operations for the **BlockExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockExecutions
    * const blockExecutions = await prisma.blockExecution.findMany()
    * ```
    */
  get blockExecution(): Prisma.BlockExecutionDelegate<ExtArgs>;

  /**
   * `prisma.blockExecutionLog`: Exposes CRUD operations for the **BlockExecutionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockExecutionLogs
    * const blockExecutionLogs = await prisma.blockExecutionLog.findMany()
    * ```
    */
  get blockExecutionLog(): Prisma.BlockExecutionLogDelegate<ExtArgs>;

  /**
   * `prisma.blockLibrary`: Exposes CRUD operations for the **BlockLibrary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockLibraries
    * const blockLibraries = await prisma.blockLibrary.findMany()
    * ```
    */
  get blockLibrary(): Prisma.BlockLibraryDelegate<ExtArgs>;

  /**
   * `prisma.blockLibraryRating`: Exposes CRUD operations for the **BlockLibraryRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockLibraryRatings
    * const blockLibraryRatings = await prisma.blockLibraryRating.findMany()
    * ```
    */
  get blockLibraryRating(): Prisma.BlockLibraryRatingDelegate<ExtArgs>;

  /**
   * `prisma.customBlock`: Exposes CRUD operations for the **CustomBlock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomBlocks
    * const customBlocks = await prisma.customBlock.findMany()
    * ```
    */
  get customBlock(): Prisma.CustomBlockDelegate<ExtArgs>;

  /**
   * `prisma.executionQueue`: Exposes CRUD operations for the **ExecutionQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExecutionQueues
    * const executionQueues = await prisma.executionQueue.findMany()
    * ```
    */
  get executionQueue(): Prisma.ExecutionQueueDelegate<ExtArgs>;

  /**
   * `prisma.executionNodeStatus`: Exposes CRUD operations for the **ExecutionNodeStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExecutionNodeStatuses
    * const executionNodeStatuses = await prisma.executionNodeStatus.findMany()
    * ```
    */
  get executionNodeStatus(): Prisma.ExecutionNodeStatusDelegate<ExtArgs>;

  /**
   * `prisma.circuitBreakerState`: Exposes CRUD operations for the **CircuitBreakerState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CircuitBreakerStates
    * const circuitBreakerStates = await prisma.circuitBreakerState.findMany()
    * ```
    */
  get circuitBreakerState(): Prisma.CircuitBreakerStateDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs>;

  /**
   * `prisma.notificationTemplate`: Exposes CRUD operations for the **NotificationTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationTemplates
    * const notificationTemplates = await prisma.notificationTemplate.findMany()
    * ```
    */
  get notificationTemplate(): Prisma.NotificationTemplateDelegate<ExtArgs>;

  /**
   * `prisma.notificationLog`: Exposes CRUD operations for the **NotificationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationLogs
    * const notificationLogs = await prisma.notificationLog.findMany()
    * ```
    */
  get notificationLog(): Prisma.NotificationLogDelegate<ExtArgs>;

  /**
   * `prisma.pricingTier`: Exposes CRUD operations for the **PricingTier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PricingTiers
    * const pricingTiers = await prisma.pricingTier.findMany()
    * ```
    */
  get pricingTier(): Prisma.PricingTierDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.subscriptionInvoice`: Exposes CRUD operations for the **SubscriptionInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionInvoices
    * const subscriptionInvoices = await prisma.subscriptionInvoice.findMany()
    * ```
    */
  get subscriptionInvoice(): Prisma.SubscriptionInvoiceDelegate<ExtArgs>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.usageLog`: Exposes CRUD operations for the **UsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageLogs
    * const usageLogs = await prisma.usageLog.findMany()
    * ```
    */
  get usageLog(): Prisma.UsageLogDelegate<ExtArgs>;

  /**
   * `prisma.walletTransaction`: Exposes CRUD operations for the **WalletTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WalletTransactions
    * const walletTransactions = await prisma.walletTransaction.findMany()
    * ```
    */
  get walletTransaction(): Prisma.WalletTransactionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Profile: 'Profile',
    UserWallet: 'UserWallet',
    WorkflowTemplate: 'WorkflowTemplate',
    Workflow: 'Workflow',
    WorkflowExecution: 'WorkflowExecution',
    NodeExecution: 'NodeExecution',
    NodeLog: 'NodeLog',
    NodeInput: 'NodeInput',
    NodeOutput: 'NodeOutput',
    ExecutionLog: 'ExecutionLog',
    WorkflowPause: 'WorkflowPause',
    BlockchainTransaction: 'BlockchainTransaction',
    TransactionAttempt: 'TransactionAttempt',
    AiBlockchainOperation: 'AiBlockchainOperation',
    BlockExecution: 'BlockExecution',
    BlockExecutionLog: 'BlockExecutionLog',
    BlockLibrary: 'BlockLibrary',
    BlockLibraryRating: 'BlockLibraryRating',
    CustomBlock: 'CustomBlock',
    ExecutionQueue: 'ExecutionQueue',
    ExecutionNodeStatus: 'ExecutionNodeStatus',
    CircuitBreakerState: 'CircuitBreakerState',
    Notification: 'Notification',
    NotificationPreference: 'NotificationPreference',
    NotificationTemplate: 'NotificationTemplate',
    NotificationLog: 'NotificationLog',
    PricingTier: 'PricingTier',
    Subscription: 'Subscription',
    SubscriptionInvoice: 'SubscriptionInvoice',
    Team: 'Team',
    TeamMember: 'TeamMember',
    AuditLog: 'AuditLog',
    UsageLog: 'UsageLog',
    WalletTransaction: 'WalletTransaction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "profile" | "userWallet" | "workflowTemplate" | "workflow" | "workflowExecution" | "nodeExecution" | "nodeLog" | "nodeInput" | "nodeOutput" | "executionLog" | "workflowPause" | "blockchainTransaction" | "transactionAttempt" | "aiBlockchainOperation" | "blockExecution" | "blockExecutionLog" | "blockLibrary" | "blockLibraryRating" | "customBlock" | "executionQueue" | "executionNodeStatus" | "circuitBreakerState" | "notification" | "notificationPreference" | "notificationTemplate" | "notificationLog" | "pricingTier" | "subscription" | "subscriptionInvoice" | "team" | "teamMember" | "auditLog" | "usageLog" | "walletTransaction"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      UserWallet: {
        payload: Prisma.$UserWalletPayload<ExtArgs>
        fields: Prisma.UserWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserWalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserWalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload>
          }
          findFirst: {
            args: Prisma.UserWalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserWalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload>
          }
          findMany: {
            args: Prisma.UserWalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload>[]
          }
          create: {
            args: Prisma.UserWalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload>
          }
          createMany: {
            args: Prisma.UserWalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserWalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload>[]
          }
          delete: {
            args: Prisma.UserWalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload>
          }
          update: {
            args: Prisma.UserWalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload>
          }
          deleteMany: {
            args: Prisma.UserWalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserWalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserWalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload>
          }
          aggregate: {
            args: Prisma.UserWalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserWallet>
          }
          groupBy: {
            args: Prisma.UserWalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserWalletCountArgs<ExtArgs>
            result: $Utils.Optional<UserWalletCountAggregateOutputType> | number
          }
        }
      }
      WorkflowTemplate: {
        payload: Prisma.$WorkflowTemplatePayload<ExtArgs>
        fields: Prisma.WorkflowTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          findFirst: {
            args: Prisma.WorkflowTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          findMany: {
            args: Prisma.WorkflowTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>[]
          }
          create: {
            args: Prisma.WorkflowTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          createMany: {
            args: Prisma.WorkflowTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>[]
          }
          delete: {
            args: Prisma.WorkflowTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          update: {
            args: Prisma.WorkflowTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          deleteMany: {
            args: Prisma.WorkflowTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          aggregate: {
            args: Prisma.WorkflowTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowTemplate>
          }
          groupBy: {
            args: Prisma.WorkflowTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowTemplateCountAggregateOutputType> | number
          }
        }
      }
      Workflow: {
        payload: Prisma.$WorkflowPayload<ExtArgs>
        fields: Prisma.WorkflowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findFirst: {
            args: Prisma.WorkflowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findMany: {
            args: Prisma.WorkflowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          create: {
            args: Prisma.WorkflowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          createMany: {
            args: Prisma.WorkflowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          delete: {
            args: Prisma.WorkflowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          update: {
            args: Prisma.WorkflowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          aggregate: {
            args: Prisma.WorkflowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflow>
          }
          groupBy: {
            args: Prisma.WorkflowGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowCountAggregateOutputType> | number
          }
        }
      }
      WorkflowExecution: {
        payload: Prisma.$WorkflowExecutionPayload<ExtArgs>
        fields: Prisma.WorkflowExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
          }
          findFirst: {
            args: Prisma.WorkflowExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
          }
          findMany: {
            args: Prisma.WorkflowExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>[]
          }
          create: {
            args: Prisma.WorkflowExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
          }
          createMany: {
            args: Prisma.WorkflowExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>[]
          }
          delete: {
            args: Prisma.WorkflowExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
          }
          update: {
            args: Prisma.WorkflowExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
          }
          aggregate: {
            args: Prisma.WorkflowExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowExecution>
          }
          groupBy: {
            args: Prisma.WorkflowExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowExecutionCountAggregateOutputType> | number
          }
        }
      }
      NodeExecution: {
        payload: Prisma.$NodeExecutionPayload<ExtArgs>
        fields: Prisma.NodeExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NodeExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NodeExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeExecutionPayload>
          }
          findFirst: {
            args: Prisma.NodeExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NodeExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeExecutionPayload>
          }
          findMany: {
            args: Prisma.NodeExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeExecutionPayload>[]
          }
          create: {
            args: Prisma.NodeExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeExecutionPayload>
          }
          createMany: {
            args: Prisma.NodeExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NodeExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeExecutionPayload>[]
          }
          delete: {
            args: Prisma.NodeExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeExecutionPayload>
          }
          update: {
            args: Prisma.NodeExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeExecutionPayload>
          }
          deleteMany: {
            args: Prisma.NodeExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NodeExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NodeExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeExecutionPayload>
          }
          aggregate: {
            args: Prisma.NodeExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNodeExecution>
          }
          groupBy: {
            args: Prisma.NodeExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<NodeExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.NodeExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<NodeExecutionCountAggregateOutputType> | number
          }
        }
      }
      NodeLog: {
        payload: Prisma.$NodeLogPayload<ExtArgs>
        fields: Prisma.NodeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NodeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NodeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeLogPayload>
          }
          findFirst: {
            args: Prisma.NodeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NodeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeLogPayload>
          }
          findMany: {
            args: Prisma.NodeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeLogPayload>[]
          }
          create: {
            args: Prisma.NodeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeLogPayload>
          }
          createMany: {
            args: Prisma.NodeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NodeLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeLogPayload>[]
          }
          delete: {
            args: Prisma.NodeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeLogPayload>
          }
          update: {
            args: Prisma.NodeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeLogPayload>
          }
          deleteMany: {
            args: Prisma.NodeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NodeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NodeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeLogPayload>
          }
          aggregate: {
            args: Prisma.NodeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNodeLog>
          }
          groupBy: {
            args: Prisma.NodeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<NodeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.NodeLogCountArgs<ExtArgs>
            result: $Utils.Optional<NodeLogCountAggregateOutputType> | number
          }
        }
      }
      NodeInput: {
        payload: Prisma.$NodeInputPayload<ExtArgs>
        fields: Prisma.NodeInputFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NodeInputFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeInputPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NodeInputFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeInputPayload>
          }
          findFirst: {
            args: Prisma.NodeInputFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeInputPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NodeInputFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeInputPayload>
          }
          findMany: {
            args: Prisma.NodeInputFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeInputPayload>[]
          }
          create: {
            args: Prisma.NodeInputCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeInputPayload>
          }
          createMany: {
            args: Prisma.NodeInputCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NodeInputCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeInputPayload>[]
          }
          delete: {
            args: Prisma.NodeInputDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeInputPayload>
          }
          update: {
            args: Prisma.NodeInputUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeInputPayload>
          }
          deleteMany: {
            args: Prisma.NodeInputDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NodeInputUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NodeInputUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeInputPayload>
          }
          aggregate: {
            args: Prisma.NodeInputAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNodeInput>
          }
          groupBy: {
            args: Prisma.NodeInputGroupByArgs<ExtArgs>
            result: $Utils.Optional<NodeInputGroupByOutputType>[]
          }
          count: {
            args: Prisma.NodeInputCountArgs<ExtArgs>
            result: $Utils.Optional<NodeInputCountAggregateOutputType> | number
          }
        }
      }
      NodeOutput: {
        payload: Prisma.$NodeOutputPayload<ExtArgs>
        fields: Prisma.NodeOutputFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NodeOutputFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeOutputPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NodeOutputFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeOutputPayload>
          }
          findFirst: {
            args: Prisma.NodeOutputFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeOutputPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NodeOutputFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeOutputPayload>
          }
          findMany: {
            args: Prisma.NodeOutputFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeOutputPayload>[]
          }
          create: {
            args: Prisma.NodeOutputCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeOutputPayload>
          }
          createMany: {
            args: Prisma.NodeOutputCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NodeOutputCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeOutputPayload>[]
          }
          delete: {
            args: Prisma.NodeOutputDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeOutputPayload>
          }
          update: {
            args: Prisma.NodeOutputUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeOutputPayload>
          }
          deleteMany: {
            args: Prisma.NodeOutputDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NodeOutputUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NodeOutputUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeOutputPayload>
          }
          aggregate: {
            args: Prisma.NodeOutputAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNodeOutput>
          }
          groupBy: {
            args: Prisma.NodeOutputGroupByArgs<ExtArgs>
            result: $Utils.Optional<NodeOutputGroupByOutputType>[]
          }
          count: {
            args: Prisma.NodeOutputCountArgs<ExtArgs>
            result: $Utils.Optional<NodeOutputCountAggregateOutputType> | number
          }
        }
      }
      ExecutionLog: {
        payload: Prisma.$ExecutionLogPayload<ExtArgs>
        fields: Prisma.ExecutionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExecutionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExecutionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload>
          }
          findFirst: {
            args: Prisma.ExecutionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExecutionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload>
          }
          findMany: {
            args: Prisma.ExecutionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload>[]
          }
          create: {
            args: Prisma.ExecutionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload>
          }
          createMany: {
            args: Prisma.ExecutionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExecutionLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload>[]
          }
          delete: {
            args: Prisma.ExecutionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload>
          }
          update: {
            args: Prisma.ExecutionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload>
          }
          deleteMany: {
            args: Prisma.ExecutionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExecutionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExecutionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload>
          }
          aggregate: {
            args: Prisma.ExecutionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExecutionLog>
          }
          groupBy: {
            args: Prisma.ExecutionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExecutionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExecutionLogCountArgs<ExtArgs>
            result: $Utils.Optional<ExecutionLogCountAggregateOutputType> | number
          }
        }
      }
      WorkflowPause: {
        payload: Prisma.$WorkflowPausePayload<ExtArgs>
        fields: Prisma.WorkflowPauseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowPauseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPausePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowPauseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPausePayload>
          }
          findFirst: {
            args: Prisma.WorkflowPauseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPausePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowPauseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPausePayload>
          }
          findMany: {
            args: Prisma.WorkflowPauseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPausePayload>[]
          }
          create: {
            args: Prisma.WorkflowPauseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPausePayload>
          }
          createMany: {
            args: Prisma.WorkflowPauseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowPauseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPausePayload>[]
          }
          delete: {
            args: Prisma.WorkflowPauseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPausePayload>
          }
          update: {
            args: Prisma.WorkflowPauseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPausePayload>
          }
          deleteMany: {
            args: Prisma.WorkflowPauseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowPauseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowPauseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPausePayload>
          }
          aggregate: {
            args: Prisma.WorkflowPauseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowPause>
          }
          groupBy: {
            args: Prisma.WorkflowPauseGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowPauseGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowPauseCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowPauseCountAggregateOutputType> | number
          }
        }
      }
      BlockchainTransaction: {
        payload: Prisma.$BlockchainTransactionPayload<ExtArgs>
        fields: Prisma.BlockchainTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockchainTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockchainTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload>
          }
          findFirst: {
            args: Prisma.BlockchainTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockchainTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload>
          }
          findMany: {
            args: Prisma.BlockchainTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload>[]
          }
          create: {
            args: Prisma.BlockchainTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload>
          }
          createMany: {
            args: Prisma.BlockchainTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockchainTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload>[]
          }
          delete: {
            args: Prisma.BlockchainTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload>
          }
          update: {
            args: Prisma.BlockchainTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload>
          }
          deleteMany: {
            args: Prisma.BlockchainTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockchainTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockchainTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload>
          }
          aggregate: {
            args: Prisma.BlockchainTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockchainTransaction>
          }
          groupBy: {
            args: Prisma.BlockchainTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockchainTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockchainTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<BlockchainTransactionCountAggregateOutputType> | number
          }
        }
      }
      TransactionAttempt: {
        payload: Prisma.$TransactionAttemptPayload<ExtArgs>
        fields: Prisma.TransactionAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAttemptPayload>
          }
          findFirst: {
            args: Prisma.TransactionAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAttemptPayload>
          }
          findMany: {
            args: Prisma.TransactionAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAttemptPayload>[]
          }
          create: {
            args: Prisma.TransactionAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAttemptPayload>
          }
          createMany: {
            args: Prisma.TransactionAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAttemptPayload>[]
          }
          delete: {
            args: Prisma.TransactionAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAttemptPayload>
          }
          update: {
            args: Prisma.TransactionAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAttemptPayload>
          }
          deleteMany: {
            args: Prisma.TransactionAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAttemptPayload>
          }
          aggregate: {
            args: Prisma.TransactionAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionAttempt>
          }
          groupBy: {
            args: Prisma.TransactionAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionAttemptCountAggregateOutputType> | number
          }
        }
      }
      AiBlockchainOperation: {
        payload: Prisma.$AiBlockchainOperationPayload<ExtArgs>
        fields: Prisma.AiBlockchainOperationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiBlockchainOperationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiBlockchainOperationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiBlockchainOperationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiBlockchainOperationPayload>
          }
          findFirst: {
            args: Prisma.AiBlockchainOperationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiBlockchainOperationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiBlockchainOperationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiBlockchainOperationPayload>
          }
          findMany: {
            args: Prisma.AiBlockchainOperationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiBlockchainOperationPayload>[]
          }
          create: {
            args: Prisma.AiBlockchainOperationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiBlockchainOperationPayload>
          }
          createMany: {
            args: Prisma.AiBlockchainOperationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiBlockchainOperationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiBlockchainOperationPayload>[]
          }
          delete: {
            args: Prisma.AiBlockchainOperationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiBlockchainOperationPayload>
          }
          update: {
            args: Prisma.AiBlockchainOperationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiBlockchainOperationPayload>
          }
          deleteMany: {
            args: Prisma.AiBlockchainOperationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiBlockchainOperationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiBlockchainOperationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiBlockchainOperationPayload>
          }
          aggregate: {
            args: Prisma.AiBlockchainOperationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiBlockchainOperation>
          }
          groupBy: {
            args: Prisma.AiBlockchainOperationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiBlockchainOperationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiBlockchainOperationCountArgs<ExtArgs>
            result: $Utils.Optional<AiBlockchainOperationCountAggregateOutputType> | number
          }
        }
      }
      BlockExecution: {
        payload: Prisma.$BlockExecutionPayload<ExtArgs>
        fields: Prisma.BlockExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload>
          }
          findFirst: {
            args: Prisma.BlockExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload>
          }
          findMany: {
            args: Prisma.BlockExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload>[]
          }
          create: {
            args: Prisma.BlockExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload>
          }
          createMany: {
            args: Prisma.BlockExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload>[]
          }
          delete: {
            args: Prisma.BlockExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload>
          }
          update: {
            args: Prisma.BlockExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload>
          }
          deleteMany: {
            args: Prisma.BlockExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload>
          }
          aggregate: {
            args: Prisma.BlockExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockExecution>
          }
          groupBy: {
            args: Prisma.BlockExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<BlockExecutionCountAggregateOutputType> | number
          }
        }
      }
      BlockExecutionLog: {
        payload: Prisma.$BlockExecutionLogPayload<ExtArgs>
        fields: Prisma.BlockExecutionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockExecutionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockExecutionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionLogPayload>
          }
          findFirst: {
            args: Prisma.BlockExecutionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockExecutionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionLogPayload>
          }
          findMany: {
            args: Prisma.BlockExecutionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionLogPayload>[]
          }
          create: {
            args: Prisma.BlockExecutionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionLogPayload>
          }
          createMany: {
            args: Prisma.BlockExecutionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockExecutionLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionLogPayload>[]
          }
          delete: {
            args: Prisma.BlockExecutionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionLogPayload>
          }
          update: {
            args: Prisma.BlockExecutionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionLogPayload>
          }
          deleteMany: {
            args: Prisma.BlockExecutionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockExecutionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockExecutionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionLogPayload>
          }
          aggregate: {
            args: Prisma.BlockExecutionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockExecutionLog>
          }
          groupBy: {
            args: Prisma.BlockExecutionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockExecutionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockExecutionLogCountArgs<ExtArgs>
            result: $Utils.Optional<BlockExecutionLogCountAggregateOutputType> | number
          }
        }
      }
      BlockLibrary: {
        payload: Prisma.$BlockLibraryPayload<ExtArgs>
        fields: Prisma.BlockLibraryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockLibraryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockLibraryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryPayload>
          }
          findFirst: {
            args: Prisma.BlockLibraryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockLibraryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryPayload>
          }
          findMany: {
            args: Prisma.BlockLibraryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryPayload>[]
          }
          create: {
            args: Prisma.BlockLibraryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryPayload>
          }
          createMany: {
            args: Prisma.BlockLibraryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockLibraryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryPayload>[]
          }
          delete: {
            args: Prisma.BlockLibraryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryPayload>
          }
          update: {
            args: Prisma.BlockLibraryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryPayload>
          }
          deleteMany: {
            args: Prisma.BlockLibraryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockLibraryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockLibraryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryPayload>
          }
          aggregate: {
            args: Prisma.BlockLibraryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockLibrary>
          }
          groupBy: {
            args: Prisma.BlockLibraryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockLibraryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockLibraryCountArgs<ExtArgs>
            result: $Utils.Optional<BlockLibraryCountAggregateOutputType> | number
          }
        }
      }
      BlockLibraryRating: {
        payload: Prisma.$BlockLibraryRatingPayload<ExtArgs>
        fields: Prisma.BlockLibraryRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockLibraryRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockLibraryRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryRatingPayload>
          }
          findFirst: {
            args: Prisma.BlockLibraryRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockLibraryRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryRatingPayload>
          }
          findMany: {
            args: Prisma.BlockLibraryRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryRatingPayload>[]
          }
          create: {
            args: Prisma.BlockLibraryRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryRatingPayload>
          }
          createMany: {
            args: Prisma.BlockLibraryRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockLibraryRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryRatingPayload>[]
          }
          delete: {
            args: Prisma.BlockLibraryRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryRatingPayload>
          }
          update: {
            args: Prisma.BlockLibraryRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryRatingPayload>
          }
          deleteMany: {
            args: Prisma.BlockLibraryRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockLibraryRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockLibraryRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockLibraryRatingPayload>
          }
          aggregate: {
            args: Prisma.BlockLibraryRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockLibraryRating>
          }
          groupBy: {
            args: Prisma.BlockLibraryRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockLibraryRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockLibraryRatingCountArgs<ExtArgs>
            result: $Utils.Optional<BlockLibraryRatingCountAggregateOutputType> | number
          }
        }
      }
      CustomBlock: {
        payload: Prisma.$CustomBlockPayload<ExtArgs>
        fields: Prisma.CustomBlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomBlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomBlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomBlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomBlockPayload>
          }
          findFirst: {
            args: Prisma.CustomBlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomBlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomBlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomBlockPayload>
          }
          findMany: {
            args: Prisma.CustomBlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomBlockPayload>[]
          }
          create: {
            args: Prisma.CustomBlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomBlockPayload>
          }
          createMany: {
            args: Prisma.CustomBlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomBlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomBlockPayload>[]
          }
          delete: {
            args: Prisma.CustomBlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomBlockPayload>
          }
          update: {
            args: Prisma.CustomBlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomBlockPayload>
          }
          deleteMany: {
            args: Prisma.CustomBlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomBlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomBlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomBlockPayload>
          }
          aggregate: {
            args: Prisma.CustomBlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomBlock>
          }
          groupBy: {
            args: Prisma.CustomBlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomBlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomBlockCountArgs<ExtArgs>
            result: $Utils.Optional<CustomBlockCountAggregateOutputType> | number
          }
        }
      }
      ExecutionQueue: {
        payload: Prisma.$ExecutionQueuePayload<ExtArgs>
        fields: Prisma.ExecutionQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExecutionQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExecutionQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionQueuePayload>
          }
          findFirst: {
            args: Prisma.ExecutionQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExecutionQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionQueuePayload>
          }
          findMany: {
            args: Prisma.ExecutionQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionQueuePayload>[]
          }
          create: {
            args: Prisma.ExecutionQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionQueuePayload>
          }
          createMany: {
            args: Prisma.ExecutionQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExecutionQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionQueuePayload>[]
          }
          delete: {
            args: Prisma.ExecutionQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionQueuePayload>
          }
          update: {
            args: Prisma.ExecutionQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionQueuePayload>
          }
          deleteMany: {
            args: Prisma.ExecutionQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExecutionQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExecutionQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionQueuePayload>
          }
          aggregate: {
            args: Prisma.ExecutionQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExecutionQueue>
          }
          groupBy: {
            args: Prisma.ExecutionQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExecutionQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExecutionQueueCountArgs<ExtArgs>
            result: $Utils.Optional<ExecutionQueueCountAggregateOutputType> | number
          }
        }
      }
      ExecutionNodeStatus: {
        payload: Prisma.$ExecutionNodeStatusPayload<ExtArgs>
        fields: Prisma.ExecutionNodeStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExecutionNodeStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionNodeStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExecutionNodeStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionNodeStatusPayload>
          }
          findFirst: {
            args: Prisma.ExecutionNodeStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionNodeStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExecutionNodeStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionNodeStatusPayload>
          }
          findMany: {
            args: Prisma.ExecutionNodeStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionNodeStatusPayload>[]
          }
          create: {
            args: Prisma.ExecutionNodeStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionNodeStatusPayload>
          }
          createMany: {
            args: Prisma.ExecutionNodeStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExecutionNodeStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionNodeStatusPayload>[]
          }
          delete: {
            args: Prisma.ExecutionNodeStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionNodeStatusPayload>
          }
          update: {
            args: Prisma.ExecutionNodeStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionNodeStatusPayload>
          }
          deleteMany: {
            args: Prisma.ExecutionNodeStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExecutionNodeStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExecutionNodeStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionNodeStatusPayload>
          }
          aggregate: {
            args: Prisma.ExecutionNodeStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExecutionNodeStatus>
          }
          groupBy: {
            args: Prisma.ExecutionNodeStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExecutionNodeStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExecutionNodeStatusCountArgs<ExtArgs>
            result: $Utils.Optional<ExecutionNodeStatusCountAggregateOutputType> | number
          }
        }
      }
      CircuitBreakerState: {
        payload: Prisma.$CircuitBreakerStatePayload<ExtArgs>
        fields: Prisma.CircuitBreakerStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CircuitBreakerStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CircuitBreakerStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerStatePayload>
          }
          findFirst: {
            args: Prisma.CircuitBreakerStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CircuitBreakerStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerStatePayload>
          }
          findMany: {
            args: Prisma.CircuitBreakerStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerStatePayload>[]
          }
          create: {
            args: Prisma.CircuitBreakerStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerStatePayload>
          }
          createMany: {
            args: Prisma.CircuitBreakerStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CircuitBreakerStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerStatePayload>[]
          }
          delete: {
            args: Prisma.CircuitBreakerStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerStatePayload>
          }
          update: {
            args: Prisma.CircuitBreakerStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerStatePayload>
          }
          deleteMany: {
            args: Prisma.CircuitBreakerStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CircuitBreakerStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CircuitBreakerStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerStatePayload>
          }
          aggregate: {
            args: Prisma.CircuitBreakerStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCircuitBreakerState>
          }
          groupBy: {
            args: Prisma.CircuitBreakerStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CircuitBreakerStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CircuitBreakerStateCountArgs<ExtArgs>
            result: $Utils.Optional<CircuitBreakerStateCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
      NotificationTemplate: {
        payload: Prisma.$NotificationTemplatePayload<ExtArgs>
        fields: Prisma.NotificationTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          findFirst: {
            args: Prisma.NotificationTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          findMany: {
            args: Prisma.NotificationTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[]
          }
          create: {
            args: Prisma.NotificationTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          createMany: {
            args: Prisma.NotificationTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[]
          }
          delete: {
            args: Prisma.NotificationTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          update: {
            args: Prisma.NotificationTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          deleteMany: {
            args: Prisma.NotificationTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          aggregate: {
            args: Prisma.NotificationTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationTemplate>
          }
          groupBy: {
            args: Prisma.NotificationTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationTemplateCountAggregateOutputType> | number
          }
        }
      }
      NotificationLog: {
        payload: Prisma.$NotificationLogPayload<ExtArgs>
        fields: Prisma.NotificationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findFirst: {
            args: Prisma.NotificationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findMany: {
            args: Prisma.NotificationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          create: {
            args: Prisma.NotificationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          createMany: {
            args: Prisma.NotificationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          delete: {
            args: Prisma.NotificationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          update: {
            args: Prisma.NotificationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          deleteMany: {
            args: Prisma.NotificationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          aggregate: {
            args: Prisma.NotificationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationLog>
          }
          groupBy: {
            args: Prisma.NotificationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationLogCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogCountAggregateOutputType> | number
          }
        }
      }
      PricingTier: {
        payload: Prisma.$PricingTierPayload<ExtArgs>
        fields: Prisma.PricingTierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PricingTierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingTierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PricingTierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingTierPayload>
          }
          findFirst: {
            args: Prisma.PricingTierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingTierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PricingTierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingTierPayload>
          }
          findMany: {
            args: Prisma.PricingTierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingTierPayload>[]
          }
          create: {
            args: Prisma.PricingTierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingTierPayload>
          }
          createMany: {
            args: Prisma.PricingTierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PricingTierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingTierPayload>[]
          }
          delete: {
            args: Prisma.PricingTierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingTierPayload>
          }
          update: {
            args: Prisma.PricingTierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingTierPayload>
          }
          deleteMany: {
            args: Prisma.PricingTierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PricingTierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PricingTierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingTierPayload>
          }
          aggregate: {
            args: Prisma.PricingTierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePricingTier>
          }
          groupBy: {
            args: Prisma.PricingTierGroupByArgs<ExtArgs>
            result: $Utils.Optional<PricingTierGroupByOutputType>[]
          }
          count: {
            args: Prisma.PricingTierCountArgs<ExtArgs>
            result: $Utils.Optional<PricingTierCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionInvoice: {
        payload: Prisma.$SubscriptionInvoicePayload<ExtArgs>
        fields: Prisma.SubscriptionInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionInvoicePayload>
          }
          findFirst: {
            args: Prisma.SubscriptionInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionInvoicePayload>
          }
          findMany: {
            args: Prisma.SubscriptionInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionInvoicePayload>[]
          }
          create: {
            args: Prisma.SubscriptionInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionInvoicePayload>
          }
          createMany: {
            args: Prisma.SubscriptionInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionInvoicePayload>[]
          }
          delete: {
            args: Prisma.SubscriptionInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionInvoicePayload>
          }
          update: {
            args: Prisma.SubscriptionInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionInvoicePayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionInvoicePayload>
          }
          aggregate: {
            args: Prisma.SubscriptionInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionInvoice>
          }
          groupBy: {
            args: Prisma.SubscriptionInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionInvoiceCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      UsageLog: {
        payload: Prisma.$UsageLogPayload<ExtArgs>
        fields: Prisma.UsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          findFirst: {
            args: Prisma.UsageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          findMany: {
            args: Prisma.UsageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>[]
          }
          create: {
            args: Prisma.UsageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          createMany: {
            args: Prisma.UsageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>[]
          }
          delete: {
            args: Prisma.UsageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          update: {
            args: Prisma.UsageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          deleteMany: {
            args: Prisma.UsageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          aggregate: {
            args: Prisma.UsageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageLog>
          }
          groupBy: {
            args: Prisma.UsageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageLogCountArgs<ExtArgs>
            result: $Utils.Optional<UsageLogCountAggregateOutputType> | number
          }
        }
      }
      WalletTransaction: {
        payload: Prisma.$WalletTransactionPayload<ExtArgs>
        fields: Prisma.WalletTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findFirst: {
            args: Prisma.WalletTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findMany: {
            args: Prisma.WalletTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          create: {
            args: Prisma.WalletTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          createMany: {
            args: Prisma.WalletTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          delete: {
            args: Prisma.WalletTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          update: {
            args: Prisma.WalletTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          deleteMany: {
            args: Prisma.WalletTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WalletTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          aggregate: {
            args: Prisma.WalletTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWalletTransaction>
          }
          groupBy: {
            args: Prisma.WalletTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    userWallets: number
    workflows: number
    workflowExecutions: number
    notifications: number
    teamMemberships: number
    ownedTeams: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userWallets?: boolean | UserCountOutputTypeCountUserWalletsArgs
    workflows?: boolean | UserCountOutputTypeCountWorkflowsArgs
    workflowExecutions?: boolean | UserCountOutputTypeCountWorkflowExecutionsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    teamMemberships?: boolean | UserCountOutputTypeCountTeamMembershipsArgs
    ownedTeams?: boolean | UserCountOutputTypeCountOwnedTeamsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserWalletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWalletWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkflowExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowExecutionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }


  /**
   * Count Type WorkflowCountOutputType
   */

  export type WorkflowCountOutputType = {
    executions: number
    pauses: number
  }

  export type WorkflowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | WorkflowCountOutputTypeCountExecutionsArgs
    pauses?: boolean | WorkflowCountOutputTypeCountPausesArgs
  }

  // Custom InputTypes
  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowCountOutputType
     */
    select?: WorkflowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowExecutionWhereInput
  }

  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeCountPausesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowPauseWhereInput
  }


  /**
   * Count Type WorkflowExecutionCountOutputType
   */

  export type WorkflowExecutionCountOutputType = {
    nodeExecutions: number
    executionLogs: number
    blockExecutions: number
    blockchainTransactions: number
    workflowPauses: number
  }

  export type WorkflowExecutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodeExecutions?: boolean | WorkflowExecutionCountOutputTypeCountNodeExecutionsArgs
    executionLogs?: boolean | WorkflowExecutionCountOutputTypeCountExecutionLogsArgs
    blockExecutions?: boolean | WorkflowExecutionCountOutputTypeCountBlockExecutionsArgs
    blockchainTransactions?: boolean | WorkflowExecutionCountOutputTypeCountBlockchainTransactionsArgs
    workflowPauses?: boolean | WorkflowExecutionCountOutputTypeCountWorkflowPausesArgs
  }

  // Custom InputTypes
  /**
   * WorkflowExecutionCountOutputType without action
   */
  export type WorkflowExecutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecutionCountOutputType
     */
    select?: WorkflowExecutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkflowExecutionCountOutputType without action
   */
  export type WorkflowExecutionCountOutputTypeCountNodeExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeExecutionWhereInput
  }

  /**
   * WorkflowExecutionCountOutputType without action
   */
  export type WorkflowExecutionCountOutputTypeCountExecutionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExecutionLogWhereInput
  }

  /**
   * WorkflowExecutionCountOutputType without action
   */
  export type WorkflowExecutionCountOutputTypeCountBlockExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockExecutionWhereInput
  }

  /**
   * WorkflowExecutionCountOutputType without action
   */
  export type WorkflowExecutionCountOutputTypeCountBlockchainTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockchainTransactionWhereInput
  }

  /**
   * WorkflowExecutionCountOutputType without action
   */
  export type WorkflowExecutionCountOutputTypeCountWorkflowPausesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowPauseWhereInput
  }


  /**
   * Count Type NodeExecutionCountOutputType
   */

  export type NodeExecutionCountOutputType = {
    logs: number
    nodeInputs: number
    nodeOutputs: number
  }

  export type NodeExecutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | NodeExecutionCountOutputTypeCountLogsArgs
    nodeInputs?: boolean | NodeExecutionCountOutputTypeCountNodeInputsArgs
    nodeOutputs?: boolean | NodeExecutionCountOutputTypeCountNodeOutputsArgs
  }

  // Custom InputTypes
  /**
   * NodeExecutionCountOutputType without action
   */
  export type NodeExecutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeExecutionCountOutputType
     */
    select?: NodeExecutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NodeExecutionCountOutputType without action
   */
  export type NodeExecutionCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeLogWhereInput
  }

  /**
   * NodeExecutionCountOutputType without action
   */
  export type NodeExecutionCountOutputTypeCountNodeInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeInputWhereInput
  }

  /**
   * NodeExecutionCountOutputType without action
   */
  export type NodeExecutionCountOutputTypeCountNodeOutputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeOutputWhereInput
  }


  /**
   * Count Type BlockchainTransactionCountOutputType
   */

  export type BlockchainTransactionCountOutputType = {
    transactionAttempts: number
  }

  export type BlockchainTransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactionAttempts?: boolean | BlockchainTransactionCountOutputTypeCountTransactionAttemptsArgs
  }

  // Custom InputTypes
  /**
   * BlockchainTransactionCountOutputType without action
   */
  export type BlockchainTransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransactionCountOutputType
     */
    select?: BlockchainTransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlockchainTransactionCountOutputType without action
   */
  export type BlockchainTransactionCountOutputTypeCountTransactionAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionAttemptWhereInput
  }


  /**
   * Count Type BlockExecutionCountOutputType
   */

  export type BlockExecutionCountOutputType = {
    logs: number
  }

  export type BlockExecutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | BlockExecutionCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * BlockExecutionCountOutputType without action
   */
  export type BlockExecutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecutionCountOutputType
     */
    select?: BlockExecutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlockExecutionCountOutputType without action
   */
  export type BlockExecutionCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockExecutionLogWhereInput
  }


  /**
   * Count Type BlockLibraryCountOutputType
   */

  export type BlockLibraryCountOutputType = {
    ratings: number
  }

  export type BlockLibraryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ratings?: boolean | BlockLibraryCountOutputTypeCountRatingsArgs
  }

  // Custom InputTypes
  /**
   * BlockLibraryCountOutputType without action
   */
  export type BlockLibraryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibraryCountOutputType
     */
    select?: BlockLibraryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlockLibraryCountOutputType without action
   */
  export type BlockLibraryCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockLibraryRatingWhereInput
  }


  /**
   * Count Type PricingTierCountOutputType
   */

  export type PricingTierCountOutputType = {
    subscriptions: number
  }

  export type PricingTierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | PricingTierCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * PricingTierCountOutputType without action
   */
  export type PricingTierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingTierCountOutputType
     */
    select?: PricingTierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PricingTierCountOutputType without action
   */
  export type PricingTierCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    invoices: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | SubscriptionCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionInvoiceWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    members: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | TeamCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string | null
    phone: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    userWallets?: boolean | User$userWalletsArgs<ExtArgs>
    workflows?: boolean | User$workflowsArgs<ExtArgs>
    workflowExecutions?: boolean | User$workflowExecutionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    ownedTeams?: boolean | User$ownedTeamsArgs<ExtArgs>
    notificationPreferences?: boolean | User$notificationPreferencesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    userWallets?: boolean | User$userWalletsArgs<ExtArgs>
    workflows?: boolean | User$workflowsArgs<ExtArgs>
    workflowExecutions?: boolean | User$workflowExecutionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    ownedTeams?: boolean | User$ownedTeamsArgs<ExtArgs>
    notificationPreferences?: boolean | User$notificationPreferencesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      userWallets: Prisma.$UserWalletPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
      workflowExecutions: Prisma.$WorkflowExecutionPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      teamMemberships: Prisma.$TeamMemberPayload<ExtArgs>[]
      ownedTeams: Prisma.$TeamPayload<ExtArgs>[]
      notificationPreferences: Prisma.$NotificationPreferencePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      phone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    userWallets<T extends User$userWalletsArgs<ExtArgs> = {}>(args?: Subset<T, User$userWalletsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "findMany"> | Null>
    workflows<T extends User$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, User$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findMany"> | Null>
    workflowExecutions<T extends User$workflowExecutionsArgs<ExtArgs> = {}>(args?: Subset<T, User$workflowExecutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    subscription<T extends User$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    teamMemberships<T extends User$teamMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany"> | Null>
    ownedTeams<T extends User$ownedTeamsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedTeamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany"> | Null>
    notificationPreferences<T extends User$notificationPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationPreferencesArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User.userWallets
   */
  export type User$userWalletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    where?: UserWalletWhereInput
    orderBy?: UserWalletOrderByWithRelationInput | UserWalletOrderByWithRelationInput[]
    cursor?: UserWalletWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserWalletScalarFieldEnum | UserWalletScalarFieldEnum[]
  }

  /**
   * User.workflows
   */
  export type User$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * User.workflowExecutions
   */
  export type User$workflowExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    where?: WorkflowExecutionWhereInput
    orderBy?: WorkflowExecutionOrderByWithRelationInput | WorkflowExecutionOrderByWithRelationInput[]
    cursor?: WorkflowExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowExecutionScalarFieldEnum | WorkflowExecutionScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.subscription
   */
  export type User$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * User.teamMemberships
   */
  export type User$teamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * User.ownedTeams
   */
  export type User$ownedTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * User.notificationPreferences
   */
  export type User$notificationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    monthlyExecutionQuota: number | null
    monthlyExecutionCount: number | null
    monthlyExecutionsUsed: number | null
  }

  export type ProfileSumAggregateOutputType = {
    monthlyExecutionQuota: number | null
    monthlyExecutionCount: number | null
    monthlyExecutionsUsed: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    email: string | null
    fullName: string | null
    avatarUrl: string | null
    subscriptionTier: string | null
    subscriptionStatus: string | null
    subscriptionExpiresAt: Date | null
    monthlyExecutionQuota: number | null
    monthlyExecutionCount: number | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastSeenAt: Date | null
    monthlyExecutionsUsed: number | null
    telegramChatId: string | null
    discordWebhookUrl: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    email: string | null
    fullName: string | null
    avatarUrl: string | null
    subscriptionTier: string | null
    subscriptionStatus: string | null
    subscriptionExpiresAt: Date | null
    monthlyExecutionQuota: number | null
    monthlyExecutionCount: number | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastSeenAt: Date | null
    monthlyExecutionsUsed: number | null
    telegramChatId: string | null
    discordWebhookUrl: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    email: number
    fullName: number
    avatarUrl: number
    subscriptionTier: number
    subscriptionStatus: number
    subscriptionExpiresAt: number
    monthlyExecutionQuota: number
    monthlyExecutionCount: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    createdAt: number
    updatedAt: number
    lastSeenAt: number
    monthlyExecutionsUsed: number
    telegramChatId: number
    discordWebhookUrl: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    monthlyExecutionQuota?: true
    monthlyExecutionCount?: true
    monthlyExecutionsUsed?: true
  }

  export type ProfileSumAggregateInputType = {
    monthlyExecutionQuota?: true
    monthlyExecutionCount?: true
    monthlyExecutionsUsed?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    avatarUrl?: true
    subscriptionTier?: true
    subscriptionStatus?: true
    subscriptionExpiresAt?: true
    monthlyExecutionQuota?: true
    monthlyExecutionCount?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    createdAt?: true
    updatedAt?: true
    lastSeenAt?: true
    monthlyExecutionsUsed?: true
    telegramChatId?: true
    discordWebhookUrl?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    avatarUrl?: true
    subscriptionTier?: true
    subscriptionStatus?: true
    subscriptionExpiresAt?: true
    monthlyExecutionQuota?: true
    monthlyExecutionCount?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    createdAt?: true
    updatedAt?: true
    lastSeenAt?: true
    monthlyExecutionsUsed?: true
    telegramChatId?: true
    discordWebhookUrl?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    avatarUrl?: true
    subscriptionTier?: true
    subscriptionStatus?: true
    subscriptionExpiresAt?: true
    monthlyExecutionQuota?: true
    monthlyExecutionCount?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    createdAt?: true
    updatedAt?: true
    lastSeenAt?: true
    monthlyExecutionsUsed?: true
    telegramChatId?: true
    discordWebhookUrl?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    email: string | null
    fullName: string | null
    avatarUrl: string | null
    subscriptionTier: string | null
    subscriptionStatus: string | null
    subscriptionExpiresAt: Date | null
    monthlyExecutionQuota: number | null
    monthlyExecutionCount: number | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastSeenAt: Date | null
    monthlyExecutionsUsed: number
    telegramChatId: string | null
    discordWebhookUrl: string | null
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    fullName?: boolean
    avatarUrl?: boolean
    subscriptionTier?: boolean
    subscriptionStatus?: boolean
    subscriptionExpiresAt?: boolean
    monthlyExecutionQuota?: boolean
    monthlyExecutionCount?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastSeenAt?: boolean
    monthlyExecutionsUsed?: boolean
    telegramChatId?: boolean
    discordWebhookUrl?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    fullName?: boolean
    avatarUrl?: boolean
    subscriptionTier?: boolean
    subscriptionStatus?: boolean
    subscriptionExpiresAt?: boolean
    monthlyExecutionQuota?: boolean
    monthlyExecutionCount?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastSeenAt?: boolean
    monthlyExecutionsUsed?: boolean
    telegramChatId?: boolean
    discordWebhookUrl?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    email?: boolean
    fullName?: boolean
    avatarUrl?: boolean
    subscriptionTier?: boolean
    subscriptionStatus?: boolean
    subscriptionExpiresAt?: boolean
    monthlyExecutionQuota?: boolean
    monthlyExecutionCount?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastSeenAt?: boolean
    monthlyExecutionsUsed?: boolean
    telegramChatId?: boolean
    discordWebhookUrl?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      fullName: string | null
      avatarUrl: string | null
      subscriptionTier: string | null
      subscriptionStatus: string | null
      subscriptionExpiresAt: Date | null
      monthlyExecutionQuota: number | null
      monthlyExecutionCount: number | null
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      createdAt: Date | null
      updatedAt: Date | null
      lastSeenAt: Date | null
      monthlyExecutionsUsed: number
      telegramChatId: string | null
      discordWebhookUrl: string | null
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly email: FieldRef<"Profile", 'String'>
    readonly fullName: FieldRef<"Profile", 'String'>
    readonly avatarUrl: FieldRef<"Profile", 'String'>
    readonly subscriptionTier: FieldRef<"Profile", 'String'>
    readonly subscriptionStatus: FieldRef<"Profile", 'String'>
    readonly subscriptionExpiresAt: FieldRef<"Profile", 'DateTime'>
    readonly monthlyExecutionQuota: FieldRef<"Profile", 'Int'>
    readonly monthlyExecutionCount: FieldRef<"Profile", 'Int'>
    readonly stripeCustomerId: FieldRef<"Profile", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Profile", 'String'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
    readonly lastSeenAt: FieldRef<"Profile", 'DateTime'>
    readonly monthlyExecutionsUsed: FieldRef<"Profile", 'Int'>
    readonly telegramChatId: FieldRef<"Profile", 'String'>
    readonly discordWebhookUrl: FieldRef<"Profile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model UserWallet
   */

  export type AggregateUserWallet = {
    _count: UserWalletCountAggregateOutputType | null
    _min: UserWalletMinAggregateOutputType | null
    _max: UserWalletMaxAggregateOutputType | null
  }

  export type UserWalletMinAggregateOutputType = {
    id: string | null
    userId: string | null
    chainId: string | null
    walletAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
    walletType: string | null
    chainType: string | null
  }

  export type UserWalletMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    chainId: string | null
    walletAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
    walletType: string | null
    chainType: string | null
  }

  export type UserWalletCountAggregateOutputType = {
    id: number
    userId: number
    chainId: number
    walletAddress: number
    createdAt: number
    updatedAt: number
    walletType: number
    chainType: number
    metadata: number
    _all: number
  }


  export type UserWalletMinAggregateInputType = {
    id?: true
    userId?: true
    chainId?: true
    walletAddress?: true
    createdAt?: true
    updatedAt?: true
    walletType?: true
    chainType?: true
  }

  export type UserWalletMaxAggregateInputType = {
    id?: true
    userId?: true
    chainId?: true
    walletAddress?: true
    createdAt?: true
    updatedAt?: true
    walletType?: true
    chainType?: true
  }

  export type UserWalletCountAggregateInputType = {
    id?: true
    userId?: true
    chainId?: true
    walletAddress?: true
    createdAt?: true
    updatedAt?: true
    walletType?: true
    chainType?: true
    metadata?: true
    _all?: true
  }

  export type UserWalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserWallet to aggregate.
     */
    where?: UserWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWallets to fetch.
     */
    orderBy?: UserWalletOrderByWithRelationInput | UserWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserWallets
    **/
    _count?: true | UserWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserWalletMaxAggregateInputType
  }

  export type GetUserWalletAggregateType<T extends UserWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateUserWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserWallet[P]>
      : GetScalarType<T[P], AggregateUserWallet[P]>
  }




  export type UserWalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWalletWhereInput
    orderBy?: UserWalletOrderByWithAggregationInput | UserWalletOrderByWithAggregationInput[]
    by: UserWalletScalarFieldEnum[] | UserWalletScalarFieldEnum
    having?: UserWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserWalletCountAggregateInputType | true
    _min?: UserWalletMinAggregateInputType
    _max?: UserWalletMaxAggregateInputType
  }

  export type UserWalletGroupByOutputType = {
    id: string
    userId: string
    chainId: string
    walletAddress: string
    createdAt: Date
    updatedAt: Date
    walletType: string | null
    chainType: string | null
    metadata: JsonValue | null
    _count: UserWalletCountAggregateOutputType | null
    _min: UserWalletMinAggregateOutputType | null
    _max: UserWalletMaxAggregateOutputType | null
  }

  type GetUserWalletGroupByPayload<T extends UserWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserWalletGroupByOutputType[P]>
            : GetScalarType<T[P], UserWalletGroupByOutputType[P]>
        }
      >
    >


  export type UserWalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    chainId?: boolean
    walletAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    walletType?: boolean
    chainType?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userWallet"]>

  export type UserWalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    chainId?: boolean
    walletAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    walletType?: boolean
    chainType?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userWallet"]>

  export type UserWalletSelectScalar = {
    id?: boolean
    userId?: boolean
    chainId?: boolean
    walletAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    walletType?: boolean
    chainType?: boolean
    metadata?: boolean
  }

  export type UserWalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserWalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserWalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserWallet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      chainId: string
      walletAddress: string
      createdAt: Date
      updatedAt: Date
      walletType: string | null
      chainType: string | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["userWallet"]>
    composites: {}
  }

  type UserWalletGetPayload<S extends boolean | null | undefined | UserWalletDefaultArgs> = $Result.GetResult<Prisma.$UserWalletPayload, S>

  type UserWalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserWalletFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserWalletCountAggregateInputType | true
    }

  export interface UserWalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserWallet'], meta: { name: 'UserWallet' } }
    /**
     * Find zero or one UserWallet that matches the filter.
     * @param {UserWalletFindUniqueArgs} args - Arguments to find a UserWallet
     * @example
     * // Get one UserWallet
     * const userWallet = await prisma.userWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserWalletFindUniqueArgs>(args: SelectSubset<T, UserWalletFindUniqueArgs<ExtArgs>>): Prisma__UserWalletClient<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserWallet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserWalletFindUniqueOrThrowArgs} args - Arguments to find a UserWallet
     * @example
     * // Get one UserWallet
     * const userWallet = await prisma.userWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserWalletFindUniqueOrThrowArgs>(args: SelectSubset<T, UserWalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserWalletClient<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWalletFindFirstArgs} args - Arguments to find a UserWallet
     * @example
     * // Get one UserWallet
     * const userWallet = await prisma.userWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserWalletFindFirstArgs>(args?: SelectSubset<T, UserWalletFindFirstArgs<ExtArgs>>): Prisma__UserWalletClient<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWalletFindFirstOrThrowArgs} args - Arguments to find a UserWallet
     * @example
     * // Get one UserWallet
     * const userWallet = await prisma.userWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserWalletFindFirstOrThrowArgs>(args?: SelectSubset<T, UserWalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserWalletClient<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserWallets
     * const userWallets = await prisma.userWallet.findMany()
     * 
     * // Get first 10 UserWallets
     * const userWallets = await prisma.userWallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWalletWithIdOnly = await prisma.userWallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserWalletFindManyArgs>(args?: SelectSubset<T, UserWalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserWallet.
     * @param {UserWalletCreateArgs} args - Arguments to create a UserWallet.
     * @example
     * // Create one UserWallet
     * const UserWallet = await prisma.userWallet.create({
     *   data: {
     *     // ... data to create a UserWallet
     *   }
     * })
     * 
     */
    create<T extends UserWalletCreateArgs>(args: SelectSubset<T, UserWalletCreateArgs<ExtArgs>>): Prisma__UserWalletClient<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserWallets.
     * @param {UserWalletCreateManyArgs} args - Arguments to create many UserWallets.
     * @example
     * // Create many UserWallets
     * const userWallet = await prisma.userWallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserWalletCreateManyArgs>(args?: SelectSubset<T, UserWalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserWallets and returns the data saved in the database.
     * @param {UserWalletCreateManyAndReturnArgs} args - Arguments to create many UserWallets.
     * @example
     * // Create many UserWallets
     * const userWallet = await prisma.userWallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserWallets and only return the `id`
     * const userWalletWithIdOnly = await prisma.userWallet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserWalletCreateManyAndReturnArgs>(args?: SelectSubset<T, UserWalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserWallet.
     * @param {UserWalletDeleteArgs} args - Arguments to delete one UserWallet.
     * @example
     * // Delete one UserWallet
     * const UserWallet = await prisma.userWallet.delete({
     *   where: {
     *     // ... filter to delete one UserWallet
     *   }
     * })
     * 
     */
    delete<T extends UserWalletDeleteArgs>(args: SelectSubset<T, UserWalletDeleteArgs<ExtArgs>>): Prisma__UserWalletClient<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserWallet.
     * @param {UserWalletUpdateArgs} args - Arguments to update one UserWallet.
     * @example
     * // Update one UserWallet
     * const userWallet = await prisma.userWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserWalletUpdateArgs>(args: SelectSubset<T, UserWalletUpdateArgs<ExtArgs>>): Prisma__UserWalletClient<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserWallets.
     * @param {UserWalletDeleteManyArgs} args - Arguments to filter UserWallets to delete.
     * @example
     * // Delete a few UserWallets
     * const { count } = await prisma.userWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserWalletDeleteManyArgs>(args?: SelectSubset<T, UserWalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserWallets
     * const userWallet = await prisma.userWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserWalletUpdateManyArgs>(args: SelectSubset<T, UserWalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserWallet.
     * @param {UserWalletUpsertArgs} args - Arguments to update or create a UserWallet.
     * @example
     * // Update or create a UserWallet
     * const userWallet = await prisma.userWallet.upsert({
     *   create: {
     *     // ... data to create a UserWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserWallet we want to update
     *   }
     * })
     */
    upsert<T extends UserWalletUpsertArgs>(args: SelectSubset<T, UserWalletUpsertArgs<ExtArgs>>): Prisma__UserWalletClient<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWalletCountArgs} args - Arguments to filter UserWallets to count.
     * @example
     * // Count the number of UserWallets
     * const count = await prisma.userWallet.count({
     *   where: {
     *     // ... the filter for the UserWallets we want to count
     *   }
     * })
    **/
    count<T extends UserWalletCountArgs>(
      args?: Subset<T, UserWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserWalletAggregateArgs>(args: Subset<T, UserWalletAggregateArgs>): Prisma.PrismaPromise<GetUserWalletAggregateType<T>>

    /**
     * Group by UserWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserWalletGroupByArgs['orderBy'] }
        : { orderBy?: UserWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserWallet model
   */
  readonly fields: UserWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserWalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserWallet model
   */ 
  interface UserWalletFieldRefs {
    readonly id: FieldRef<"UserWallet", 'String'>
    readonly userId: FieldRef<"UserWallet", 'String'>
    readonly chainId: FieldRef<"UserWallet", 'String'>
    readonly walletAddress: FieldRef<"UserWallet", 'String'>
    readonly createdAt: FieldRef<"UserWallet", 'DateTime'>
    readonly updatedAt: FieldRef<"UserWallet", 'DateTime'>
    readonly walletType: FieldRef<"UserWallet", 'String'>
    readonly chainType: FieldRef<"UserWallet", 'String'>
    readonly metadata: FieldRef<"UserWallet", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * UserWallet findUnique
   */
  export type UserWalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * Filter, which UserWallet to fetch.
     */
    where: UserWalletWhereUniqueInput
  }

  /**
   * UserWallet findUniqueOrThrow
   */
  export type UserWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * Filter, which UserWallet to fetch.
     */
    where: UserWalletWhereUniqueInput
  }

  /**
   * UserWallet findFirst
   */
  export type UserWalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * Filter, which UserWallet to fetch.
     */
    where?: UserWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWallets to fetch.
     */
    orderBy?: UserWalletOrderByWithRelationInput | UserWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserWallets.
     */
    cursor?: UserWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserWallets.
     */
    distinct?: UserWalletScalarFieldEnum | UserWalletScalarFieldEnum[]
  }

  /**
   * UserWallet findFirstOrThrow
   */
  export type UserWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * Filter, which UserWallet to fetch.
     */
    where?: UserWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWallets to fetch.
     */
    orderBy?: UserWalletOrderByWithRelationInput | UserWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserWallets.
     */
    cursor?: UserWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserWallets.
     */
    distinct?: UserWalletScalarFieldEnum | UserWalletScalarFieldEnum[]
  }

  /**
   * UserWallet findMany
   */
  export type UserWalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * Filter, which UserWallets to fetch.
     */
    where?: UserWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWallets to fetch.
     */
    orderBy?: UserWalletOrderByWithRelationInput | UserWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserWallets.
     */
    cursor?: UserWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWallets.
     */
    skip?: number
    distinct?: UserWalletScalarFieldEnum | UserWalletScalarFieldEnum[]
  }

  /**
   * UserWallet create
   */
  export type UserWalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * The data needed to create a UserWallet.
     */
    data: XOR<UserWalletCreateInput, UserWalletUncheckedCreateInput>
  }

  /**
   * UserWallet createMany
   */
  export type UserWalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserWallets.
     */
    data: UserWalletCreateManyInput | UserWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserWallet createManyAndReturn
   */
  export type UserWalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserWallets.
     */
    data: UserWalletCreateManyInput | UserWalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserWallet update
   */
  export type UserWalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * The data needed to update a UserWallet.
     */
    data: XOR<UserWalletUpdateInput, UserWalletUncheckedUpdateInput>
    /**
     * Choose, which UserWallet to update.
     */
    where: UserWalletWhereUniqueInput
  }

  /**
   * UserWallet updateMany
   */
  export type UserWalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserWallets.
     */
    data: XOR<UserWalletUpdateManyMutationInput, UserWalletUncheckedUpdateManyInput>
    /**
     * Filter which UserWallets to update
     */
    where?: UserWalletWhereInput
  }

  /**
   * UserWallet upsert
   */
  export type UserWalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * The filter to search for the UserWallet to update in case it exists.
     */
    where: UserWalletWhereUniqueInput
    /**
     * In case the UserWallet found by the `where` argument doesn't exist, create a new UserWallet with this data.
     */
    create: XOR<UserWalletCreateInput, UserWalletUncheckedCreateInput>
    /**
     * In case the UserWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserWalletUpdateInput, UserWalletUncheckedUpdateInput>
  }

  /**
   * UserWallet delete
   */
  export type UserWalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * Filter which UserWallet to delete.
     */
    where: UserWalletWhereUniqueInput
  }

  /**
   * UserWallet deleteMany
   */
  export type UserWalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserWallets to delete
     */
    where?: UserWalletWhereInput
  }

  /**
   * UserWallet without action
   */
  export type UserWalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowTemplate
   */

  export type AggregateWorkflowTemplate = {
    _count: WorkflowTemplateCountAggregateOutputType | null
    _min: WorkflowTemplateMinAggregateOutputType | null
    _max: WorkflowTemplateMaxAggregateOutputType | null
  }

  export type WorkflowTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    nodes: number
    edges: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkflowTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    nodes?: true
    edges?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkflowTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowTemplate to aggregate.
     */
    where?: WorkflowTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowTemplates to fetch.
     */
    orderBy?: WorkflowTemplateOrderByWithRelationInput | WorkflowTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowTemplates
    **/
    _count?: true | WorkflowTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowTemplateMaxAggregateInputType
  }

  export type GetWorkflowTemplateAggregateType<T extends WorkflowTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowTemplate[P]>
      : GetScalarType<T[P], AggregateWorkflowTemplate[P]>
  }




  export type WorkflowTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowTemplateWhereInput
    orderBy?: WorkflowTemplateOrderByWithAggregationInput | WorkflowTemplateOrderByWithAggregationInput[]
    by: WorkflowTemplateScalarFieldEnum[] | WorkflowTemplateScalarFieldEnum
    having?: WorkflowTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowTemplateCountAggregateInputType | true
    _min?: WorkflowTemplateMinAggregateInputType
    _max?: WorkflowTemplateMaxAggregateInputType
  }

  export type WorkflowTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: string | null
    nodes: JsonValue | null
    edges: JsonValue | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: WorkflowTemplateCountAggregateOutputType | null
    _min: WorkflowTemplateMinAggregateOutputType | null
    _max: WorkflowTemplateMaxAggregateOutputType | null
  }

  type GetWorkflowTemplateGroupByPayload<T extends WorkflowTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowTemplateGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    nodes?: boolean
    edges?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["workflowTemplate"]>

  export type WorkflowTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    nodes?: boolean
    edges?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["workflowTemplate"]>

  export type WorkflowTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    nodes?: boolean
    edges?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $WorkflowTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: string | null
      nodes: Prisma.JsonValue | null
      edges: Prisma.JsonValue | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["workflowTemplate"]>
    composites: {}
  }

  type WorkflowTemplateGetPayload<S extends boolean | null | undefined | WorkflowTemplateDefaultArgs> = $Result.GetResult<Prisma.$WorkflowTemplatePayload, S>

  type WorkflowTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowTemplateCountAggregateInputType | true
    }

  export interface WorkflowTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowTemplate'], meta: { name: 'WorkflowTemplate' } }
    /**
     * Find zero or one WorkflowTemplate that matches the filter.
     * @param {WorkflowTemplateFindUniqueArgs} args - Arguments to find a WorkflowTemplate
     * @example
     * // Get one WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowTemplateFindUniqueArgs>(args: SelectSubset<T, WorkflowTemplateFindUniqueArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowTemplateFindUniqueOrThrowArgs} args - Arguments to find a WorkflowTemplate
     * @example
     * // Get one WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateFindFirstArgs} args - Arguments to find a WorkflowTemplate
     * @example
     * // Get one WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowTemplateFindFirstArgs>(args?: SelectSubset<T, WorkflowTemplateFindFirstArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateFindFirstOrThrowArgs} args - Arguments to find a WorkflowTemplate
     * @example
     * // Get one WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowTemplates
     * const workflowTemplates = await prisma.workflowTemplate.findMany()
     * 
     * // Get first 10 WorkflowTemplates
     * const workflowTemplates = await prisma.workflowTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowTemplateWithIdOnly = await prisma.workflowTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowTemplateFindManyArgs>(args?: SelectSubset<T, WorkflowTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowTemplate.
     * @param {WorkflowTemplateCreateArgs} args - Arguments to create a WorkflowTemplate.
     * @example
     * // Create one WorkflowTemplate
     * const WorkflowTemplate = await prisma.workflowTemplate.create({
     *   data: {
     *     // ... data to create a WorkflowTemplate
     *   }
     * })
     * 
     */
    create<T extends WorkflowTemplateCreateArgs>(args: SelectSubset<T, WorkflowTemplateCreateArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowTemplates.
     * @param {WorkflowTemplateCreateManyArgs} args - Arguments to create many WorkflowTemplates.
     * @example
     * // Create many WorkflowTemplates
     * const workflowTemplate = await prisma.workflowTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowTemplateCreateManyArgs>(args?: SelectSubset<T, WorkflowTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowTemplates and returns the data saved in the database.
     * @param {WorkflowTemplateCreateManyAndReturnArgs} args - Arguments to create many WorkflowTemplates.
     * @example
     * // Create many WorkflowTemplates
     * const workflowTemplate = await prisma.workflowTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowTemplates and only return the `id`
     * const workflowTemplateWithIdOnly = await prisma.workflowTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkflowTemplate.
     * @param {WorkflowTemplateDeleteArgs} args - Arguments to delete one WorkflowTemplate.
     * @example
     * // Delete one WorkflowTemplate
     * const WorkflowTemplate = await prisma.workflowTemplate.delete({
     *   where: {
     *     // ... filter to delete one WorkflowTemplate
     *   }
     * })
     * 
     */
    delete<T extends WorkflowTemplateDeleteArgs>(args: SelectSubset<T, WorkflowTemplateDeleteArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowTemplate.
     * @param {WorkflowTemplateUpdateArgs} args - Arguments to update one WorkflowTemplate.
     * @example
     * // Update one WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowTemplateUpdateArgs>(args: SelectSubset<T, WorkflowTemplateUpdateArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowTemplates.
     * @param {WorkflowTemplateDeleteManyArgs} args - Arguments to filter WorkflowTemplates to delete.
     * @example
     * // Delete a few WorkflowTemplates
     * const { count } = await prisma.workflowTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowTemplateDeleteManyArgs>(args?: SelectSubset<T, WorkflowTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowTemplates
     * const workflowTemplate = await prisma.workflowTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowTemplateUpdateManyArgs>(args: SelectSubset<T, WorkflowTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowTemplate.
     * @param {WorkflowTemplateUpsertArgs} args - Arguments to update or create a WorkflowTemplate.
     * @example
     * // Update or create a WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.upsert({
     *   create: {
     *     // ... data to create a WorkflowTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowTemplate we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowTemplateUpsertArgs>(args: SelectSubset<T, WorkflowTemplateUpsertArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateCountArgs} args - Arguments to filter WorkflowTemplates to count.
     * @example
     * // Count the number of WorkflowTemplates
     * const count = await prisma.workflowTemplate.count({
     *   where: {
     *     // ... the filter for the WorkflowTemplates we want to count
     *   }
     * })
    **/
    count<T extends WorkflowTemplateCountArgs>(
      args?: Subset<T, WorkflowTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowTemplateAggregateArgs>(args: Subset<T, WorkflowTemplateAggregateArgs>): Prisma.PrismaPromise<GetWorkflowTemplateAggregateType<T>>

    /**
     * Group by WorkflowTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowTemplateGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowTemplate model
   */
  readonly fields: WorkflowTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowTemplate model
   */ 
  interface WorkflowTemplateFieldRefs {
    readonly id: FieldRef<"WorkflowTemplate", 'String'>
    readonly name: FieldRef<"WorkflowTemplate", 'String'>
    readonly description: FieldRef<"WorkflowTemplate", 'String'>
    readonly category: FieldRef<"WorkflowTemplate", 'String'>
    readonly nodes: FieldRef<"WorkflowTemplate", 'Json'>
    readonly edges: FieldRef<"WorkflowTemplate", 'Json'>
    readonly createdAt: FieldRef<"WorkflowTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkflowTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowTemplate findUnique
   */
  export type WorkflowTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Filter, which WorkflowTemplate to fetch.
     */
    where: WorkflowTemplateWhereUniqueInput
  }

  /**
   * WorkflowTemplate findUniqueOrThrow
   */
  export type WorkflowTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Filter, which WorkflowTemplate to fetch.
     */
    where: WorkflowTemplateWhereUniqueInput
  }

  /**
   * WorkflowTemplate findFirst
   */
  export type WorkflowTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Filter, which WorkflowTemplate to fetch.
     */
    where?: WorkflowTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowTemplates to fetch.
     */
    orderBy?: WorkflowTemplateOrderByWithRelationInput | WorkflowTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowTemplates.
     */
    cursor?: WorkflowTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowTemplates.
     */
    distinct?: WorkflowTemplateScalarFieldEnum | WorkflowTemplateScalarFieldEnum[]
  }

  /**
   * WorkflowTemplate findFirstOrThrow
   */
  export type WorkflowTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Filter, which WorkflowTemplate to fetch.
     */
    where?: WorkflowTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowTemplates to fetch.
     */
    orderBy?: WorkflowTemplateOrderByWithRelationInput | WorkflowTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowTemplates.
     */
    cursor?: WorkflowTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowTemplates.
     */
    distinct?: WorkflowTemplateScalarFieldEnum | WorkflowTemplateScalarFieldEnum[]
  }

  /**
   * WorkflowTemplate findMany
   */
  export type WorkflowTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Filter, which WorkflowTemplates to fetch.
     */
    where?: WorkflowTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowTemplates to fetch.
     */
    orderBy?: WorkflowTemplateOrderByWithRelationInput | WorkflowTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowTemplates.
     */
    cursor?: WorkflowTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowTemplates.
     */
    skip?: number
    distinct?: WorkflowTemplateScalarFieldEnum | WorkflowTemplateScalarFieldEnum[]
  }

  /**
   * WorkflowTemplate create
   */
  export type WorkflowTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * The data needed to create a WorkflowTemplate.
     */
    data: XOR<WorkflowTemplateCreateInput, WorkflowTemplateUncheckedCreateInput>
  }

  /**
   * WorkflowTemplate createMany
   */
  export type WorkflowTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowTemplates.
     */
    data: WorkflowTemplateCreateManyInput | WorkflowTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowTemplate createManyAndReturn
   */
  export type WorkflowTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkflowTemplates.
     */
    data: WorkflowTemplateCreateManyInput | WorkflowTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowTemplate update
   */
  export type WorkflowTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * The data needed to update a WorkflowTemplate.
     */
    data: XOR<WorkflowTemplateUpdateInput, WorkflowTemplateUncheckedUpdateInput>
    /**
     * Choose, which WorkflowTemplate to update.
     */
    where: WorkflowTemplateWhereUniqueInput
  }

  /**
   * WorkflowTemplate updateMany
   */
  export type WorkflowTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowTemplates.
     */
    data: XOR<WorkflowTemplateUpdateManyMutationInput, WorkflowTemplateUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowTemplates to update
     */
    where?: WorkflowTemplateWhereInput
  }

  /**
   * WorkflowTemplate upsert
   */
  export type WorkflowTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * The filter to search for the WorkflowTemplate to update in case it exists.
     */
    where: WorkflowTemplateWhereUniqueInput
    /**
     * In case the WorkflowTemplate found by the `where` argument doesn't exist, create a new WorkflowTemplate with this data.
     */
    create: XOR<WorkflowTemplateCreateInput, WorkflowTemplateUncheckedCreateInput>
    /**
     * In case the WorkflowTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowTemplateUpdateInput, WorkflowTemplateUncheckedUpdateInput>
  }

  /**
   * WorkflowTemplate delete
   */
  export type WorkflowTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Filter which WorkflowTemplate to delete.
     */
    where: WorkflowTemplateWhereUniqueInput
  }

  /**
   * WorkflowTemplate deleteMany
   */
  export type WorkflowTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowTemplates to delete
     */
    where?: WorkflowTemplateWhereInput
  }

  /**
   * WorkflowTemplate without action
   */
  export type WorkflowTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
  }


  /**
   * Model Workflow
   */

  export type AggregateWorkflow = {
    _count: WorkflowCountAggregateOutputType | null
    _avg: WorkflowAvgAggregateOutputType | null
    _sum: WorkflowSumAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  export type WorkflowAvgAggregateOutputType = {
    version: number | null
  }

  export type WorkflowSumAggregateOutputType = {
    version: number | null
  }

  export type WorkflowMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    version: number | null
    createdBy: string | null
  }

  export type WorkflowMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    version: number | null
    createdBy: string | null
  }

  export type WorkflowCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    nodes: number
    edges: number
    isPublic: number
    tags: number
    createdAt: number
    updatedAt: number
    definition: number
    version: number
    createdBy: number
    _all: number
  }


  export type WorkflowAvgAggregateInputType = {
    version?: true
  }

  export type WorkflowSumAggregateInputType = {
    version?: true
  }

  export type WorkflowMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    version?: true
    createdBy?: true
  }

  export type WorkflowMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    version?: true
    createdBy?: true
  }

  export type WorkflowCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    nodes?: true
    edges?: true
    isPublic?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    definition?: true
    version?: true
    createdBy?: true
    _all?: true
  }

  export type WorkflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflow to aggregate.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workflows
    **/
    _count?: true | WorkflowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowMaxAggregateInputType
  }

  export type GetWorkflowAggregateType<T extends WorkflowAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflow[P]>
      : GetScalarType<T[P], AggregateWorkflow[P]>
  }




  export type WorkflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithAggregationInput | WorkflowOrderByWithAggregationInput[]
    by: WorkflowScalarFieldEnum[] | WorkflowScalarFieldEnum
    having?: WorkflowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowCountAggregateInputType | true
    _avg?: WorkflowAvgAggregateInputType
    _sum?: WorkflowSumAggregateInputType
    _min?: WorkflowMinAggregateInputType
    _max?: WorkflowMaxAggregateInputType
  }

  export type WorkflowGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string | null
    nodes: JsonValue | null
    edges: JsonValue | null
    isPublic: boolean | null
    tags: string[]
    createdAt: Date | null
    updatedAt: Date | null
    definition: JsonValue
    version: number
    createdBy: string | null
    _count: WorkflowCountAggregateOutputType | null
    _avg: WorkflowAvgAggregateOutputType | null
    _sum: WorkflowSumAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  type GetWorkflowGroupByPayload<T extends WorkflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    nodes?: boolean
    edges?: boolean
    isPublic?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    definition?: boolean
    version?: boolean
    createdBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | Workflow$executionsArgs<ExtArgs>
    pauses?: boolean | Workflow$pausesArgs<ExtArgs>
    _count?: boolean | WorkflowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    nodes?: boolean
    edges?: boolean
    isPublic?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    definition?: boolean
    version?: boolean
    createdBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    nodes?: boolean
    edges?: boolean
    isPublic?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    definition?: boolean
    version?: boolean
    createdBy?: boolean
  }

  export type WorkflowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | Workflow$executionsArgs<ExtArgs>
    pauses?: boolean | Workflow$pausesArgs<ExtArgs>
    _count?: boolean | WorkflowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkflowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workflow"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      executions: Prisma.$WorkflowExecutionPayload<ExtArgs>[]
      pauses: Prisma.$WorkflowPausePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string | null
      nodes: Prisma.JsonValue | null
      edges: Prisma.JsonValue | null
      isPublic: boolean | null
      tags: string[]
      createdAt: Date | null
      updatedAt: Date | null
      definition: Prisma.JsonValue
      version: number
      createdBy: string | null
    }, ExtArgs["result"]["workflow"]>
    composites: {}
  }

  type WorkflowGetPayload<S extends boolean | null | undefined | WorkflowDefaultArgs> = $Result.GetResult<Prisma.$WorkflowPayload, S>

  type WorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowCountAggregateInputType | true
    }

  export interface WorkflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workflow'], meta: { name: 'Workflow' } }
    /**
     * Find zero or one Workflow that matches the filter.
     * @param {WorkflowFindUniqueArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowFindUniqueArgs>(args: SelectSubset<T, WorkflowFindUniqueArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Workflow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowFindUniqueOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Workflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowFindFirstArgs>(args?: SelectSubset<T, WorkflowFindFirstArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Workflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Workflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workflows
     * const workflows = await prisma.workflow.findMany()
     * 
     * // Get first 10 Workflows
     * const workflows = await prisma.workflow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowWithIdOnly = await prisma.workflow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowFindManyArgs>(args?: SelectSubset<T, WorkflowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Workflow.
     * @param {WorkflowCreateArgs} args - Arguments to create a Workflow.
     * @example
     * // Create one Workflow
     * const Workflow = await prisma.workflow.create({
     *   data: {
     *     // ... data to create a Workflow
     *   }
     * })
     * 
     */
    create<T extends WorkflowCreateArgs>(args: SelectSubset<T, WorkflowCreateArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Workflows.
     * @param {WorkflowCreateManyArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowCreateManyArgs>(args?: SelectSubset<T, WorkflowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workflows and returns the data saved in the database.
     * @param {WorkflowCreateManyAndReturnArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workflows and only return the `id`
     * const workflowWithIdOnly = await prisma.workflow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Workflow.
     * @param {WorkflowDeleteArgs} args - Arguments to delete one Workflow.
     * @example
     * // Delete one Workflow
     * const Workflow = await prisma.workflow.delete({
     *   where: {
     *     // ... filter to delete one Workflow
     *   }
     * })
     * 
     */
    delete<T extends WorkflowDeleteArgs>(args: SelectSubset<T, WorkflowDeleteArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Workflow.
     * @param {WorkflowUpdateArgs} args - Arguments to update one Workflow.
     * @example
     * // Update one Workflow
     * const workflow = await prisma.workflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowUpdateArgs>(args: SelectSubset<T, WorkflowUpdateArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Workflows.
     * @param {WorkflowDeleteManyArgs} args - Arguments to filter Workflows to delete.
     * @example
     * // Delete a few Workflows
     * const { count } = await prisma.workflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowDeleteManyArgs>(args?: SelectSubset<T, WorkflowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowUpdateManyArgs>(args: SelectSubset<T, WorkflowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Workflow.
     * @param {WorkflowUpsertArgs} args - Arguments to update or create a Workflow.
     * @example
     * // Update or create a Workflow
     * const workflow = await prisma.workflow.upsert({
     *   create: {
     *     // ... data to create a Workflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workflow we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowUpsertArgs>(args: SelectSubset<T, WorkflowUpsertArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowCountArgs} args - Arguments to filter Workflows to count.
     * @example
     * // Count the number of Workflows
     * const count = await prisma.workflow.count({
     *   where: {
     *     // ... the filter for the Workflows we want to count
     *   }
     * })
    **/
    count<T extends WorkflowCountArgs>(
      args?: Subset<T, WorkflowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowAggregateArgs>(args: Subset<T, WorkflowAggregateArgs>): Prisma.PrismaPromise<GetWorkflowAggregateType<T>>

    /**
     * Group by Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workflow model
   */
  readonly fields: WorkflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    executions<T extends Workflow$executionsArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    pauses<T extends Workflow$pausesArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$pausesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPausePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workflow model
   */ 
  interface WorkflowFieldRefs {
    readonly id: FieldRef<"Workflow", 'String'>
    readonly userId: FieldRef<"Workflow", 'String'>
    readonly name: FieldRef<"Workflow", 'String'>
    readonly description: FieldRef<"Workflow", 'String'>
    readonly nodes: FieldRef<"Workflow", 'Json'>
    readonly edges: FieldRef<"Workflow", 'Json'>
    readonly isPublic: FieldRef<"Workflow", 'Boolean'>
    readonly tags: FieldRef<"Workflow", 'String[]'>
    readonly createdAt: FieldRef<"Workflow", 'DateTime'>
    readonly updatedAt: FieldRef<"Workflow", 'DateTime'>
    readonly definition: FieldRef<"Workflow", 'Json'>
    readonly version: FieldRef<"Workflow", 'Int'>
    readonly createdBy: FieldRef<"Workflow", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Workflow findUnique
   */
  export type WorkflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow findUniqueOrThrow
   */
  export type WorkflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow findFirst
   */
  export type WorkflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow findFirstOrThrow
   */
  export type WorkflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow findMany
   */
  export type WorkflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflows to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow create
   */
  export type WorkflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The data needed to create a Workflow.
     */
    data: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
  }

  /**
   * Workflow createMany
   */
  export type WorkflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workflow createManyAndReturn
   */
  export type WorkflowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workflow update
   */
  export type WorkflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The data needed to update a Workflow.
     */
    data: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
    /**
     * Choose, which Workflow to update.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow updateMany
   */
  export type WorkflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workflows.
     */
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>
    /**
     * Filter which Workflows to update
     */
    where?: WorkflowWhereInput
  }

  /**
   * Workflow upsert
   */
  export type WorkflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The filter to search for the Workflow to update in case it exists.
     */
    where: WorkflowWhereUniqueInput
    /**
     * In case the Workflow found by the `where` argument doesn't exist, create a new Workflow with this data.
     */
    create: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
    /**
     * In case the Workflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
  }

  /**
   * Workflow delete
   */
  export type WorkflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter which Workflow to delete.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow deleteMany
   */
  export type WorkflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflows to delete
     */
    where?: WorkflowWhereInput
  }

  /**
   * Workflow.executions
   */
  export type Workflow$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    where?: WorkflowExecutionWhereInput
    orderBy?: WorkflowExecutionOrderByWithRelationInput | WorkflowExecutionOrderByWithRelationInput[]
    cursor?: WorkflowExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowExecutionScalarFieldEnum | WorkflowExecutionScalarFieldEnum[]
  }

  /**
   * Workflow.pauses
   */
  export type Workflow$pausesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowPause
     */
    select?: WorkflowPauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowPauseInclude<ExtArgs> | null
    where?: WorkflowPauseWhereInput
    orderBy?: WorkflowPauseOrderByWithRelationInput | WorkflowPauseOrderByWithRelationInput[]
    cursor?: WorkflowPauseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowPauseScalarFieldEnum | WorkflowPauseScalarFieldEnum[]
  }

  /**
   * Workflow without action
   */
  export type WorkflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowExecution
   */

  export type AggregateWorkflowExecution = {
    _count: WorkflowExecutionCountAggregateOutputType | null
    _min: WorkflowExecutionMinAggregateOutputType | null
    _max: WorkflowExecutionMaxAggregateOutputType | null
  }

  export type WorkflowExecutionMinAggregateOutputType = {
    id: string | null
    workflowId: string | null
    userId: string | null
    status: $Enums.WorkflowStatus | null
    startedAt: Date | null
    finishedAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
    triggerType: string | null
    lockedBy: string | null
  }

  export type WorkflowExecutionMaxAggregateOutputType = {
    id: string | null
    workflowId: string | null
    userId: string | null
    status: $Enums.WorkflowStatus | null
    startedAt: Date | null
    finishedAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
    triggerType: string | null
    lockedBy: string | null
  }

  export type WorkflowExecutionCountAggregateOutputType = {
    id: number
    workflowId: number
    userId: number
    status: number
    input: number
    output: number
    startedAt: number
    finishedAt: number
    error: number
    metadata: number
    createdAt: number
    updatedAt: number
    triggerType: number
    triggerData: number
    lockedBy: number
    logs: number
    _all: number
  }


  export type WorkflowExecutionMinAggregateInputType = {
    id?: true
    workflowId?: true
    userId?: true
    status?: true
    startedAt?: true
    finishedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    triggerType?: true
    lockedBy?: true
  }

  export type WorkflowExecutionMaxAggregateInputType = {
    id?: true
    workflowId?: true
    userId?: true
    status?: true
    startedAt?: true
    finishedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    triggerType?: true
    lockedBy?: true
  }

  export type WorkflowExecutionCountAggregateInputType = {
    id?: true
    workflowId?: true
    userId?: true
    status?: true
    input?: true
    output?: true
    startedAt?: true
    finishedAt?: true
    error?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    triggerType?: true
    triggerData?: true
    lockedBy?: true
    logs?: true
    _all?: true
  }

  export type WorkflowExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowExecution to aggregate.
     */
    where?: WorkflowExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowExecutions to fetch.
     */
    orderBy?: WorkflowExecutionOrderByWithRelationInput | WorkflowExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowExecutions
    **/
    _count?: true | WorkflowExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowExecutionMaxAggregateInputType
  }

  export type GetWorkflowExecutionAggregateType<T extends WorkflowExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowExecution[P]>
      : GetScalarType<T[P], AggregateWorkflowExecution[P]>
  }




  export type WorkflowExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowExecutionWhereInput
    orderBy?: WorkflowExecutionOrderByWithAggregationInput | WorkflowExecutionOrderByWithAggregationInput[]
    by: WorkflowExecutionScalarFieldEnum[] | WorkflowExecutionScalarFieldEnum
    having?: WorkflowExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowExecutionCountAggregateInputType | true
    _min?: WorkflowExecutionMinAggregateInputType
    _max?: WorkflowExecutionMaxAggregateInputType
  }

  export type WorkflowExecutionGroupByOutputType = {
    id: string
    workflowId: string
    userId: string
    status: $Enums.WorkflowStatus
    input: JsonValue | null
    output: JsonValue | null
    startedAt: Date
    finishedAt: Date | null
    error: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    triggerType: string | null
    triggerData: JsonValue | null
    lockedBy: string | null
    logs: JsonValue | null
    _count: WorkflowExecutionCountAggregateOutputType | null
    _min: WorkflowExecutionMinAggregateOutputType | null
    _max: WorkflowExecutionMaxAggregateOutputType | null
  }

  type GetWorkflowExecutionGroupByPayload<T extends WorkflowExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowExecutionGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    userId?: boolean
    status?: boolean
    input?: boolean
    output?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    triggerType?: boolean
    triggerData?: boolean
    lockedBy?: boolean
    logs?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    nodeExecutions?: boolean | WorkflowExecution$nodeExecutionsArgs<ExtArgs>
    executionLogs?: boolean | WorkflowExecution$executionLogsArgs<ExtArgs>
    blockExecutions?: boolean | WorkflowExecution$blockExecutionsArgs<ExtArgs>
    blockchainTransactions?: boolean | WorkflowExecution$blockchainTransactionsArgs<ExtArgs>
    workflowPauses?: boolean | WorkflowExecution$workflowPausesArgs<ExtArgs>
    _count?: boolean | WorkflowExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowExecution"]>

  export type WorkflowExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    userId?: boolean
    status?: boolean
    input?: boolean
    output?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    triggerType?: boolean
    triggerData?: boolean
    lockedBy?: boolean
    logs?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowExecution"]>

  export type WorkflowExecutionSelectScalar = {
    id?: boolean
    workflowId?: boolean
    userId?: boolean
    status?: boolean
    input?: boolean
    output?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    triggerType?: boolean
    triggerData?: boolean
    lockedBy?: boolean
    logs?: boolean
  }

  export type WorkflowExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    nodeExecutions?: boolean | WorkflowExecution$nodeExecutionsArgs<ExtArgs>
    executionLogs?: boolean | WorkflowExecution$executionLogsArgs<ExtArgs>
    blockExecutions?: boolean | WorkflowExecution$blockExecutionsArgs<ExtArgs>
    blockchainTransactions?: boolean | WorkflowExecution$blockchainTransactionsArgs<ExtArgs>
    workflowPauses?: boolean | WorkflowExecution$workflowPausesArgs<ExtArgs>
    _count?: boolean | WorkflowExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkflowExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkflowExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowExecution"
    objects: {
      workflow: Prisma.$WorkflowPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      nodeExecutions: Prisma.$NodeExecutionPayload<ExtArgs>[]
      executionLogs: Prisma.$ExecutionLogPayload<ExtArgs>[]
      blockExecutions: Prisma.$BlockExecutionPayload<ExtArgs>[]
      blockchainTransactions: Prisma.$BlockchainTransactionPayload<ExtArgs>[]
      workflowPauses: Prisma.$WorkflowPausePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowId: string
      userId: string
      status: $Enums.WorkflowStatus
      input: Prisma.JsonValue | null
      output: Prisma.JsonValue | null
      startedAt: Date
      finishedAt: Date | null
      error: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      triggerType: string | null
      triggerData: Prisma.JsonValue | null
      lockedBy: string | null
      logs: Prisma.JsonValue | null
    }, ExtArgs["result"]["workflowExecution"]>
    composites: {}
  }

  type WorkflowExecutionGetPayload<S extends boolean | null | undefined | WorkflowExecutionDefaultArgs> = $Result.GetResult<Prisma.$WorkflowExecutionPayload, S>

  type WorkflowExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowExecutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowExecutionCountAggregateInputType | true
    }

  export interface WorkflowExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowExecution'], meta: { name: 'WorkflowExecution' } }
    /**
     * Find zero or one WorkflowExecution that matches the filter.
     * @param {WorkflowExecutionFindUniqueArgs} args - Arguments to find a WorkflowExecution
     * @example
     * // Get one WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowExecutionFindUniqueArgs>(args: SelectSubset<T, WorkflowExecutionFindUniqueArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowExecution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowExecutionFindUniqueOrThrowArgs} args - Arguments to find a WorkflowExecution
     * @example
     * // Get one WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionFindFirstArgs} args - Arguments to find a WorkflowExecution
     * @example
     * // Get one WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowExecutionFindFirstArgs>(args?: SelectSubset<T, WorkflowExecutionFindFirstArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionFindFirstOrThrowArgs} args - Arguments to find a WorkflowExecution
     * @example
     * // Get one WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowExecutions
     * const workflowExecutions = await prisma.workflowExecution.findMany()
     * 
     * // Get first 10 WorkflowExecutions
     * const workflowExecutions = await prisma.workflowExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowExecutionWithIdOnly = await prisma.workflowExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowExecutionFindManyArgs>(args?: SelectSubset<T, WorkflowExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowExecution.
     * @param {WorkflowExecutionCreateArgs} args - Arguments to create a WorkflowExecution.
     * @example
     * // Create one WorkflowExecution
     * const WorkflowExecution = await prisma.workflowExecution.create({
     *   data: {
     *     // ... data to create a WorkflowExecution
     *   }
     * })
     * 
     */
    create<T extends WorkflowExecutionCreateArgs>(args: SelectSubset<T, WorkflowExecutionCreateArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowExecutions.
     * @param {WorkflowExecutionCreateManyArgs} args - Arguments to create many WorkflowExecutions.
     * @example
     * // Create many WorkflowExecutions
     * const workflowExecution = await prisma.workflowExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowExecutionCreateManyArgs>(args?: SelectSubset<T, WorkflowExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowExecutions and returns the data saved in the database.
     * @param {WorkflowExecutionCreateManyAndReturnArgs} args - Arguments to create many WorkflowExecutions.
     * @example
     * // Create many WorkflowExecutions
     * const workflowExecution = await prisma.workflowExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowExecutions and only return the `id`
     * const workflowExecutionWithIdOnly = await prisma.workflowExecution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkflowExecution.
     * @param {WorkflowExecutionDeleteArgs} args - Arguments to delete one WorkflowExecution.
     * @example
     * // Delete one WorkflowExecution
     * const WorkflowExecution = await prisma.workflowExecution.delete({
     *   where: {
     *     // ... filter to delete one WorkflowExecution
     *   }
     * })
     * 
     */
    delete<T extends WorkflowExecutionDeleteArgs>(args: SelectSubset<T, WorkflowExecutionDeleteArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowExecution.
     * @param {WorkflowExecutionUpdateArgs} args - Arguments to update one WorkflowExecution.
     * @example
     * // Update one WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowExecutionUpdateArgs>(args: SelectSubset<T, WorkflowExecutionUpdateArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowExecutions.
     * @param {WorkflowExecutionDeleteManyArgs} args - Arguments to filter WorkflowExecutions to delete.
     * @example
     * // Delete a few WorkflowExecutions
     * const { count } = await prisma.workflowExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowExecutionDeleteManyArgs>(args?: SelectSubset<T, WorkflowExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowExecutions
     * const workflowExecution = await prisma.workflowExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowExecutionUpdateManyArgs>(args: SelectSubset<T, WorkflowExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowExecution.
     * @param {WorkflowExecutionUpsertArgs} args - Arguments to update or create a WorkflowExecution.
     * @example
     * // Update or create a WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.upsert({
     *   create: {
     *     // ... data to create a WorkflowExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowExecution we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowExecutionUpsertArgs>(args: SelectSubset<T, WorkflowExecutionUpsertArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionCountArgs} args - Arguments to filter WorkflowExecutions to count.
     * @example
     * // Count the number of WorkflowExecutions
     * const count = await prisma.workflowExecution.count({
     *   where: {
     *     // ... the filter for the WorkflowExecutions we want to count
     *   }
     * })
    **/
    count<T extends WorkflowExecutionCountArgs>(
      args?: Subset<T, WorkflowExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowExecutionAggregateArgs>(args: Subset<T, WorkflowExecutionAggregateArgs>): Prisma.PrismaPromise<GetWorkflowExecutionAggregateType<T>>

    /**
     * Group by WorkflowExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowExecutionGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowExecution model
   */
  readonly fields: WorkflowExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflow<T extends WorkflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefaultArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    nodeExecutions<T extends WorkflowExecution$nodeExecutionsArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowExecution$nodeExecutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    executionLogs<T extends WorkflowExecution$executionLogsArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowExecution$executionLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "findMany"> | Null>
    blockExecutions<T extends WorkflowExecution$blockExecutionsArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowExecution$blockExecutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    blockchainTransactions<T extends WorkflowExecution$blockchainTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowExecution$blockchainTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    workflowPauses<T extends WorkflowExecution$workflowPausesArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowExecution$workflowPausesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPausePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowExecution model
   */ 
  interface WorkflowExecutionFieldRefs {
    readonly id: FieldRef<"WorkflowExecution", 'String'>
    readonly workflowId: FieldRef<"WorkflowExecution", 'String'>
    readonly userId: FieldRef<"WorkflowExecution", 'String'>
    readonly status: FieldRef<"WorkflowExecution", 'WorkflowStatus'>
    readonly input: FieldRef<"WorkflowExecution", 'Json'>
    readonly output: FieldRef<"WorkflowExecution", 'Json'>
    readonly startedAt: FieldRef<"WorkflowExecution", 'DateTime'>
    readonly finishedAt: FieldRef<"WorkflowExecution", 'DateTime'>
    readonly error: FieldRef<"WorkflowExecution", 'String'>
    readonly metadata: FieldRef<"WorkflowExecution", 'Json'>
    readonly createdAt: FieldRef<"WorkflowExecution", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkflowExecution", 'DateTime'>
    readonly triggerType: FieldRef<"WorkflowExecution", 'String'>
    readonly triggerData: FieldRef<"WorkflowExecution", 'Json'>
    readonly lockedBy: FieldRef<"WorkflowExecution", 'String'>
    readonly logs: FieldRef<"WorkflowExecution", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowExecution findUnique
   */
  export type WorkflowExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowExecution to fetch.
     */
    where: WorkflowExecutionWhereUniqueInput
  }

  /**
   * WorkflowExecution findUniqueOrThrow
   */
  export type WorkflowExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowExecution to fetch.
     */
    where: WorkflowExecutionWhereUniqueInput
  }

  /**
   * WorkflowExecution findFirst
   */
  export type WorkflowExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowExecution to fetch.
     */
    where?: WorkflowExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowExecutions to fetch.
     */
    orderBy?: WorkflowExecutionOrderByWithRelationInput | WorkflowExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowExecutions.
     */
    cursor?: WorkflowExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowExecutions.
     */
    distinct?: WorkflowExecutionScalarFieldEnum | WorkflowExecutionScalarFieldEnum[]
  }

  /**
   * WorkflowExecution findFirstOrThrow
   */
  export type WorkflowExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowExecution to fetch.
     */
    where?: WorkflowExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowExecutions to fetch.
     */
    orderBy?: WorkflowExecutionOrderByWithRelationInput | WorkflowExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowExecutions.
     */
    cursor?: WorkflowExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowExecutions.
     */
    distinct?: WorkflowExecutionScalarFieldEnum | WorkflowExecutionScalarFieldEnum[]
  }

  /**
   * WorkflowExecution findMany
   */
  export type WorkflowExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowExecutions to fetch.
     */
    where?: WorkflowExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowExecutions to fetch.
     */
    orderBy?: WorkflowExecutionOrderByWithRelationInput | WorkflowExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowExecutions.
     */
    cursor?: WorkflowExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowExecutions.
     */
    skip?: number
    distinct?: WorkflowExecutionScalarFieldEnum | WorkflowExecutionScalarFieldEnum[]
  }

  /**
   * WorkflowExecution create
   */
  export type WorkflowExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowExecution.
     */
    data: XOR<WorkflowExecutionCreateInput, WorkflowExecutionUncheckedCreateInput>
  }

  /**
   * WorkflowExecution createMany
   */
  export type WorkflowExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowExecutions.
     */
    data: WorkflowExecutionCreateManyInput | WorkflowExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowExecution createManyAndReturn
   */
  export type WorkflowExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkflowExecutions.
     */
    data: WorkflowExecutionCreateManyInput | WorkflowExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowExecution update
   */
  export type WorkflowExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowExecution.
     */
    data: XOR<WorkflowExecutionUpdateInput, WorkflowExecutionUncheckedUpdateInput>
    /**
     * Choose, which WorkflowExecution to update.
     */
    where: WorkflowExecutionWhereUniqueInput
  }

  /**
   * WorkflowExecution updateMany
   */
  export type WorkflowExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowExecutions.
     */
    data: XOR<WorkflowExecutionUpdateManyMutationInput, WorkflowExecutionUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowExecutions to update
     */
    where?: WorkflowExecutionWhereInput
  }

  /**
   * WorkflowExecution upsert
   */
  export type WorkflowExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowExecution to update in case it exists.
     */
    where: WorkflowExecutionWhereUniqueInput
    /**
     * In case the WorkflowExecution found by the `where` argument doesn't exist, create a new WorkflowExecution with this data.
     */
    create: XOR<WorkflowExecutionCreateInput, WorkflowExecutionUncheckedCreateInput>
    /**
     * In case the WorkflowExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowExecutionUpdateInput, WorkflowExecutionUncheckedUpdateInput>
  }

  /**
   * WorkflowExecution delete
   */
  export type WorkflowExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * Filter which WorkflowExecution to delete.
     */
    where: WorkflowExecutionWhereUniqueInput
  }

  /**
   * WorkflowExecution deleteMany
   */
  export type WorkflowExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowExecutions to delete
     */
    where?: WorkflowExecutionWhereInput
  }

  /**
   * WorkflowExecution.nodeExecutions
   */
  export type WorkflowExecution$nodeExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeExecution
     */
    select?: NodeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeExecutionInclude<ExtArgs> | null
    where?: NodeExecutionWhereInput
    orderBy?: NodeExecutionOrderByWithRelationInput | NodeExecutionOrderByWithRelationInput[]
    cursor?: NodeExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NodeExecutionScalarFieldEnum | NodeExecutionScalarFieldEnum[]
  }

  /**
   * WorkflowExecution.executionLogs
   */
  export type WorkflowExecution$executionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    where?: ExecutionLogWhereInput
    orderBy?: ExecutionLogOrderByWithRelationInput | ExecutionLogOrderByWithRelationInput[]
    cursor?: ExecutionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExecutionLogScalarFieldEnum | ExecutionLogScalarFieldEnum[]
  }

  /**
   * WorkflowExecution.blockExecutions
   */
  export type WorkflowExecution$blockExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    where?: BlockExecutionWhereInput
    orderBy?: BlockExecutionOrderByWithRelationInput | BlockExecutionOrderByWithRelationInput[]
    cursor?: BlockExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockExecutionScalarFieldEnum | BlockExecutionScalarFieldEnum[]
  }

  /**
   * WorkflowExecution.blockchainTransactions
   */
  export type WorkflowExecution$blockchainTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    where?: BlockchainTransactionWhereInput
    orderBy?: BlockchainTransactionOrderByWithRelationInput | BlockchainTransactionOrderByWithRelationInput[]
    cursor?: BlockchainTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockchainTransactionScalarFieldEnum | BlockchainTransactionScalarFieldEnum[]
  }

  /**
   * WorkflowExecution.workflowPauses
   */
  export type WorkflowExecution$workflowPausesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowPause
     */
    select?: WorkflowPauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowPauseInclude<ExtArgs> | null
    where?: WorkflowPauseWhereInput
    orderBy?: WorkflowPauseOrderByWithRelationInput | WorkflowPauseOrderByWithRelationInput[]
    cursor?: WorkflowPauseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowPauseScalarFieldEnum | WorkflowPauseScalarFieldEnum[]
  }

  /**
   * WorkflowExecution without action
   */
  export type WorkflowExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
  }


  /**
   * Model NodeExecution
   */

  export type AggregateNodeExecution = {
    _count: NodeExecutionCountAggregateOutputType | null
    _avg: NodeExecutionAvgAggregateOutputType | null
    _sum: NodeExecutionSumAggregateOutputType | null
    _min: NodeExecutionMinAggregateOutputType | null
    _max: NodeExecutionMaxAggregateOutputType | null
  }

  export type NodeExecutionAvgAggregateOutputType = {
    durationMs: number | null
    retryCount: number | null
  }

  export type NodeExecutionSumAggregateOutputType = {
    durationMs: number | null
    retryCount: number | null
  }

  export type NodeExecutionMinAggregateOutputType = {
    id: string | null
    executionId: string | null
    nodeId: string | null
    status: string | null
    error: string | null
    startedAt: Date | null
    completedAt: Date | null
    durationMs: number | null
    updatedAt: Date | null
    retryCount: number | null
    finishedAt: Date | null
  }

  export type NodeExecutionMaxAggregateOutputType = {
    id: string | null
    executionId: string | null
    nodeId: string | null
    status: string | null
    error: string | null
    startedAt: Date | null
    completedAt: Date | null
    durationMs: number | null
    updatedAt: Date | null
    retryCount: number | null
    finishedAt: Date | null
  }

  export type NodeExecutionCountAggregateOutputType = {
    id: number
    executionId: number
    nodeId: number
    status: number
    outputData: number
    error: number
    startedAt: number
    completedAt: number
    durationMs: number
    updatedAt: number
    retryCount: number
    finishedAt: number
    output: number
    _all: number
  }


  export type NodeExecutionAvgAggregateInputType = {
    durationMs?: true
    retryCount?: true
  }

  export type NodeExecutionSumAggregateInputType = {
    durationMs?: true
    retryCount?: true
  }

  export type NodeExecutionMinAggregateInputType = {
    id?: true
    executionId?: true
    nodeId?: true
    status?: true
    error?: true
    startedAt?: true
    completedAt?: true
    durationMs?: true
    updatedAt?: true
    retryCount?: true
    finishedAt?: true
  }

  export type NodeExecutionMaxAggregateInputType = {
    id?: true
    executionId?: true
    nodeId?: true
    status?: true
    error?: true
    startedAt?: true
    completedAt?: true
    durationMs?: true
    updatedAt?: true
    retryCount?: true
    finishedAt?: true
  }

  export type NodeExecutionCountAggregateInputType = {
    id?: true
    executionId?: true
    nodeId?: true
    status?: true
    outputData?: true
    error?: true
    startedAt?: true
    completedAt?: true
    durationMs?: true
    updatedAt?: true
    retryCount?: true
    finishedAt?: true
    output?: true
    _all?: true
  }

  export type NodeExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NodeExecution to aggregate.
     */
    where?: NodeExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeExecutions to fetch.
     */
    orderBy?: NodeExecutionOrderByWithRelationInput | NodeExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NodeExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NodeExecutions
    **/
    _count?: true | NodeExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NodeExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NodeExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NodeExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NodeExecutionMaxAggregateInputType
  }

  export type GetNodeExecutionAggregateType<T extends NodeExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateNodeExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNodeExecution[P]>
      : GetScalarType<T[P], AggregateNodeExecution[P]>
  }




  export type NodeExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeExecutionWhereInput
    orderBy?: NodeExecutionOrderByWithAggregationInput | NodeExecutionOrderByWithAggregationInput[]
    by: NodeExecutionScalarFieldEnum[] | NodeExecutionScalarFieldEnum
    having?: NodeExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NodeExecutionCountAggregateInputType | true
    _avg?: NodeExecutionAvgAggregateInputType
    _sum?: NodeExecutionSumAggregateInputType
    _min?: NodeExecutionMinAggregateInputType
    _max?: NodeExecutionMaxAggregateInputType
  }

  export type NodeExecutionGroupByOutputType = {
    id: string
    executionId: string
    nodeId: string
    status: string
    outputData: JsonValue | null
    error: string | null
    startedAt: Date
    completedAt: Date
    durationMs: number | null
    updatedAt: Date | null
    retryCount: number | null
    finishedAt: Date | null
    output: JsonValue | null
    _count: NodeExecutionCountAggregateOutputType | null
    _avg: NodeExecutionAvgAggregateOutputType | null
    _sum: NodeExecutionSumAggregateOutputType | null
    _min: NodeExecutionMinAggregateOutputType | null
    _max: NodeExecutionMaxAggregateOutputType | null
  }

  type GetNodeExecutionGroupByPayload<T extends NodeExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NodeExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NodeExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NodeExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], NodeExecutionGroupByOutputType[P]>
        }
      >
    >


  export type NodeExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    nodeId?: boolean
    status?: boolean
    outputData?: boolean
    error?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationMs?: boolean
    updatedAt?: boolean
    retryCount?: boolean
    finishedAt?: boolean
    output?: boolean
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
    logs?: boolean | NodeExecution$logsArgs<ExtArgs>
    nodeInputs?: boolean | NodeExecution$nodeInputsArgs<ExtArgs>
    nodeOutputs?: boolean | NodeExecution$nodeOutputsArgs<ExtArgs>
    _count?: boolean | NodeExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nodeExecution"]>

  export type NodeExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    nodeId?: boolean
    status?: boolean
    outputData?: boolean
    error?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationMs?: boolean
    updatedAt?: boolean
    retryCount?: boolean
    finishedAt?: boolean
    output?: boolean
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nodeExecution"]>

  export type NodeExecutionSelectScalar = {
    id?: boolean
    executionId?: boolean
    nodeId?: boolean
    status?: boolean
    outputData?: boolean
    error?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationMs?: boolean
    updatedAt?: boolean
    retryCount?: boolean
    finishedAt?: boolean
    output?: boolean
  }

  export type NodeExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
    logs?: boolean | NodeExecution$logsArgs<ExtArgs>
    nodeInputs?: boolean | NodeExecution$nodeInputsArgs<ExtArgs>
    nodeOutputs?: boolean | NodeExecution$nodeOutputsArgs<ExtArgs>
    _count?: boolean | NodeExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NodeExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }

  export type $NodeExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NodeExecution"
    objects: {
      execution: Prisma.$WorkflowExecutionPayload<ExtArgs>
      logs: Prisma.$NodeLogPayload<ExtArgs>[]
      nodeInputs: Prisma.$NodeInputPayload<ExtArgs>[]
      nodeOutputs: Prisma.$NodeOutputPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      executionId: string
      nodeId: string
      status: string
      outputData: Prisma.JsonValue | null
      error: string | null
      startedAt: Date
      completedAt: Date
      durationMs: number | null
      updatedAt: Date | null
      retryCount: number | null
      finishedAt: Date | null
      output: Prisma.JsonValue | null
    }, ExtArgs["result"]["nodeExecution"]>
    composites: {}
  }

  type NodeExecutionGetPayload<S extends boolean | null | undefined | NodeExecutionDefaultArgs> = $Result.GetResult<Prisma.$NodeExecutionPayload, S>

  type NodeExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NodeExecutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NodeExecutionCountAggregateInputType | true
    }

  export interface NodeExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NodeExecution'], meta: { name: 'NodeExecution' } }
    /**
     * Find zero or one NodeExecution that matches the filter.
     * @param {NodeExecutionFindUniqueArgs} args - Arguments to find a NodeExecution
     * @example
     * // Get one NodeExecution
     * const nodeExecution = await prisma.nodeExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NodeExecutionFindUniqueArgs>(args: SelectSubset<T, NodeExecutionFindUniqueArgs<ExtArgs>>): Prisma__NodeExecutionClient<$Result.GetResult<Prisma.$NodeExecutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NodeExecution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NodeExecutionFindUniqueOrThrowArgs} args - Arguments to find a NodeExecution
     * @example
     * // Get one NodeExecution
     * const nodeExecution = await prisma.nodeExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NodeExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, NodeExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NodeExecutionClient<$Result.GetResult<Prisma.$NodeExecutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NodeExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeExecutionFindFirstArgs} args - Arguments to find a NodeExecution
     * @example
     * // Get one NodeExecution
     * const nodeExecution = await prisma.nodeExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NodeExecutionFindFirstArgs>(args?: SelectSubset<T, NodeExecutionFindFirstArgs<ExtArgs>>): Prisma__NodeExecutionClient<$Result.GetResult<Prisma.$NodeExecutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NodeExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeExecutionFindFirstOrThrowArgs} args - Arguments to find a NodeExecution
     * @example
     * // Get one NodeExecution
     * const nodeExecution = await prisma.nodeExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NodeExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, NodeExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__NodeExecutionClient<$Result.GetResult<Prisma.$NodeExecutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NodeExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NodeExecutions
     * const nodeExecutions = await prisma.nodeExecution.findMany()
     * 
     * // Get first 10 NodeExecutions
     * const nodeExecutions = await prisma.nodeExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nodeExecutionWithIdOnly = await prisma.nodeExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NodeExecutionFindManyArgs>(args?: SelectSubset<T, NodeExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeExecutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NodeExecution.
     * @param {NodeExecutionCreateArgs} args - Arguments to create a NodeExecution.
     * @example
     * // Create one NodeExecution
     * const NodeExecution = await prisma.nodeExecution.create({
     *   data: {
     *     // ... data to create a NodeExecution
     *   }
     * })
     * 
     */
    create<T extends NodeExecutionCreateArgs>(args: SelectSubset<T, NodeExecutionCreateArgs<ExtArgs>>): Prisma__NodeExecutionClient<$Result.GetResult<Prisma.$NodeExecutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NodeExecutions.
     * @param {NodeExecutionCreateManyArgs} args - Arguments to create many NodeExecutions.
     * @example
     * // Create many NodeExecutions
     * const nodeExecution = await prisma.nodeExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NodeExecutionCreateManyArgs>(args?: SelectSubset<T, NodeExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NodeExecutions and returns the data saved in the database.
     * @param {NodeExecutionCreateManyAndReturnArgs} args - Arguments to create many NodeExecutions.
     * @example
     * // Create many NodeExecutions
     * const nodeExecution = await prisma.nodeExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NodeExecutions and only return the `id`
     * const nodeExecutionWithIdOnly = await prisma.nodeExecution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NodeExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, NodeExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeExecutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NodeExecution.
     * @param {NodeExecutionDeleteArgs} args - Arguments to delete one NodeExecution.
     * @example
     * // Delete one NodeExecution
     * const NodeExecution = await prisma.nodeExecution.delete({
     *   where: {
     *     // ... filter to delete one NodeExecution
     *   }
     * })
     * 
     */
    delete<T extends NodeExecutionDeleteArgs>(args: SelectSubset<T, NodeExecutionDeleteArgs<ExtArgs>>): Prisma__NodeExecutionClient<$Result.GetResult<Prisma.$NodeExecutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NodeExecution.
     * @param {NodeExecutionUpdateArgs} args - Arguments to update one NodeExecution.
     * @example
     * // Update one NodeExecution
     * const nodeExecution = await prisma.nodeExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NodeExecutionUpdateArgs>(args: SelectSubset<T, NodeExecutionUpdateArgs<ExtArgs>>): Prisma__NodeExecutionClient<$Result.GetResult<Prisma.$NodeExecutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NodeExecutions.
     * @param {NodeExecutionDeleteManyArgs} args - Arguments to filter NodeExecutions to delete.
     * @example
     * // Delete a few NodeExecutions
     * const { count } = await prisma.nodeExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NodeExecutionDeleteManyArgs>(args?: SelectSubset<T, NodeExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NodeExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NodeExecutions
     * const nodeExecution = await prisma.nodeExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NodeExecutionUpdateManyArgs>(args: SelectSubset<T, NodeExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NodeExecution.
     * @param {NodeExecutionUpsertArgs} args - Arguments to update or create a NodeExecution.
     * @example
     * // Update or create a NodeExecution
     * const nodeExecution = await prisma.nodeExecution.upsert({
     *   create: {
     *     // ... data to create a NodeExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NodeExecution we want to update
     *   }
     * })
     */
    upsert<T extends NodeExecutionUpsertArgs>(args: SelectSubset<T, NodeExecutionUpsertArgs<ExtArgs>>): Prisma__NodeExecutionClient<$Result.GetResult<Prisma.$NodeExecutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NodeExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeExecutionCountArgs} args - Arguments to filter NodeExecutions to count.
     * @example
     * // Count the number of NodeExecutions
     * const count = await prisma.nodeExecution.count({
     *   where: {
     *     // ... the filter for the NodeExecutions we want to count
     *   }
     * })
    **/
    count<T extends NodeExecutionCountArgs>(
      args?: Subset<T, NodeExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NodeExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NodeExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NodeExecutionAggregateArgs>(args: Subset<T, NodeExecutionAggregateArgs>): Prisma.PrismaPromise<GetNodeExecutionAggregateType<T>>

    /**
     * Group by NodeExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NodeExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NodeExecutionGroupByArgs['orderBy'] }
        : { orderBy?: NodeExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NodeExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNodeExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NodeExecution model
   */
  readonly fields: NodeExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NodeExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NodeExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    execution<T extends WorkflowExecutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowExecutionDefaultArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    logs<T extends NodeExecution$logsArgs<ExtArgs> = {}>(args?: Subset<T, NodeExecution$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeLogPayload<ExtArgs>, T, "findMany"> | Null>
    nodeInputs<T extends NodeExecution$nodeInputsArgs<ExtArgs> = {}>(args?: Subset<T, NodeExecution$nodeInputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeInputPayload<ExtArgs>, T, "findMany"> | Null>
    nodeOutputs<T extends NodeExecution$nodeOutputsArgs<ExtArgs> = {}>(args?: Subset<T, NodeExecution$nodeOutputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeOutputPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NodeExecution model
   */ 
  interface NodeExecutionFieldRefs {
    readonly id: FieldRef<"NodeExecution", 'String'>
    readonly executionId: FieldRef<"NodeExecution", 'String'>
    readonly nodeId: FieldRef<"NodeExecution", 'String'>
    readonly status: FieldRef<"NodeExecution", 'String'>
    readonly outputData: FieldRef<"NodeExecution", 'Json'>
    readonly error: FieldRef<"NodeExecution", 'String'>
    readonly startedAt: FieldRef<"NodeExecution", 'DateTime'>
    readonly completedAt: FieldRef<"NodeExecution", 'DateTime'>
    readonly durationMs: FieldRef<"NodeExecution", 'Int'>
    readonly updatedAt: FieldRef<"NodeExecution", 'DateTime'>
    readonly retryCount: FieldRef<"NodeExecution", 'Int'>
    readonly finishedAt: FieldRef<"NodeExecution", 'DateTime'>
    readonly output: FieldRef<"NodeExecution", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * NodeExecution findUnique
   */
  export type NodeExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeExecution
     */
    select?: NodeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeExecutionInclude<ExtArgs> | null
    /**
     * Filter, which NodeExecution to fetch.
     */
    where: NodeExecutionWhereUniqueInput
  }

  /**
   * NodeExecution findUniqueOrThrow
   */
  export type NodeExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeExecution
     */
    select?: NodeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeExecutionInclude<ExtArgs> | null
    /**
     * Filter, which NodeExecution to fetch.
     */
    where: NodeExecutionWhereUniqueInput
  }

  /**
   * NodeExecution findFirst
   */
  export type NodeExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeExecution
     */
    select?: NodeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeExecutionInclude<ExtArgs> | null
    /**
     * Filter, which NodeExecution to fetch.
     */
    where?: NodeExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeExecutions to fetch.
     */
    orderBy?: NodeExecutionOrderByWithRelationInput | NodeExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NodeExecutions.
     */
    cursor?: NodeExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NodeExecutions.
     */
    distinct?: NodeExecutionScalarFieldEnum | NodeExecutionScalarFieldEnum[]
  }

  /**
   * NodeExecution findFirstOrThrow
   */
  export type NodeExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeExecution
     */
    select?: NodeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeExecutionInclude<ExtArgs> | null
    /**
     * Filter, which NodeExecution to fetch.
     */
    where?: NodeExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeExecutions to fetch.
     */
    orderBy?: NodeExecutionOrderByWithRelationInput | NodeExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NodeExecutions.
     */
    cursor?: NodeExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NodeExecutions.
     */
    distinct?: NodeExecutionScalarFieldEnum | NodeExecutionScalarFieldEnum[]
  }

  /**
   * NodeExecution findMany
   */
  export type NodeExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeExecution
     */
    select?: NodeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeExecutionInclude<ExtArgs> | null
    /**
     * Filter, which NodeExecutions to fetch.
     */
    where?: NodeExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeExecutions to fetch.
     */
    orderBy?: NodeExecutionOrderByWithRelationInput | NodeExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NodeExecutions.
     */
    cursor?: NodeExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeExecutions.
     */
    skip?: number
    distinct?: NodeExecutionScalarFieldEnum | NodeExecutionScalarFieldEnum[]
  }

  /**
   * NodeExecution create
   */
  export type NodeExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeExecution
     */
    select?: NodeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a NodeExecution.
     */
    data: XOR<NodeExecutionCreateInput, NodeExecutionUncheckedCreateInput>
  }

  /**
   * NodeExecution createMany
   */
  export type NodeExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NodeExecutions.
     */
    data: NodeExecutionCreateManyInput | NodeExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NodeExecution createManyAndReturn
   */
  export type NodeExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeExecution
     */
    select?: NodeExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NodeExecutions.
     */
    data: NodeExecutionCreateManyInput | NodeExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NodeExecution update
   */
  export type NodeExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeExecution
     */
    select?: NodeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a NodeExecution.
     */
    data: XOR<NodeExecutionUpdateInput, NodeExecutionUncheckedUpdateInput>
    /**
     * Choose, which NodeExecution to update.
     */
    where: NodeExecutionWhereUniqueInput
  }

  /**
   * NodeExecution updateMany
   */
  export type NodeExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NodeExecutions.
     */
    data: XOR<NodeExecutionUpdateManyMutationInput, NodeExecutionUncheckedUpdateManyInput>
    /**
     * Filter which NodeExecutions to update
     */
    where?: NodeExecutionWhereInput
  }

  /**
   * NodeExecution upsert
   */
  export type NodeExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeExecution
     */
    select?: NodeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the NodeExecution to update in case it exists.
     */
    where: NodeExecutionWhereUniqueInput
    /**
     * In case the NodeExecution found by the `where` argument doesn't exist, create a new NodeExecution with this data.
     */
    create: XOR<NodeExecutionCreateInput, NodeExecutionUncheckedCreateInput>
    /**
     * In case the NodeExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NodeExecutionUpdateInput, NodeExecutionUncheckedUpdateInput>
  }

  /**
   * NodeExecution delete
   */
  export type NodeExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeExecution
     */
    select?: NodeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeExecutionInclude<ExtArgs> | null
    /**
     * Filter which NodeExecution to delete.
     */
    where: NodeExecutionWhereUniqueInput
  }

  /**
   * NodeExecution deleteMany
   */
  export type NodeExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NodeExecutions to delete
     */
    where?: NodeExecutionWhereInput
  }

  /**
   * NodeExecution.logs
   */
  export type NodeExecution$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeLog
     */
    select?: NodeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeLogInclude<ExtArgs> | null
    where?: NodeLogWhereInput
    orderBy?: NodeLogOrderByWithRelationInput | NodeLogOrderByWithRelationInput[]
    cursor?: NodeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NodeLogScalarFieldEnum | NodeLogScalarFieldEnum[]
  }

  /**
   * NodeExecution.nodeInputs
   */
  export type NodeExecution$nodeInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeInput
     */
    select?: NodeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInputInclude<ExtArgs> | null
    where?: NodeInputWhereInput
    orderBy?: NodeInputOrderByWithRelationInput | NodeInputOrderByWithRelationInput[]
    cursor?: NodeInputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NodeInputScalarFieldEnum | NodeInputScalarFieldEnum[]
  }

  /**
   * NodeExecution.nodeOutputs
   */
  export type NodeExecution$nodeOutputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeOutput
     */
    select?: NodeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeOutputInclude<ExtArgs> | null
    where?: NodeOutputWhereInput
    orderBy?: NodeOutputOrderByWithRelationInput | NodeOutputOrderByWithRelationInput[]
    cursor?: NodeOutputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NodeOutputScalarFieldEnum | NodeOutputScalarFieldEnum[]
  }

  /**
   * NodeExecution without action
   */
  export type NodeExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeExecution
     */
    select?: NodeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeExecutionInclude<ExtArgs> | null
  }


  /**
   * Model NodeLog
   */

  export type AggregateNodeLog = {
    _count: NodeLogCountAggregateOutputType | null
    _min: NodeLogMinAggregateOutputType | null
    _max: NodeLogMaxAggregateOutputType | null
  }

  export type NodeLogMinAggregateOutputType = {
    id: string | null
    nodeExecutionId: string | null
    level: $Enums.LogLevel | null
    message: string | null
    createdAt: Date | null
  }

  export type NodeLogMaxAggregateOutputType = {
    id: string | null
    nodeExecutionId: string | null
    level: $Enums.LogLevel | null
    message: string | null
    createdAt: Date | null
  }

  export type NodeLogCountAggregateOutputType = {
    id: number
    nodeExecutionId: number
    level: number
    message: number
    createdAt: number
    metadata: number
    _all: number
  }


  export type NodeLogMinAggregateInputType = {
    id?: true
    nodeExecutionId?: true
    level?: true
    message?: true
    createdAt?: true
  }

  export type NodeLogMaxAggregateInputType = {
    id?: true
    nodeExecutionId?: true
    level?: true
    message?: true
    createdAt?: true
  }

  export type NodeLogCountAggregateInputType = {
    id?: true
    nodeExecutionId?: true
    level?: true
    message?: true
    createdAt?: true
    metadata?: true
    _all?: true
  }

  export type NodeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NodeLog to aggregate.
     */
    where?: NodeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeLogs to fetch.
     */
    orderBy?: NodeLogOrderByWithRelationInput | NodeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NodeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NodeLogs
    **/
    _count?: true | NodeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NodeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NodeLogMaxAggregateInputType
  }

  export type GetNodeLogAggregateType<T extends NodeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateNodeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNodeLog[P]>
      : GetScalarType<T[P], AggregateNodeLog[P]>
  }




  export type NodeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeLogWhereInput
    orderBy?: NodeLogOrderByWithAggregationInput | NodeLogOrderByWithAggregationInput[]
    by: NodeLogScalarFieldEnum[] | NodeLogScalarFieldEnum
    having?: NodeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NodeLogCountAggregateInputType | true
    _min?: NodeLogMinAggregateInputType
    _max?: NodeLogMaxAggregateInputType
  }

  export type NodeLogGroupByOutputType = {
    id: string
    nodeExecutionId: string
    level: $Enums.LogLevel
    message: string
    createdAt: Date
    metadata: JsonValue | null
    _count: NodeLogCountAggregateOutputType | null
    _min: NodeLogMinAggregateOutputType | null
    _max: NodeLogMaxAggregateOutputType | null
  }

  type GetNodeLogGroupByPayload<T extends NodeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NodeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NodeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NodeLogGroupByOutputType[P]>
            : GetScalarType<T[P], NodeLogGroupByOutputType[P]>
        }
      >
    >


  export type NodeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeExecutionId?: boolean
    level?: boolean
    message?: boolean
    createdAt?: boolean
    metadata?: boolean
    nodeExecution?: boolean | NodeExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nodeLog"]>

  export type NodeLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeExecutionId?: boolean
    level?: boolean
    message?: boolean
    createdAt?: boolean
    metadata?: boolean
    nodeExecution?: boolean | NodeExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nodeLog"]>

  export type NodeLogSelectScalar = {
    id?: boolean
    nodeExecutionId?: boolean
    level?: boolean
    message?: boolean
    createdAt?: boolean
    metadata?: boolean
  }

  export type NodeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodeExecution?: boolean | NodeExecutionDefaultArgs<ExtArgs>
  }
  export type NodeLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodeExecution?: boolean | NodeExecutionDefaultArgs<ExtArgs>
  }

  export type $NodeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NodeLog"
    objects: {
      nodeExecution: Prisma.$NodeExecutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nodeExecutionId: string
      level: $Enums.LogLevel
      message: string
      createdAt: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["nodeLog"]>
    composites: {}
  }

  type NodeLogGetPayload<S extends boolean | null | undefined | NodeLogDefaultArgs> = $Result.GetResult<Prisma.$NodeLogPayload, S>

  type NodeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NodeLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NodeLogCountAggregateInputType | true
    }

  export interface NodeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NodeLog'], meta: { name: 'NodeLog' } }
    /**
     * Find zero or one NodeLog that matches the filter.
     * @param {NodeLogFindUniqueArgs} args - Arguments to find a NodeLog
     * @example
     * // Get one NodeLog
     * const nodeLog = await prisma.nodeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NodeLogFindUniqueArgs>(args: SelectSubset<T, NodeLogFindUniqueArgs<ExtArgs>>): Prisma__NodeLogClient<$Result.GetResult<Prisma.$NodeLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NodeLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NodeLogFindUniqueOrThrowArgs} args - Arguments to find a NodeLog
     * @example
     * // Get one NodeLog
     * const nodeLog = await prisma.nodeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NodeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, NodeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NodeLogClient<$Result.GetResult<Prisma.$NodeLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NodeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeLogFindFirstArgs} args - Arguments to find a NodeLog
     * @example
     * // Get one NodeLog
     * const nodeLog = await prisma.nodeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NodeLogFindFirstArgs>(args?: SelectSubset<T, NodeLogFindFirstArgs<ExtArgs>>): Prisma__NodeLogClient<$Result.GetResult<Prisma.$NodeLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NodeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeLogFindFirstOrThrowArgs} args - Arguments to find a NodeLog
     * @example
     * // Get one NodeLog
     * const nodeLog = await prisma.nodeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NodeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, NodeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__NodeLogClient<$Result.GetResult<Prisma.$NodeLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NodeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NodeLogs
     * const nodeLogs = await prisma.nodeLog.findMany()
     * 
     * // Get first 10 NodeLogs
     * const nodeLogs = await prisma.nodeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nodeLogWithIdOnly = await prisma.nodeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NodeLogFindManyArgs>(args?: SelectSubset<T, NodeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NodeLog.
     * @param {NodeLogCreateArgs} args - Arguments to create a NodeLog.
     * @example
     * // Create one NodeLog
     * const NodeLog = await prisma.nodeLog.create({
     *   data: {
     *     // ... data to create a NodeLog
     *   }
     * })
     * 
     */
    create<T extends NodeLogCreateArgs>(args: SelectSubset<T, NodeLogCreateArgs<ExtArgs>>): Prisma__NodeLogClient<$Result.GetResult<Prisma.$NodeLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NodeLogs.
     * @param {NodeLogCreateManyArgs} args - Arguments to create many NodeLogs.
     * @example
     * // Create many NodeLogs
     * const nodeLog = await prisma.nodeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NodeLogCreateManyArgs>(args?: SelectSubset<T, NodeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NodeLogs and returns the data saved in the database.
     * @param {NodeLogCreateManyAndReturnArgs} args - Arguments to create many NodeLogs.
     * @example
     * // Create many NodeLogs
     * const nodeLog = await prisma.nodeLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NodeLogs and only return the `id`
     * const nodeLogWithIdOnly = await prisma.nodeLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NodeLogCreateManyAndReturnArgs>(args?: SelectSubset<T, NodeLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NodeLog.
     * @param {NodeLogDeleteArgs} args - Arguments to delete one NodeLog.
     * @example
     * // Delete one NodeLog
     * const NodeLog = await prisma.nodeLog.delete({
     *   where: {
     *     // ... filter to delete one NodeLog
     *   }
     * })
     * 
     */
    delete<T extends NodeLogDeleteArgs>(args: SelectSubset<T, NodeLogDeleteArgs<ExtArgs>>): Prisma__NodeLogClient<$Result.GetResult<Prisma.$NodeLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NodeLog.
     * @param {NodeLogUpdateArgs} args - Arguments to update one NodeLog.
     * @example
     * // Update one NodeLog
     * const nodeLog = await prisma.nodeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NodeLogUpdateArgs>(args: SelectSubset<T, NodeLogUpdateArgs<ExtArgs>>): Prisma__NodeLogClient<$Result.GetResult<Prisma.$NodeLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NodeLogs.
     * @param {NodeLogDeleteManyArgs} args - Arguments to filter NodeLogs to delete.
     * @example
     * // Delete a few NodeLogs
     * const { count } = await prisma.nodeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NodeLogDeleteManyArgs>(args?: SelectSubset<T, NodeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NodeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NodeLogs
     * const nodeLog = await prisma.nodeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NodeLogUpdateManyArgs>(args: SelectSubset<T, NodeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NodeLog.
     * @param {NodeLogUpsertArgs} args - Arguments to update or create a NodeLog.
     * @example
     * // Update or create a NodeLog
     * const nodeLog = await prisma.nodeLog.upsert({
     *   create: {
     *     // ... data to create a NodeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NodeLog we want to update
     *   }
     * })
     */
    upsert<T extends NodeLogUpsertArgs>(args: SelectSubset<T, NodeLogUpsertArgs<ExtArgs>>): Prisma__NodeLogClient<$Result.GetResult<Prisma.$NodeLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NodeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeLogCountArgs} args - Arguments to filter NodeLogs to count.
     * @example
     * // Count the number of NodeLogs
     * const count = await prisma.nodeLog.count({
     *   where: {
     *     // ... the filter for the NodeLogs we want to count
     *   }
     * })
    **/
    count<T extends NodeLogCountArgs>(
      args?: Subset<T, NodeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NodeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NodeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NodeLogAggregateArgs>(args: Subset<T, NodeLogAggregateArgs>): Prisma.PrismaPromise<GetNodeLogAggregateType<T>>

    /**
     * Group by NodeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NodeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NodeLogGroupByArgs['orderBy'] }
        : { orderBy?: NodeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NodeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNodeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NodeLog model
   */
  readonly fields: NodeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NodeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NodeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nodeExecution<T extends NodeExecutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NodeExecutionDefaultArgs<ExtArgs>>): Prisma__NodeExecutionClient<$Result.GetResult<Prisma.$NodeExecutionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NodeLog model
   */ 
  interface NodeLogFieldRefs {
    readonly id: FieldRef<"NodeLog", 'String'>
    readonly nodeExecutionId: FieldRef<"NodeLog", 'String'>
    readonly level: FieldRef<"NodeLog", 'LogLevel'>
    readonly message: FieldRef<"NodeLog", 'String'>
    readonly createdAt: FieldRef<"NodeLog", 'DateTime'>
    readonly metadata: FieldRef<"NodeLog", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * NodeLog findUnique
   */
  export type NodeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeLog
     */
    select?: NodeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeLogInclude<ExtArgs> | null
    /**
     * Filter, which NodeLog to fetch.
     */
    where: NodeLogWhereUniqueInput
  }

  /**
   * NodeLog findUniqueOrThrow
   */
  export type NodeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeLog
     */
    select?: NodeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeLogInclude<ExtArgs> | null
    /**
     * Filter, which NodeLog to fetch.
     */
    where: NodeLogWhereUniqueInput
  }

  /**
   * NodeLog findFirst
   */
  export type NodeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeLog
     */
    select?: NodeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeLogInclude<ExtArgs> | null
    /**
     * Filter, which NodeLog to fetch.
     */
    where?: NodeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeLogs to fetch.
     */
    orderBy?: NodeLogOrderByWithRelationInput | NodeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NodeLogs.
     */
    cursor?: NodeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NodeLogs.
     */
    distinct?: NodeLogScalarFieldEnum | NodeLogScalarFieldEnum[]
  }

  /**
   * NodeLog findFirstOrThrow
   */
  export type NodeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeLog
     */
    select?: NodeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeLogInclude<ExtArgs> | null
    /**
     * Filter, which NodeLog to fetch.
     */
    where?: NodeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeLogs to fetch.
     */
    orderBy?: NodeLogOrderByWithRelationInput | NodeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NodeLogs.
     */
    cursor?: NodeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NodeLogs.
     */
    distinct?: NodeLogScalarFieldEnum | NodeLogScalarFieldEnum[]
  }

  /**
   * NodeLog findMany
   */
  export type NodeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeLog
     */
    select?: NodeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeLogInclude<ExtArgs> | null
    /**
     * Filter, which NodeLogs to fetch.
     */
    where?: NodeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeLogs to fetch.
     */
    orderBy?: NodeLogOrderByWithRelationInput | NodeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NodeLogs.
     */
    cursor?: NodeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeLogs.
     */
    skip?: number
    distinct?: NodeLogScalarFieldEnum | NodeLogScalarFieldEnum[]
  }

  /**
   * NodeLog create
   */
  export type NodeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeLog
     */
    select?: NodeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a NodeLog.
     */
    data: XOR<NodeLogCreateInput, NodeLogUncheckedCreateInput>
  }

  /**
   * NodeLog createMany
   */
  export type NodeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NodeLogs.
     */
    data: NodeLogCreateManyInput | NodeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NodeLog createManyAndReturn
   */
  export type NodeLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeLog
     */
    select?: NodeLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NodeLogs.
     */
    data: NodeLogCreateManyInput | NodeLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NodeLog update
   */
  export type NodeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeLog
     */
    select?: NodeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a NodeLog.
     */
    data: XOR<NodeLogUpdateInput, NodeLogUncheckedUpdateInput>
    /**
     * Choose, which NodeLog to update.
     */
    where: NodeLogWhereUniqueInput
  }

  /**
   * NodeLog updateMany
   */
  export type NodeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NodeLogs.
     */
    data: XOR<NodeLogUpdateManyMutationInput, NodeLogUncheckedUpdateManyInput>
    /**
     * Filter which NodeLogs to update
     */
    where?: NodeLogWhereInput
  }

  /**
   * NodeLog upsert
   */
  export type NodeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeLog
     */
    select?: NodeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the NodeLog to update in case it exists.
     */
    where: NodeLogWhereUniqueInput
    /**
     * In case the NodeLog found by the `where` argument doesn't exist, create a new NodeLog with this data.
     */
    create: XOR<NodeLogCreateInput, NodeLogUncheckedCreateInput>
    /**
     * In case the NodeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NodeLogUpdateInput, NodeLogUncheckedUpdateInput>
  }

  /**
   * NodeLog delete
   */
  export type NodeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeLog
     */
    select?: NodeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeLogInclude<ExtArgs> | null
    /**
     * Filter which NodeLog to delete.
     */
    where: NodeLogWhereUniqueInput
  }

  /**
   * NodeLog deleteMany
   */
  export type NodeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NodeLogs to delete
     */
    where?: NodeLogWhereInput
  }

  /**
   * NodeLog without action
   */
  export type NodeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeLog
     */
    select?: NodeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeLogInclude<ExtArgs> | null
  }


  /**
   * Model NodeInput
   */

  export type AggregateNodeInput = {
    _count: NodeInputCountAggregateOutputType | null
    _min: NodeInputMinAggregateOutputType | null
    _max: NodeInputMaxAggregateOutputType | null
  }

  export type NodeInputMinAggregateOutputType = {
    id: string | null
    executionId: string | null
    nodeId: string | null
    createdAt: Date | null
  }

  export type NodeInputMaxAggregateOutputType = {
    id: string | null
    executionId: string | null
    nodeId: string | null
    createdAt: Date | null
  }

  export type NodeInputCountAggregateOutputType = {
    id: number
    executionId: number
    nodeId: number
    inputData: number
    createdAt: number
    _all: number
  }


  export type NodeInputMinAggregateInputType = {
    id?: true
    executionId?: true
    nodeId?: true
    createdAt?: true
  }

  export type NodeInputMaxAggregateInputType = {
    id?: true
    executionId?: true
    nodeId?: true
    createdAt?: true
  }

  export type NodeInputCountAggregateInputType = {
    id?: true
    executionId?: true
    nodeId?: true
    inputData?: true
    createdAt?: true
    _all?: true
  }

  export type NodeInputAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NodeInput to aggregate.
     */
    where?: NodeInputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeInputs to fetch.
     */
    orderBy?: NodeInputOrderByWithRelationInput | NodeInputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NodeInputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeInputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeInputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NodeInputs
    **/
    _count?: true | NodeInputCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NodeInputMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NodeInputMaxAggregateInputType
  }

  export type GetNodeInputAggregateType<T extends NodeInputAggregateArgs> = {
        [P in keyof T & keyof AggregateNodeInput]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNodeInput[P]>
      : GetScalarType<T[P], AggregateNodeInput[P]>
  }




  export type NodeInputGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeInputWhereInput
    orderBy?: NodeInputOrderByWithAggregationInput | NodeInputOrderByWithAggregationInput[]
    by: NodeInputScalarFieldEnum[] | NodeInputScalarFieldEnum
    having?: NodeInputScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NodeInputCountAggregateInputType | true
    _min?: NodeInputMinAggregateInputType
    _max?: NodeInputMaxAggregateInputType
  }

  export type NodeInputGroupByOutputType = {
    id: string
    executionId: string
    nodeId: string
    inputData: JsonValue | null
    createdAt: Date | null
    _count: NodeInputCountAggregateOutputType | null
    _min: NodeInputMinAggregateOutputType | null
    _max: NodeInputMaxAggregateOutputType | null
  }

  type GetNodeInputGroupByPayload<T extends NodeInputGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NodeInputGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NodeInputGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NodeInputGroupByOutputType[P]>
            : GetScalarType<T[P], NodeInputGroupByOutputType[P]>
        }
      >
    >


  export type NodeInputSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    nodeId?: boolean
    inputData?: boolean
    createdAt?: boolean
    nodeExecution?: boolean | NodeExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nodeInput"]>

  export type NodeInputSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    nodeId?: boolean
    inputData?: boolean
    createdAt?: boolean
    nodeExecution?: boolean | NodeExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nodeInput"]>

  export type NodeInputSelectScalar = {
    id?: boolean
    executionId?: boolean
    nodeId?: boolean
    inputData?: boolean
    createdAt?: boolean
  }

  export type NodeInputInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodeExecution?: boolean | NodeExecutionDefaultArgs<ExtArgs>
  }
  export type NodeInputIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodeExecution?: boolean | NodeExecutionDefaultArgs<ExtArgs>
  }

  export type $NodeInputPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NodeInput"
    objects: {
      nodeExecution: Prisma.$NodeExecutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      executionId: string
      nodeId: string
      inputData: Prisma.JsonValue | null
      createdAt: Date | null
    }, ExtArgs["result"]["nodeInput"]>
    composites: {}
  }

  type NodeInputGetPayload<S extends boolean | null | undefined | NodeInputDefaultArgs> = $Result.GetResult<Prisma.$NodeInputPayload, S>

  type NodeInputCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NodeInputFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NodeInputCountAggregateInputType | true
    }

  export interface NodeInputDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NodeInput'], meta: { name: 'NodeInput' } }
    /**
     * Find zero or one NodeInput that matches the filter.
     * @param {NodeInputFindUniqueArgs} args - Arguments to find a NodeInput
     * @example
     * // Get one NodeInput
     * const nodeInput = await prisma.nodeInput.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NodeInputFindUniqueArgs>(args: SelectSubset<T, NodeInputFindUniqueArgs<ExtArgs>>): Prisma__NodeInputClient<$Result.GetResult<Prisma.$NodeInputPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NodeInput that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NodeInputFindUniqueOrThrowArgs} args - Arguments to find a NodeInput
     * @example
     * // Get one NodeInput
     * const nodeInput = await prisma.nodeInput.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NodeInputFindUniqueOrThrowArgs>(args: SelectSubset<T, NodeInputFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NodeInputClient<$Result.GetResult<Prisma.$NodeInputPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NodeInput that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeInputFindFirstArgs} args - Arguments to find a NodeInput
     * @example
     * // Get one NodeInput
     * const nodeInput = await prisma.nodeInput.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NodeInputFindFirstArgs>(args?: SelectSubset<T, NodeInputFindFirstArgs<ExtArgs>>): Prisma__NodeInputClient<$Result.GetResult<Prisma.$NodeInputPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NodeInput that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeInputFindFirstOrThrowArgs} args - Arguments to find a NodeInput
     * @example
     * // Get one NodeInput
     * const nodeInput = await prisma.nodeInput.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NodeInputFindFirstOrThrowArgs>(args?: SelectSubset<T, NodeInputFindFirstOrThrowArgs<ExtArgs>>): Prisma__NodeInputClient<$Result.GetResult<Prisma.$NodeInputPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NodeInputs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeInputFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NodeInputs
     * const nodeInputs = await prisma.nodeInput.findMany()
     * 
     * // Get first 10 NodeInputs
     * const nodeInputs = await prisma.nodeInput.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nodeInputWithIdOnly = await prisma.nodeInput.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NodeInputFindManyArgs>(args?: SelectSubset<T, NodeInputFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeInputPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NodeInput.
     * @param {NodeInputCreateArgs} args - Arguments to create a NodeInput.
     * @example
     * // Create one NodeInput
     * const NodeInput = await prisma.nodeInput.create({
     *   data: {
     *     // ... data to create a NodeInput
     *   }
     * })
     * 
     */
    create<T extends NodeInputCreateArgs>(args: SelectSubset<T, NodeInputCreateArgs<ExtArgs>>): Prisma__NodeInputClient<$Result.GetResult<Prisma.$NodeInputPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NodeInputs.
     * @param {NodeInputCreateManyArgs} args - Arguments to create many NodeInputs.
     * @example
     * // Create many NodeInputs
     * const nodeInput = await prisma.nodeInput.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NodeInputCreateManyArgs>(args?: SelectSubset<T, NodeInputCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NodeInputs and returns the data saved in the database.
     * @param {NodeInputCreateManyAndReturnArgs} args - Arguments to create many NodeInputs.
     * @example
     * // Create many NodeInputs
     * const nodeInput = await prisma.nodeInput.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NodeInputs and only return the `id`
     * const nodeInputWithIdOnly = await prisma.nodeInput.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NodeInputCreateManyAndReturnArgs>(args?: SelectSubset<T, NodeInputCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeInputPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NodeInput.
     * @param {NodeInputDeleteArgs} args - Arguments to delete one NodeInput.
     * @example
     * // Delete one NodeInput
     * const NodeInput = await prisma.nodeInput.delete({
     *   where: {
     *     // ... filter to delete one NodeInput
     *   }
     * })
     * 
     */
    delete<T extends NodeInputDeleteArgs>(args: SelectSubset<T, NodeInputDeleteArgs<ExtArgs>>): Prisma__NodeInputClient<$Result.GetResult<Prisma.$NodeInputPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NodeInput.
     * @param {NodeInputUpdateArgs} args - Arguments to update one NodeInput.
     * @example
     * // Update one NodeInput
     * const nodeInput = await prisma.nodeInput.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NodeInputUpdateArgs>(args: SelectSubset<T, NodeInputUpdateArgs<ExtArgs>>): Prisma__NodeInputClient<$Result.GetResult<Prisma.$NodeInputPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NodeInputs.
     * @param {NodeInputDeleteManyArgs} args - Arguments to filter NodeInputs to delete.
     * @example
     * // Delete a few NodeInputs
     * const { count } = await prisma.nodeInput.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NodeInputDeleteManyArgs>(args?: SelectSubset<T, NodeInputDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NodeInputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeInputUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NodeInputs
     * const nodeInput = await prisma.nodeInput.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NodeInputUpdateManyArgs>(args: SelectSubset<T, NodeInputUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NodeInput.
     * @param {NodeInputUpsertArgs} args - Arguments to update or create a NodeInput.
     * @example
     * // Update or create a NodeInput
     * const nodeInput = await prisma.nodeInput.upsert({
     *   create: {
     *     // ... data to create a NodeInput
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NodeInput we want to update
     *   }
     * })
     */
    upsert<T extends NodeInputUpsertArgs>(args: SelectSubset<T, NodeInputUpsertArgs<ExtArgs>>): Prisma__NodeInputClient<$Result.GetResult<Prisma.$NodeInputPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NodeInputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeInputCountArgs} args - Arguments to filter NodeInputs to count.
     * @example
     * // Count the number of NodeInputs
     * const count = await prisma.nodeInput.count({
     *   where: {
     *     // ... the filter for the NodeInputs we want to count
     *   }
     * })
    **/
    count<T extends NodeInputCountArgs>(
      args?: Subset<T, NodeInputCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NodeInputCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NodeInput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeInputAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NodeInputAggregateArgs>(args: Subset<T, NodeInputAggregateArgs>): Prisma.PrismaPromise<GetNodeInputAggregateType<T>>

    /**
     * Group by NodeInput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeInputGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NodeInputGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NodeInputGroupByArgs['orderBy'] }
        : { orderBy?: NodeInputGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NodeInputGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNodeInputGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NodeInput model
   */
  readonly fields: NodeInputFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NodeInput.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NodeInputClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nodeExecution<T extends NodeExecutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NodeExecutionDefaultArgs<ExtArgs>>): Prisma__NodeExecutionClient<$Result.GetResult<Prisma.$NodeExecutionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NodeInput model
   */ 
  interface NodeInputFieldRefs {
    readonly id: FieldRef<"NodeInput", 'String'>
    readonly executionId: FieldRef<"NodeInput", 'String'>
    readonly nodeId: FieldRef<"NodeInput", 'String'>
    readonly inputData: FieldRef<"NodeInput", 'Json'>
    readonly createdAt: FieldRef<"NodeInput", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NodeInput findUnique
   */
  export type NodeInputFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeInput
     */
    select?: NodeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInputInclude<ExtArgs> | null
    /**
     * Filter, which NodeInput to fetch.
     */
    where: NodeInputWhereUniqueInput
  }

  /**
   * NodeInput findUniqueOrThrow
   */
  export type NodeInputFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeInput
     */
    select?: NodeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInputInclude<ExtArgs> | null
    /**
     * Filter, which NodeInput to fetch.
     */
    where: NodeInputWhereUniqueInput
  }

  /**
   * NodeInput findFirst
   */
  export type NodeInputFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeInput
     */
    select?: NodeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInputInclude<ExtArgs> | null
    /**
     * Filter, which NodeInput to fetch.
     */
    where?: NodeInputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeInputs to fetch.
     */
    orderBy?: NodeInputOrderByWithRelationInput | NodeInputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NodeInputs.
     */
    cursor?: NodeInputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeInputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeInputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NodeInputs.
     */
    distinct?: NodeInputScalarFieldEnum | NodeInputScalarFieldEnum[]
  }

  /**
   * NodeInput findFirstOrThrow
   */
  export type NodeInputFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeInput
     */
    select?: NodeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInputInclude<ExtArgs> | null
    /**
     * Filter, which NodeInput to fetch.
     */
    where?: NodeInputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeInputs to fetch.
     */
    orderBy?: NodeInputOrderByWithRelationInput | NodeInputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NodeInputs.
     */
    cursor?: NodeInputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeInputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeInputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NodeInputs.
     */
    distinct?: NodeInputScalarFieldEnum | NodeInputScalarFieldEnum[]
  }

  /**
   * NodeInput findMany
   */
  export type NodeInputFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeInput
     */
    select?: NodeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInputInclude<ExtArgs> | null
    /**
     * Filter, which NodeInputs to fetch.
     */
    where?: NodeInputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeInputs to fetch.
     */
    orderBy?: NodeInputOrderByWithRelationInput | NodeInputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NodeInputs.
     */
    cursor?: NodeInputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeInputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeInputs.
     */
    skip?: number
    distinct?: NodeInputScalarFieldEnum | NodeInputScalarFieldEnum[]
  }

  /**
   * NodeInput create
   */
  export type NodeInputCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeInput
     */
    select?: NodeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInputInclude<ExtArgs> | null
    /**
     * The data needed to create a NodeInput.
     */
    data: XOR<NodeInputCreateInput, NodeInputUncheckedCreateInput>
  }

  /**
   * NodeInput createMany
   */
  export type NodeInputCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NodeInputs.
     */
    data: NodeInputCreateManyInput | NodeInputCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NodeInput createManyAndReturn
   */
  export type NodeInputCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeInput
     */
    select?: NodeInputSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NodeInputs.
     */
    data: NodeInputCreateManyInput | NodeInputCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInputIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NodeInput update
   */
  export type NodeInputUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeInput
     */
    select?: NodeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInputInclude<ExtArgs> | null
    /**
     * The data needed to update a NodeInput.
     */
    data: XOR<NodeInputUpdateInput, NodeInputUncheckedUpdateInput>
    /**
     * Choose, which NodeInput to update.
     */
    where: NodeInputWhereUniqueInput
  }

  /**
   * NodeInput updateMany
   */
  export type NodeInputUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NodeInputs.
     */
    data: XOR<NodeInputUpdateManyMutationInput, NodeInputUncheckedUpdateManyInput>
    /**
     * Filter which NodeInputs to update
     */
    where?: NodeInputWhereInput
  }

  /**
   * NodeInput upsert
   */
  export type NodeInputUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeInput
     */
    select?: NodeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInputInclude<ExtArgs> | null
    /**
     * The filter to search for the NodeInput to update in case it exists.
     */
    where: NodeInputWhereUniqueInput
    /**
     * In case the NodeInput found by the `where` argument doesn't exist, create a new NodeInput with this data.
     */
    create: XOR<NodeInputCreateInput, NodeInputUncheckedCreateInput>
    /**
     * In case the NodeInput was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NodeInputUpdateInput, NodeInputUncheckedUpdateInput>
  }

  /**
   * NodeInput delete
   */
  export type NodeInputDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeInput
     */
    select?: NodeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInputInclude<ExtArgs> | null
    /**
     * Filter which NodeInput to delete.
     */
    where: NodeInputWhereUniqueInput
  }

  /**
   * NodeInput deleteMany
   */
  export type NodeInputDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NodeInputs to delete
     */
    where?: NodeInputWhereInput
  }

  /**
   * NodeInput without action
   */
  export type NodeInputDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeInput
     */
    select?: NodeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInputInclude<ExtArgs> | null
  }


  /**
   * Model NodeOutput
   */

  export type AggregateNodeOutput = {
    _count: NodeOutputCountAggregateOutputType | null
    _min: NodeOutputMinAggregateOutputType | null
    _max: NodeOutputMaxAggregateOutputType | null
  }

  export type NodeOutputMinAggregateOutputType = {
    id: string | null
    executionId: string | null
    nodeId: string | null
    createdAt: Date | null
  }

  export type NodeOutputMaxAggregateOutputType = {
    id: string | null
    executionId: string | null
    nodeId: string | null
    createdAt: Date | null
  }

  export type NodeOutputCountAggregateOutputType = {
    id: number
    executionId: number
    nodeId: number
    outputData: number
    createdAt: number
    _all: number
  }


  export type NodeOutputMinAggregateInputType = {
    id?: true
    executionId?: true
    nodeId?: true
    createdAt?: true
  }

  export type NodeOutputMaxAggregateInputType = {
    id?: true
    executionId?: true
    nodeId?: true
    createdAt?: true
  }

  export type NodeOutputCountAggregateInputType = {
    id?: true
    executionId?: true
    nodeId?: true
    outputData?: true
    createdAt?: true
    _all?: true
  }

  export type NodeOutputAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NodeOutput to aggregate.
     */
    where?: NodeOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeOutputs to fetch.
     */
    orderBy?: NodeOutputOrderByWithRelationInput | NodeOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NodeOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NodeOutputs
    **/
    _count?: true | NodeOutputCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NodeOutputMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NodeOutputMaxAggregateInputType
  }

  export type GetNodeOutputAggregateType<T extends NodeOutputAggregateArgs> = {
        [P in keyof T & keyof AggregateNodeOutput]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNodeOutput[P]>
      : GetScalarType<T[P], AggregateNodeOutput[P]>
  }




  export type NodeOutputGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeOutputWhereInput
    orderBy?: NodeOutputOrderByWithAggregationInput | NodeOutputOrderByWithAggregationInput[]
    by: NodeOutputScalarFieldEnum[] | NodeOutputScalarFieldEnum
    having?: NodeOutputScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NodeOutputCountAggregateInputType | true
    _min?: NodeOutputMinAggregateInputType
    _max?: NodeOutputMaxAggregateInputType
  }

  export type NodeOutputGroupByOutputType = {
    id: string
    executionId: string
    nodeId: string
    outputData: JsonValue | null
    createdAt: Date | null
    _count: NodeOutputCountAggregateOutputType | null
    _min: NodeOutputMinAggregateOutputType | null
    _max: NodeOutputMaxAggregateOutputType | null
  }

  type GetNodeOutputGroupByPayload<T extends NodeOutputGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NodeOutputGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NodeOutputGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NodeOutputGroupByOutputType[P]>
            : GetScalarType<T[P], NodeOutputGroupByOutputType[P]>
        }
      >
    >


  export type NodeOutputSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    nodeId?: boolean
    outputData?: boolean
    createdAt?: boolean
    nodeExecution?: boolean | NodeExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nodeOutput"]>

  export type NodeOutputSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    nodeId?: boolean
    outputData?: boolean
    createdAt?: boolean
    nodeExecution?: boolean | NodeExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nodeOutput"]>

  export type NodeOutputSelectScalar = {
    id?: boolean
    executionId?: boolean
    nodeId?: boolean
    outputData?: boolean
    createdAt?: boolean
  }

  export type NodeOutputInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodeExecution?: boolean | NodeExecutionDefaultArgs<ExtArgs>
  }
  export type NodeOutputIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodeExecution?: boolean | NodeExecutionDefaultArgs<ExtArgs>
  }

  export type $NodeOutputPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NodeOutput"
    objects: {
      nodeExecution: Prisma.$NodeExecutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      executionId: string
      nodeId: string
      outputData: Prisma.JsonValue | null
      createdAt: Date | null
    }, ExtArgs["result"]["nodeOutput"]>
    composites: {}
  }

  type NodeOutputGetPayload<S extends boolean | null | undefined | NodeOutputDefaultArgs> = $Result.GetResult<Prisma.$NodeOutputPayload, S>

  type NodeOutputCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NodeOutputFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NodeOutputCountAggregateInputType | true
    }

  export interface NodeOutputDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NodeOutput'], meta: { name: 'NodeOutput' } }
    /**
     * Find zero or one NodeOutput that matches the filter.
     * @param {NodeOutputFindUniqueArgs} args - Arguments to find a NodeOutput
     * @example
     * // Get one NodeOutput
     * const nodeOutput = await prisma.nodeOutput.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NodeOutputFindUniqueArgs>(args: SelectSubset<T, NodeOutputFindUniqueArgs<ExtArgs>>): Prisma__NodeOutputClient<$Result.GetResult<Prisma.$NodeOutputPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NodeOutput that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NodeOutputFindUniqueOrThrowArgs} args - Arguments to find a NodeOutput
     * @example
     * // Get one NodeOutput
     * const nodeOutput = await prisma.nodeOutput.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NodeOutputFindUniqueOrThrowArgs>(args: SelectSubset<T, NodeOutputFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NodeOutputClient<$Result.GetResult<Prisma.$NodeOutputPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NodeOutput that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeOutputFindFirstArgs} args - Arguments to find a NodeOutput
     * @example
     * // Get one NodeOutput
     * const nodeOutput = await prisma.nodeOutput.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NodeOutputFindFirstArgs>(args?: SelectSubset<T, NodeOutputFindFirstArgs<ExtArgs>>): Prisma__NodeOutputClient<$Result.GetResult<Prisma.$NodeOutputPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NodeOutput that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeOutputFindFirstOrThrowArgs} args - Arguments to find a NodeOutput
     * @example
     * // Get one NodeOutput
     * const nodeOutput = await prisma.nodeOutput.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NodeOutputFindFirstOrThrowArgs>(args?: SelectSubset<T, NodeOutputFindFirstOrThrowArgs<ExtArgs>>): Prisma__NodeOutputClient<$Result.GetResult<Prisma.$NodeOutputPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NodeOutputs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeOutputFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NodeOutputs
     * const nodeOutputs = await prisma.nodeOutput.findMany()
     * 
     * // Get first 10 NodeOutputs
     * const nodeOutputs = await prisma.nodeOutput.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nodeOutputWithIdOnly = await prisma.nodeOutput.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NodeOutputFindManyArgs>(args?: SelectSubset<T, NodeOutputFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeOutputPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NodeOutput.
     * @param {NodeOutputCreateArgs} args - Arguments to create a NodeOutput.
     * @example
     * // Create one NodeOutput
     * const NodeOutput = await prisma.nodeOutput.create({
     *   data: {
     *     // ... data to create a NodeOutput
     *   }
     * })
     * 
     */
    create<T extends NodeOutputCreateArgs>(args: SelectSubset<T, NodeOutputCreateArgs<ExtArgs>>): Prisma__NodeOutputClient<$Result.GetResult<Prisma.$NodeOutputPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NodeOutputs.
     * @param {NodeOutputCreateManyArgs} args - Arguments to create many NodeOutputs.
     * @example
     * // Create many NodeOutputs
     * const nodeOutput = await prisma.nodeOutput.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NodeOutputCreateManyArgs>(args?: SelectSubset<T, NodeOutputCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NodeOutputs and returns the data saved in the database.
     * @param {NodeOutputCreateManyAndReturnArgs} args - Arguments to create many NodeOutputs.
     * @example
     * // Create many NodeOutputs
     * const nodeOutput = await prisma.nodeOutput.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NodeOutputs and only return the `id`
     * const nodeOutputWithIdOnly = await prisma.nodeOutput.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NodeOutputCreateManyAndReturnArgs>(args?: SelectSubset<T, NodeOutputCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeOutputPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NodeOutput.
     * @param {NodeOutputDeleteArgs} args - Arguments to delete one NodeOutput.
     * @example
     * // Delete one NodeOutput
     * const NodeOutput = await prisma.nodeOutput.delete({
     *   where: {
     *     // ... filter to delete one NodeOutput
     *   }
     * })
     * 
     */
    delete<T extends NodeOutputDeleteArgs>(args: SelectSubset<T, NodeOutputDeleteArgs<ExtArgs>>): Prisma__NodeOutputClient<$Result.GetResult<Prisma.$NodeOutputPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NodeOutput.
     * @param {NodeOutputUpdateArgs} args - Arguments to update one NodeOutput.
     * @example
     * // Update one NodeOutput
     * const nodeOutput = await prisma.nodeOutput.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NodeOutputUpdateArgs>(args: SelectSubset<T, NodeOutputUpdateArgs<ExtArgs>>): Prisma__NodeOutputClient<$Result.GetResult<Prisma.$NodeOutputPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NodeOutputs.
     * @param {NodeOutputDeleteManyArgs} args - Arguments to filter NodeOutputs to delete.
     * @example
     * // Delete a few NodeOutputs
     * const { count } = await prisma.nodeOutput.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NodeOutputDeleteManyArgs>(args?: SelectSubset<T, NodeOutputDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NodeOutputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeOutputUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NodeOutputs
     * const nodeOutput = await prisma.nodeOutput.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NodeOutputUpdateManyArgs>(args: SelectSubset<T, NodeOutputUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NodeOutput.
     * @param {NodeOutputUpsertArgs} args - Arguments to update or create a NodeOutput.
     * @example
     * // Update or create a NodeOutput
     * const nodeOutput = await prisma.nodeOutput.upsert({
     *   create: {
     *     // ... data to create a NodeOutput
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NodeOutput we want to update
     *   }
     * })
     */
    upsert<T extends NodeOutputUpsertArgs>(args: SelectSubset<T, NodeOutputUpsertArgs<ExtArgs>>): Prisma__NodeOutputClient<$Result.GetResult<Prisma.$NodeOutputPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NodeOutputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeOutputCountArgs} args - Arguments to filter NodeOutputs to count.
     * @example
     * // Count the number of NodeOutputs
     * const count = await prisma.nodeOutput.count({
     *   where: {
     *     // ... the filter for the NodeOutputs we want to count
     *   }
     * })
    **/
    count<T extends NodeOutputCountArgs>(
      args?: Subset<T, NodeOutputCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NodeOutputCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NodeOutput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeOutputAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NodeOutputAggregateArgs>(args: Subset<T, NodeOutputAggregateArgs>): Prisma.PrismaPromise<GetNodeOutputAggregateType<T>>

    /**
     * Group by NodeOutput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeOutputGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NodeOutputGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NodeOutputGroupByArgs['orderBy'] }
        : { orderBy?: NodeOutputGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NodeOutputGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNodeOutputGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NodeOutput model
   */
  readonly fields: NodeOutputFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NodeOutput.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NodeOutputClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nodeExecution<T extends NodeExecutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NodeExecutionDefaultArgs<ExtArgs>>): Prisma__NodeExecutionClient<$Result.GetResult<Prisma.$NodeExecutionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NodeOutput model
   */ 
  interface NodeOutputFieldRefs {
    readonly id: FieldRef<"NodeOutput", 'String'>
    readonly executionId: FieldRef<"NodeOutput", 'String'>
    readonly nodeId: FieldRef<"NodeOutput", 'String'>
    readonly outputData: FieldRef<"NodeOutput", 'Json'>
    readonly createdAt: FieldRef<"NodeOutput", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NodeOutput findUnique
   */
  export type NodeOutputFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeOutput
     */
    select?: NodeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeOutputInclude<ExtArgs> | null
    /**
     * Filter, which NodeOutput to fetch.
     */
    where: NodeOutputWhereUniqueInput
  }

  /**
   * NodeOutput findUniqueOrThrow
   */
  export type NodeOutputFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeOutput
     */
    select?: NodeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeOutputInclude<ExtArgs> | null
    /**
     * Filter, which NodeOutput to fetch.
     */
    where: NodeOutputWhereUniqueInput
  }

  /**
   * NodeOutput findFirst
   */
  export type NodeOutputFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeOutput
     */
    select?: NodeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeOutputInclude<ExtArgs> | null
    /**
     * Filter, which NodeOutput to fetch.
     */
    where?: NodeOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeOutputs to fetch.
     */
    orderBy?: NodeOutputOrderByWithRelationInput | NodeOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NodeOutputs.
     */
    cursor?: NodeOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NodeOutputs.
     */
    distinct?: NodeOutputScalarFieldEnum | NodeOutputScalarFieldEnum[]
  }

  /**
   * NodeOutput findFirstOrThrow
   */
  export type NodeOutputFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeOutput
     */
    select?: NodeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeOutputInclude<ExtArgs> | null
    /**
     * Filter, which NodeOutput to fetch.
     */
    where?: NodeOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeOutputs to fetch.
     */
    orderBy?: NodeOutputOrderByWithRelationInput | NodeOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NodeOutputs.
     */
    cursor?: NodeOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NodeOutputs.
     */
    distinct?: NodeOutputScalarFieldEnum | NodeOutputScalarFieldEnum[]
  }

  /**
   * NodeOutput findMany
   */
  export type NodeOutputFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeOutput
     */
    select?: NodeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeOutputInclude<ExtArgs> | null
    /**
     * Filter, which NodeOutputs to fetch.
     */
    where?: NodeOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeOutputs to fetch.
     */
    orderBy?: NodeOutputOrderByWithRelationInput | NodeOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NodeOutputs.
     */
    cursor?: NodeOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeOutputs.
     */
    skip?: number
    distinct?: NodeOutputScalarFieldEnum | NodeOutputScalarFieldEnum[]
  }

  /**
   * NodeOutput create
   */
  export type NodeOutputCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeOutput
     */
    select?: NodeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeOutputInclude<ExtArgs> | null
    /**
     * The data needed to create a NodeOutput.
     */
    data: XOR<NodeOutputCreateInput, NodeOutputUncheckedCreateInput>
  }

  /**
   * NodeOutput createMany
   */
  export type NodeOutputCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NodeOutputs.
     */
    data: NodeOutputCreateManyInput | NodeOutputCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NodeOutput createManyAndReturn
   */
  export type NodeOutputCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeOutput
     */
    select?: NodeOutputSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NodeOutputs.
     */
    data: NodeOutputCreateManyInput | NodeOutputCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeOutputIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NodeOutput update
   */
  export type NodeOutputUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeOutput
     */
    select?: NodeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeOutputInclude<ExtArgs> | null
    /**
     * The data needed to update a NodeOutput.
     */
    data: XOR<NodeOutputUpdateInput, NodeOutputUncheckedUpdateInput>
    /**
     * Choose, which NodeOutput to update.
     */
    where: NodeOutputWhereUniqueInput
  }

  /**
   * NodeOutput updateMany
   */
  export type NodeOutputUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NodeOutputs.
     */
    data: XOR<NodeOutputUpdateManyMutationInput, NodeOutputUncheckedUpdateManyInput>
    /**
     * Filter which NodeOutputs to update
     */
    where?: NodeOutputWhereInput
  }

  /**
   * NodeOutput upsert
   */
  export type NodeOutputUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeOutput
     */
    select?: NodeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeOutputInclude<ExtArgs> | null
    /**
     * The filter to search for the NodeOutput to update in case it exists.
     */
    where: NodeOutputWhereUniqueInput
    /**
     * In case the NodeOutput found by the `where` argument doesn't exist, create a new NodeOutput with this data.
     */
    create: XOR<NodeOutputCreateInput, NodeOutputUncheckedCreateInput>
    /**
     * In case the NodeOutput was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NodeOutputUpdateInput, NodeOutputUncheckedUpdateInput>
  }

  /**
   * NodeOutput delete
   */
  export type NodeOutputDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeOutput
     */
    select?: NodeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeOutputInclude<ExtArgs> | null
    /**
     * Filter which NodeOutput to delete.
     */
    where: NodeOutputWhereUniqueInput
  }

  /**
   * NodeOutput deleteMany
   */
  export type NodeOutputDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NodeOutputs to delete
     */
    where?: NodeOutputWhereInput
  }

  /**
   * NodeOutput without action
   */
  export type NodeOutputDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeOutput
     */
    select?: NodeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeOutputInclude<ExtArgs> | null
  }


  /**
   * Model ExecutionLog
   */

  export type AggregateExecutionLog = {
    _count: ExecutionLogCountAggregateOutputType | null
    _min: ExecutionLogMinAggregateOutputType | null
    _max: ExecutionLogMaxAggregateOutputType | null
  }

  export type ExecutionLogMinAggregateOutputType = {
    id: string | null
    executionId: string | null
    level: $Enums.LogLevel | null
    message: string | null
    timestamp: Date | null
  }

  export type ExecutionLogMaxAggregateOutputType = {
    id: string | null
    executionId: string | null
    level: $Enums.LogLevel | null
    message: string | null
    timestamp: Date | null
  }

  export type ExecutionLogCountAggregateOutputType = {
    id: number
    executionId: number
    level: number
    message: number
    timestamp: number
    metadata: number
    _all: number
  }


  export type ExecutionLogMinAggregateInputType = {
    id?: true
    executionId?: true
    level?: true
    message?: true
    timestamp?: true
  }

  export type ExecutionLogMaxAggregateInputType = {
    id?: true
    executionId?: true
    level?: true
    message?: true
    timestamp?: true
  }

  export type ExecutionLogCountAggregateInputType = {
    id?: true
    executionId?: true
    level?: true
    message?: true
    timestamp?: true
    metadata?: true
    _all?: true
  }

  export type ExecutionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExecutionLog to aggregate.
     */
    where?: ExecutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionLogs to fetch.
     */
    orderBy?: ExecutionLogOrderByWithRelationInput | ExecutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExecutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExecutionLogs
    **/
    _count?: true | ExecutionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExecutionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExecutionLogMaxAggregateInputType
  }

  export type GetExecutionLogAggregateType<T extends ExecutionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateExecutionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExecutionLog[P]>
      : GetScalarType<T[P], AggregateExecutionLog[P]>
  }




  export type ExecutionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExecutionLogWhereInput
    orderBy?: ExecutionLogOrderByWithAggregationInput | ExecutionLogOrderByWithAggregationInput[]
    by: ExecutionLogScalarFieldEnum[] | ExecutionLogScalarFieldEnum
    having?: ExecutionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExecutionLogCountAggregateInputType | true
    _min?: ExecutionLogMinAggregateInputType
    _max?: ExecutionLogMaxAggregateInputType
  }

  export type ExecutionLogGroupByOutputType = {
    id: string
    executionId: string
    level: $Enums.LogLevel
    message: string
    timestamp: Date
    metadata: JsonValue | null
    _count: ExecutionLogCountAggregateOutputType | null
    _min: ExecutionLogMinAggregateOutputType | null
    _max: ExecutionLogMaxAggregateOutputType | null
  }

  type GetExecutionLogGroupByPayload<T extends ExecutionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExecutionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExecutionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExecutionLogGroupByOutputType[P]>
            : GetScalarType<T[P], ExecutionLogGroupByOutputType[P]>
        }
      >
    >


  export type ExecutionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    level?: boolean
    message?: boolean
    timestamp?: boolean
    metadata?: boolean
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["executionLog"]>

  export type ExecutionLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    level?: boolean
    message?: boolean
    timestamp?: boolean
    metadata?: boolean
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["executionLog"]>

  export type ExecutionLogSelectScalar = {
    id?: boolean
    executionId?: boolean
    level?: boolean
    message?: boolean
    timestamp?: boolean
    metadata?: boolean
  }

  export type ExecutionLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }
  export type ExecutionLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }

  export type $ExecutionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExecutionLog"
    objects: {
      execution: Prisma.$WorkflowExecutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      executionId: string
      level: $Enums.LogLevel
      message: string
      timestamp: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["executionLog"]>
    composites: {}
  }

  type ExecutionLogGetPayload<S extends boolean | null | undefined | ExecutionLogDefaultArgs> = $Result.GetResult<Prisma.$ExecutionLogPayload, S>

  type ExecutionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExecutionLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExecutionLogCountAggregateInputType | true
    }

  export interface ExecutionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExecutionLog'], meta: { name: 'ExecutionLog' } }
    /**
     * Find zero or one ExecutionLog that matches the filter.
     * @param {ExecutionLogFindUniqueArgs} args - Arguments to find a ExecutionLog
     * @example
     * // Get one ExecutionLog
     * const executionLog = await prisma.executionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExecutionLogFindUniqueArgs>(args: SelectSubset<T, ExecutionLogFindUniqueArgs<ExtArgs>>): Prisma__ExecutionLogClient<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExecutionLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExecutionLogFindUniqueOrThrowArgs} args - Arguments to find a ExecutionLog
     * @example
     * // Get one ExecutionLog
     * const executionLog = await prisma.executionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExecutionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ExecutionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExecutionLogClient<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExecutionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionLogFindFirstArgs} args - Arguments to find a ExecutionLog
     * @example
     * // Get one ExecutionLog
     * const executionLog = await prisma.executionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExecutionLogFindFirstArgs>(args?: SelectSubset<T, ExecutionLogFindFirstArgs<ExtArgs>>): Prisma__ExecutionLogClient<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExecutionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionLogFindFirstOrThrowArgs} args - Arguments to find a ExecutionLog
     * @example
     * // Get one ExecutionLog
     * const executionLog = await prisma.executionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExecutionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ExecutionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExecutionLogClient<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExecutionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExecutionLogs
     * const executionLogs = await prisma.executionLog.findMany()
     * 
     * // Get first 10 ExecutionLogs
     * const executionLogs = await prisma.executionLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const executionLogWithIdOnly = await prisma.executionLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExecutionLogFindManyArgs>(args?: SelectSubset<T, ExecutionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExecutionLog.
     * @param {ExecutionLogCreateArgs} args - Arguments to create a ExecutionLog.
     * @example
     * // Create one ExecutionLog
     * const ExecutionLog = await prisma.executionLog.create({
     *   data: {
     *     // ... data to create a ExecutionLog
     *   }
     * })
     * 
     */
    create<T extends ExecutionLogCreateArgs>(args: SelectSubset<T, ExecutionLogCreateArgs<ExtArgs>>): Prisma__ExecutionLogClient<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExecutionLogs.
     * @param {ExecutionLogCreateManyArgs} args - Arguments to create many ExecutionLogs.
     * @example
     * // Create many ExecutionLogs
     * const executionLog = await prisma.executionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExecutionLogCreateManyArgs>(args?: SelectSubset<T, ExecutionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExecutionLogs and returns the data saved in the database.
     * @param {ExecutionLogCreateManyAndReturnArgs} args - Arguments to create many ExecutionLogs.
     * @example
     * // Create many ExecutionLogs
     * const executionLog = await prisma.executionLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExecutionLogs and only return the `id`
     * const executionLogWithIdOnly = await prisma.executionLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExecutionLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ExecutionLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExecutionLog.
     * @param {ExecutionLogDeleteArgs} args - Arguments to delete one ExecutionLog.
     * @example
     * // Delete one ExecutionLog
     * const ExecutionLog = await prisma.executionLog.delete({
     *   where: {
     *     // ... filter to delete one ExecutionLog
     *   }
     * })
     * 
     */
    delete<T extends ExecutionLogDeleteArgs>(args: SelectSubset<T, ExecutionLogDeleteArgs<ExtArgs>>): Prisma__ExecutionLogClient<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExecutionLog.
     * @param {ExecutionLogUpdateArgs} args - Arguments to update one ExecutionLog.
     * @example
     * // Update one ExecutionLog
     * const executionLog = await prisma.executionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExecutionLogUpdateArgs>(args: SelectSubset<T, ExecutionLogUpdateArgs<ExtArgs>>): Prisma__ExecutionLogClient<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExecutionLogs.
     * @param {ExecutionLogDeleteManyArgs} args - Arguments to filter ExecutionLogs to delete.
     * @example
     * // Delete a few ExecutionLogs
     * const { count } = await prisma.executionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExecutionLogDeleteManyArgs>(args?: SelectSubset<T, ExecutionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExecutionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExecutionLogs
     * const executionLog = await prisma.executionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExecutionLogUpdateManyArgs>(args: SelectSubset<T, ExecutionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExecutionLog.
     * @param {ExecutionLogUpsertArgs} args - Arguments to update or create a ExecutionLog.
     * @example
     * // Update or create a ExecutionLog
     * const executionLog = await prisma.executionLog.upsert({
     *   create: {
     *     // ... data to create a ExecutionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExecutionLog we want to update
     *   }
     * })
     */
    upsert<T extends ExecutionLogUpsertArgs>(args: SelectSubset<T, ExecutionLogUpsertArgs<ExtArgs>>): Prisma__ExecutionLogClient<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExecutionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionLogCountArgs} args - Arguments to filter ExecutionLogs to count.
     * @example
     * // Count the number of ExecutionLogs
     * const count = await prisma.executionLog.count({
     *   where: {
     *     // ... the filter for the ExecutionLogs we want to count
     *   }
     * })
    **/
    count<T extends ExecutionLogCountArgs>(
      args?: Subset<T, ExecutionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExecutionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExecutionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExecutionLogAggregateArgs>(args: Subset<T, ExecutionLogAggregateArgs>): Prisma.PrismaPromise<GetExecutionLogAggregateType<T>>

    /**
     * Group by ExecutionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExecutionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExecutionLogGroupByArgs['orderBy'] }
        : { orderBy?: ExecutionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExecutionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExecutionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExecutionLog model
   */
  readonly fields: ExecutionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExecutionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExecutionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    execution<T extends WorkflowExecutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowExecutionDefaultArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExecutionLog model
   */ 
  interface ExecutionLogFieldRefs {
    readonly id: FieldRef<"ExecutionLog", 'String'>
    readonly executionId: FieldRef<"ExecutionLog", 'String'>
    readonly level: FieldRef<"ExecutionLog", 'LogLevel'>
    readonly message: FieldRef<"ExecutionLog", 'String'>
    readonly timestamp: FieldRef<"ExecutionLog", 'DateTime'>
    readonly metadata: FieldRef<"ExecutionLog", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ExecutionLog findUnique
   */
  export type ExecutionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which ExecutionLog to fetch.
     */
    where: ExecutionLogWhereUniqueInput
  }

  /**
   * ExecutionLog findUniqueOrThrow
   */
  export type ExecutionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which ExecutionLog to fetch.
     */
    where: ExecutionLogWhereUniqueInput
  }

  /**
   * ExecutionLog findFirst
   */
  export type ExecutionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which ExecutionLog to fetch.
     */
    where?: ExecutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionLogs to fetch.
     */
    orderBy?: ExecutionLogOrderByWithRelationInput | ExecutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExecutionLogs.
     */
    cursor?: ExecutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExecutionLogs.
     */
    distinct?: ExecutionLogScalarFieldEnum | ExecutionLogScalarFieldEnum[]
  }

  /**
   * ExecutionLog findFirstOrThrow
   */
  export type ExecutionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which ExecutionLog to fetch.
     */
    where?: ExecutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionLogs to fetch.
     */
    orderBy?: ExecutionLogOrderByWithRelationInput | ExecutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExecutionLogs.
     */
    cursor?: ExecutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExecutionLogs.
     */
    distinct?: ExecutionLogScalarFieldEnum | ExecutionLogScalarFieldEnum[]
  }

  /**
   * ExecutionLog findMany
   */
  export type ExecutionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which ExecutionLogs to fetch.
     */
    where?: ExecutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionLogs to fetch.
     */
    orderBy?: ExecutionLogOrderByWithRelationInput | ExecutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExecutionLogs.
     */
    cursor?: ExecutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionLogs.
     */
    skip?: number
    distinct?: ExecutionLogScalarFieldEnum | ExecutionLogScalarFieldEnum[]
  }

  /**
   * ExecutionLog create
   */
  export type ExecutionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ExecutionLog.
     */
    data: XOR<ExecutionLogCreateInput, ExecutionLogUncheckedCreateInput>
  }

  /**
   * ExecutionLog createMany
   */
  export type ExecutionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExecutionLogs.
     */
    data: ExecutionLogCreateManyInput | ExecutionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExecutionLog createManyAndReturn
   */
  export type ExecutionLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExecutionLogs.
     */
    data: ExecutionLogCreateManyInput | ExecutionLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExecutionLog update
   */
  export type ExecutionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ExecutionLog.
     */
    data: XOR<ExecutionLogUpdateInput, ExecutionLogUncheckedUpdateInput>
    /**
     * Choose, which ExecutionLog to update.
     */
    where: ExecutionLogWhereUniqueInput
  }

  /**
   * ExecutionLog updateMany
   */
  export type ExecutionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExecutionLogs.
     */
    data: XOR<ExecutionLogUpdateManyMutationInput, ExecutionLogUncheckedUpdateManyInput>
    /**
     * Filter which ExecutionLogs to update
     */
    where?: ExecutionLogWhereInput
  }

  /**
   * ExecutionLog upsert
   */
  export type ExecutionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ExecutionLog to update in case it exists.
     */
    where: ExecutionLogWhereUniqueInput
    /**
     * In case the ExecutionLog found by the `where` argument doesn't exist, create a new ExecutionLog with this data.
     */
    create: XOR<ExecutionLogCreateInput, ExecutionLogUncheckedCreateInput>
    /**
     * In case the ExecutionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExecutionLogUpdateInput, ExecutionLogUncheckedUpdateInput>
  }

  /**
   * ExecutionLog delete
   */
  export type ExecutionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * Filter which ExecutionLog to delete.
     */
    where: ExecutionLogWhereUniqueInput
  }

  /**
   * ExecutionLog deleteMany
   */
  export type ExecutionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExecutionLogs to delete
     */
    where?: ExecutionLogWhereInput
  }

  /**
   * ExecutionLog without action
   */
  export type ExecutionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowPause
   */

  export type AggregateWorkflowPause = {
    _count: WorkflowPauseCountAggregateOutputType | null
    _min: WorkflowPauseMinAggregateOutputType | null
    _max: WorkflowPauseMaxAggregateOutputType | null
  }

  export type WorkflowPauseMinAggregateOutputType = {
    id: string | null
    workflowId: string | null
    executionId: string | null
    nodeId: string | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowPauseMaxAggregateOutputType = {
    id: string | null
    workflowId: string | null
    executionId: string | null
    nodeId: string | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowPauseCountAggregateOutputType = {
    id: number
    workflowId: number
    executionId: number
    nodeId: number
    reason: number
    resumeData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkflowPauseMinAggregateInputType = {
    id?: true
    workflowId?: true
    executionId?: true
    nodeId?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowPauseMaxAggregateInputType = {
    id?: true
    workflowId?: true
    executionId?: true
    nodeId?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowPauseCountAggregateInputType = {
    id?: true
    workflowId?: true
    executionId?: true
    nodeId?: true
    reason?: true
    resumeData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkflowPauseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowPause to aggregate.
     */
    where?: WorkflowPauseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowPauses to fetch.
     */
    orderBy?: WorkflowPauseOrderByWithRelationInput | WorkflowPauseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowPauseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowPauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowPauses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowPauses
    **/
    _count?: true | WorkflowPauseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowPauseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowPauseMaxAggregateInputType
  }

  export type GetWorkflowPauseAggregateType<T extends WorkflowPauseAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowPause]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowPause[P]>
      : GetScalarType<T[P], AggregateWorkflowPause[P]>
  }




  export type WorkflowPauseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowPauseWhereInput
    orderBy?: WorkflowPauseOrderByWithAggregationInput | WorkflowPauseOrderByWithAggregationInput[]
    by: WorkflowPauseScalarFieldEnum[] | WorkflowPauseScalarFieldEnum
    having?: WorkflowPauseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowPauseCountAggregateInputType | true
    _min?: WorkflowPauseMinAggregateInputType
    _max?: WorkflowPauseMaxAggregateInputType
  }

  export type WorkflowPauseGroupByOutputType = {
    id: string
    workflowId: string
    executionId: string
    nodeId: string
    reason: string
    resumeData: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: WorkflowPauseCountAggregateOutputType | null
    _min: WorkflowPauseMinAggregateOutputType | null
    _max: WorkflowPauseMaxAggregateOutputType | null
  }

  type GetWorkflowPauseGroupByPayload<T extends WorkflowPauseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowPauseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowPauseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowPauseGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowPauseGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowPauseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    executionId?: boolean
    nodeId?: boolean
    reason?: boolean
    resumeData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowPause"]>

  export type WorkflowPauseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    executionId?: boolean
    nodeId?: boolean
    reason?: boolean
    resumeData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowPause"]>

  export type WorkflowPauseSelectScalar = {
    id?: boolean
    workflowId?: boolean
    executionId?: boolean
    nodeId?: boolean
    reason?: boolean
    resumeData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkflowPauseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }
  export type WorkflowPauseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }

  export type $WorkflowPausePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowPause"
    objects: {
      workflow: Prisma.$WorkflowPayload<ExtArgs>
      execution: Prisma.$WorkflowExecutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowId: string
      executionId: string
      nodeId: string
      reason: string
      resumeData: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workflowPause"]>
    composites: {}
  }

  type WorkflowPauseGetPayload<S extends boolean | null | undefined | WorkflowPauseDefaultArgs> = $Result.GetResult<Prisma.$WorkflowPausePayload, S>

  type WorkflowPauseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowPauseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowPauseCountAggregateInputType | true
    }

  export interface WorkflowPauseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowPause'], meta: { name: 'WorkflowPause' } }
    /**
     * Find zero or one WorkflowPause that matches the filter.
     * @param {WorkflowPauseFindUniqueArgs} args - Arguments to find a WorkflowPause
     * @example
     * // Get one WorkflowPause
     * const workflowPause = await prisma.workflowPause.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowPauseFindUniqueArgs>(args: SelectSubset<T, WorkflowPauseFindUniqueArgs<ExtArgs>>): Prisma__WorkflowPauseClient<$Result.GetResult<Prisma.$WorkflowPausePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowPause that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowPauseFindUniqueOrThrowArgs} args - Arguments to find a WorkflowPause
     * @example
     * // Get one WorkflowPause
     * const workflowPause = await prisma.workflowPause.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowPauseFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowPauseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowPauseClient<$Result.GetResult<Prisma.$WorkflowPausePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowPause that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowPauseFindFirstArgs} args - Arguments to find a WorkflowPause
     * @example
     * // Get one WorkflowPause
     * const workflowPause = await prisma.workflowPause.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowPauseFindFirstArgs>(args?: SelectSubset<T, WorkflowPauseFindFirstArgs<ExtArgs>>): Prisma__WorkflowPauseClient<$Result.GetResult<Prisma.$WorkflowPausePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowPause that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowPauseFindFirstOrThrowArgs} args - Arguments to find a WorkflowPause
     * @example
     * // Get one WorkflowPause
     * const workflowPause = await prisma.workflowPause.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowPauseFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowPauseFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowPauseClient<$Result.GetResult<Prisma.$WorkflowPausePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowPauses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowPauseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowPauses
     * const workflowPauses = await prisma.workflowPause.findMany()
     * 
     * // Get first 10 WorkflowPauses
     * const workflowPauses = await prisma.workflowPause.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowPauseWithIdOnly = await prisma.workflowPause.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowPauseFindManyArgs>(args?: SelectSubset<T, WorkflowPauseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPausePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowPause.
     * @param {WorkflowPauseCreateArgs} args - Arguments to create a WorkflowPause.
     * @example
     * // Create one WorkflowPause
     * const WorkflowPause = await prisma.workflowPause.create({
     *   data: {
     *     // ... data to create a WorkflowPause
     *   }
     * })
     * 
     */
    create<T extends WorkflowPauseCreateArgs>(args: SelectSubset<T, WorkflowPauseCreateArgs<ExtArgs>>): Prisma__WorkflowPauseClient<$Result.GetResult<Prisma.$WorkflowPausePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowPauses.
     * @param {WorkflowPauseCreateManyArgs} args - Arguments to create many WorkflowPauses.
     * @example
     * // Create many WorkflowPauses
     * const workflowPause = await prisma.workflowPause.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowPauseCreateManyArgs>(args?: SelectSubset<T, WorkflowPauseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowPauses and returns the data saved in the database.
     * @param {WorkflowPauseCreateManyAndReturnArgs} args - Arguments to create many WorkflowPauses.
     * @example
     * // Create many WorkflowPauses
     * const workflowPause = await prisma.workflowPause.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowPauses and only return the `id`
     * const workflowPauseWithIdOnly = await prisma.workflowPause.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowPauseCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowPauseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPausePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkflowPause.
     * @param {WorkflowPauseDeleteArgs} args - Arguments to delete one WorkflowPause.
     * @example
     * // Delete one WorkflowPause
     * const WorkflowPause = await prisma.workflowPause.delete({
     *   where: {
     *     // ... filter to delete one WorkflowPause
     *   }
     * })
     * 
     */
    delete<T extends WorkflowPauseDeleteArgs>(args: SelectSubset<T, WorkflowPauseDeleteArgs<ExtArgs>>): Prisma__WorkflowPauseClient<$Result.GetResult<Prisma.$WorkflowPausePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowPause.
     * @param {WorkflowPauseUpdateArgs} args - Arguments to update one WorkflowPause.
     * @example
     * // Update one WorkflowPause
     * const workflowPause = await prisma.workflowPause.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowPauseUpdateArgs>(args: SelectSubset<T, WorkflowPauseUpdateArgs<ExtArgs>>): Prisma__WorkflowPauseClient<$Result.GetResult<Prisma.$WorkflowPausePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowPauses.
     * @param {WorkflowPauseDeleteManyArgs} args - Arguments to filter WorkflowPauses to delete.
     * @example
     * // Delete a few WorkflowPauses
     * const { count } = await prisma.workflowPause.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowPauseDeleteManyArgs>(args?: SelectSubset<T, WorkflowPauseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowPauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowPauseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowPauses
     * const workflowPause = await prisma.workflowPause.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowPauseUpdateManyArgs>(args: SelectSubset<T, WorkflowPauseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowPause.
     * @param {WorkflowPauseUpsertArgs} args - Arguments to update or create a WorkflowPause.
     * @example
     * // Update or create a WorkflowPause
     * const workflowPause = await prisma.workflowPause.upsert({
     *   create: {
     *     // ... data to create a WorkflowPause
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowPause we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowPauseUpsertArgs>(args: SelectSubset<T, WorkflowPauseUpsertArgs<ExtArgs>>): Prisma__WorkflowPauseClient<$Result.GetResult<Prisma.$WorkflowPausePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowPauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowPauseCountArgs} args - Arguments to filter WorkflowPauses to count.
     * @example
     * // Count the number of WorkflowPauses
     * const count = await prisma.workflowPause.count({
     *   where: {
     *     // ... the filter for the WorkflowPauses we want to count
     *   }
     * })
    **/
    count<T extends WorkflowPauseCountArgs>(
      args?: Subset<T, WorkflowPauseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowPauseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowPause.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowPauseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowPauseAggregateArgs>(args: Subset<T, WorkflowPauseAggregateArgs>): Prisma.PrismaPromise<GetWorkflowPauseAggregateType<T>>

    /**
     * Group by WorkflowPause.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowPauseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowPauseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowPauseGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowPauseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowPauseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowPauseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowPause model
   */
  readonly fields: WorkflowPauseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowPause.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowPauseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflow<T extends WorkflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefaultArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    execution<T extends WorkflowExecutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowExecutionDefaultArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowPause model
   */ 
  interface WorkflowPauseFieldRefs {
    readonly id: FieldRef<"WorkflowPause", 'String'>
    readonly workflowId: FieldRef<"WorkflowPause", 'String'>
    readonly executionId: FieldRef<"WorkflowPause", 'String'>
    readonly nodeId: FieldRef<"WorkflowPause", 'String'>
    readonly reason: FieldRef<"WorkflowPause", 'String'>
    readonly resumeData: FieldRef<"WorkflowPause", 'Json'>
    readonly createdAt: FieldRef<"WorkflowPause", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkflowPause", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowPause findUnique
   */
  export type WorkflowPauseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowPause
     */
    select?: WorkflowPauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowPauseInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowPause to fetch.
     */
    where: WorkflowPauseWhereUniqueInput
  }

  /**
   * WorkflowPause findUniqueOrThrow
   */
  export type WorkflowPauseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowPause
     */
    select?: WorkflowPauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowPauseInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowPause to fetch.
     */
    where: WorkflowPauseWhereUniqueInput
  }

  /**
   * WorkflowPause findFirst
   */
  export type WorkflowPauseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowPause
     */
    select?: WorkflowPauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowPauseInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowPause to fetch.
     */
    where?: WorkflowPauseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowPauses to fetch.
     */
    orderBy?: WorkflowPauseOrderByWithRelationInput | WorkflowPauseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowPauses.
     */
    cursor?: WorkflowPauseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowPauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowPauses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowPauses.
     */
    distinct?: WorkflowPauseScalarFieldEnum | WorkflowPauseScalarFieldEnum[]
  }

  /**
   * WorkflowPause findFirstOrThrow
   */
  export type WorkflowPauseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowPause
     */
    select?: WorkflowPauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowPauseInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowPause to fetch.
     */
    where?: WorkflowPauseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowPauses to fetch.
     */
    orderBy?: WorkflowPauseOrderByWithRelationInput | WorkflowPauseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowPauses.
     */
    cursor?: WorkflowPauseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowPauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowPauses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowPauses.
     */
    distinct?: WorkflowPauseScalarFieldEnum | WorkflowPauseScalarFieldEnum[]
  }

  /**
   * WorkflowPause findMany
   */
  export type WorkflowPauseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowPause
     */
    select?: WorkflowPauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowPauseInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowPauses to fetch.
     */
    where?: WorkflowPauseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowPauses to fetch.
     */
    orderBy?: WorkflowPauseOrderByWithRelationInput | WorkflowPauseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowPauses.
     */
    cursor?: WorkflowPauseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowPauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowPauses.
     */
    skip?: number
    distinct?: WorkflowPauseScalarFieldEnum | WorkflowPauseScalarFieldEnum[]
  }

  /**
   * WorkflowPause create
   */
  export type WorkflowPauseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowPause
     */
    select?: WorkflowPauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowPauseInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowPause.
     */
    data: XOR<WorkflowPauseCreateInput, WorkflowPauseUncheckedCreateInput>
  }

  /**
   * WorkflowPause createMany
   */
  export type WorkflowPauseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowPauses.
     */
    data: WorkflowPauseCreateManyInput | WorkflowPauseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowPause createManyAndReturn
   */
  export type WorkflowPauseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowPause
     */
    select?: WorkflowPauseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkflowPauses.
     */
    data: WorkflowPauseCreateManyInput | WorkflowPauseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowPauseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowPause update
   */
  export type WorkflowPauseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowPause
     */
    select?: WorkflowPauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowPauseInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowPause.
     */
    data: XOR<WorkflowPauseUpdateInput, WorkflowPauseUncheckedUpdateInput>
    /**
     * Choose, which WorkflowPause to update.
     */
    where: WorkflowPauseWhereUniqueInput
  }

  /**
   * WorkflowPause updateMany
   */
  export type WorkflowPauseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowPauses.
     */
    data: XOR<WorkflowPauseUpdateManyMutationInput, WorkflowPauseUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowPauses to update
     */
    where?: WorkflowPauseWhereInput
  }

  /**
   * WorkflowPause upsert
   */
  export type WorkflowPauseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowPause
     */
    select?: WorkflowPauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowPauseInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowPause to update in case it exists.
     */
    where: WorkflowPauseWhereUniqueInput
    /**
     * In case the WorkflowPause found by the `where` argument doesn't exist, create a new WorkflowPause with this data.
     */
    create: XOR<WorkflowPauseCreateInput, WorkflowPauseUncheckedCreateInput>
    /**
     * In case the WorkflowPause was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowPauseUpdateInput, WorkflowPauseUncheckedUpdateInput>
  }

  /**
   * WorkflowPause delete
   */
  export type WorkflowPauseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowPause
     */
    select?: WorkflowPauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowPauseInclude<ExtArgs> | null
    /**
     * Filter which WorkflowPause to delete.
     */
    where: WorkflowPauseWhereUniqueInput
  }

  /**
   * WorkflowPause deleteMany
   */
  export type WorkflowPauseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowPauses to delete
     */
    where?: WorkflowPauseWhereInput
  }

  /**
   * WorkflowPause without action
   */
  export type WorkflowPauseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowPause
     */
    select?: WorkflowPauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowPauseInclude<ExtArgs> | null
  }


  /**
   * Model BlockchainTransaction
   */

  export type AggregateBlockchainTransaction = {
    _count: BlockchainTransactionCountAggregateOutputType | null
    _avg: BlockchainTransactionAvgAggregateOutputType | null
    _sum: BlockchainTransactionSumAggregateOutputType | null
    _min: BlockchainTransactionMinAggregateOutputType | null
    _max: BlockchainTransactionMaxAggregateOutputType | null
  }

  export type BlockchainTransactionAvgAggregateOutputType = {
    chainId: number | null
    nonce: number | null
    blockNumber: number | null
  }

  export type BlockchainTransactionSumAggregateOutputType = {
    chainId: number | null
    nonce: number | null
    blockNumber: number | null
  }

  export type BlockchainTransactionMinAggregateOutputType = {
    id: string | null
    nodeId: string | null
    executionId: string | null
    toAddress: string | null
    value: string | null
    chainId: number | null
    gasLimit: string | null
    gasUsed: string | null
    maxFeePerGas: string | null
    maxPriorityFeePerGas: string | null
    nonce: number | null
    status: string | null
    hash: string | null
    txHash: string | null
    blockNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    walletAddress: string | null
    effectiveGasPrice: string | null
    error: string | null
    fromAddress: string | null
  }

  export type BlockchainTransactionMaxAggregateOutputType = {
    id: string | null
    nodeId: string | null
    executionId: string | null
    toAddress: string | null
    value: string | null
    chainId: number | null
    gasLimit: string | null
    gasUsed: string | null
    maxFeePerGas: string | null
    maxPriorityFeePerGas: string | null
    nonce: number | null
    status: string | null
    hash: string | null
    txHash: string | null
    blockNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    walletAddress: string | null
    effectiveGasPrice: string | null
    error: string | null
    fromAddress: string | null
  }

  export type BlockchainTransactionCountAggregateOutputType = {
    id: number
    nodeId: number
    executionId: number
    toAddress: number
    value: number
    data: number
    chainId: number
    gasLimit: number
    gasUsed: number
    maxFeePerGas: number
    maxPriorityFeePerGas: number
    nonce: number
    status: number
    hash: number
    txHash: number
    blockNumber: number
    createdAt: number
    updatedAt: number
    userId: number
    walletAddress: number
    effectiveGasPrice: number
    error: number
    fromAddress: number
    _all: number
  }


  export type BlockchainTransactionAvgAggregateInputType = {
    chainId?: true
    nonce?: true
    blockNumber?: true
  }

  export type BlockchainTransactionSumAggregateInputType = {
    chainId?: true
    nonce?: true
    blockNumber?: true
  }

  export type BlockchainTransactionMinAggregateInputType = {
    id?: true
    nodeId?: true
    executionId?: true
    toAddress?: true
    value?: true
    chainId?: true
    gasLimit?: true
    gasUsed?: true
    maxFeePerGas?: true
    maxPriorityFeePerGas?: true
    nonce?: true
    status?: true
    hash?: true
    txHash?: true
    blockNumber?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    walletAddress?: true
    effectiveGasPrice?: true
    error?: true
    fromAddress?: true
  }

  export type BlockchainTransactionMaxAggregateInputType = {
    id?: true
    nodeId?: true
    executionId?: true
    toAddress?: true
    value?: true
    chainId?: true
    gasLimit?: true
    gasUsed?: true
    maxFeePerGas?: true
    maxPriorityFeePerGas?: true
    nonce?: true
    status?: true
    hash?: true
    txHash?: true
    blockNumber?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    walletAddress?: true
    effectiveGasPrice?: true
    error?: true
    fromAddress?: true
  }

  export type BlockchainTransactionCountAggregateInputType = {
    id?: true
    nodeId?: true
    executionId?: true
    toAddress?: true
    value?: true
    data?: true
    chainId?: true
    gasLimit?: true
    gasUsed?: true
    maxFeePerGas?: true
    maxPriorityFeePerGas?: true
    nonce?: true
    status?: true
    hash?: true
    txHash?: true
    blockNumber?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    walletAddress?: true
    effectiveGasPrice?: true
    error?: true
    fromAddress?: true
    _all?: true
  }

  export type BlockchainTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockchainTransaction to aggregate.
     */
    where?: BlockchainTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainTransactions to fetch.
     */
    orderBy?: BlockchainTransactionOrderByWithRelationInput | BlockchainTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockchainTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockchainTransactions
    **/
    _count?: true | BlockchainTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockchainTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockchainTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockchainTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockchainTransactionMaxAggregateInputType
  }

  export type GetBlockchainTransactionAggregateType<T extends BlockchainTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockchainTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockchainTransaction[P]>
      : GetScalarType<T[P], AggregateBlockchainTransaction[P]>
  }




  export type BlockchainTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockchainTransactionWhereInput
    orderBy?: BlockchainTransactionOrderByWithAggregationInput | BlockchainTransactionOrderByWithAggregationInput[]
    by: BlockchainTransactionScalarFieldEnum[] | BlockchainTransactionScalarFieldEnum
    having?: BlockchainTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockchainTransactionCountAggregateInputType | true
    _avg?: BlockchainTransactionAvgAggregateInputType
    _sum?: BlockchainTransactionSumAggregateInputType
    _min?: BlockchainTransactionMinAggregateInputType
    _max?: BlockchainTransactionMaxAggregateInputType
  }

  export type BlockchainTransactionGroupByOutputType = {
    id: string
    nodeId: string
    executionId: string
    toAddress: string
    value: string
    data: JsonValue | null
    chainId: number
    gasLimit: string | null
    gasUsed: string | null
    maxFeePerGas: string | null
    maxPriorityFeePerGas: string | null
    nonce: number | null
    status: string
    hash: string | null
    txHash: string | null
    blockNumber: number | null
    createdAt: Date
    updatedAt: Date
    userId: string | null
    walletAddress: string
    effectiveGasPrice: string | null
    error: string | null
    fromAddress: string | null
    _count: BlockchainTransactionCountAggregateOutputType | null
    _avg: BlockchainTransactionAvgAggregateOutputType | null
    _sum: BlockchainTransactionSumAggregateOutputType | null
    _min: BlockchainTransactionMinAggregateOutputType | null
    _max: BlockchainTransactionMaxAggregateOutputType | null
  }

  type GetBlockchainTransactionGroupByPayload<T extends BlockchainTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockchainTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockchainTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockchainTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], BlockchainTransactionGroupByOutputType[P]>
        }
      >
    >


  export type BlockchainTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeId?: boolean
    executionId?: boolean
    toAddress?: boolean
    value?: boolean
    data?: boolean
    chainId?: boolean
    gasLimit?: boolean
    gasUsed?: boolean
    maxFeePerGas?: boolean
    maxPriorityFeePerGas?: boolean
    nonce?: boolean
    status?: boolean
    hash?: boolean
    txHash?: boolean
    blockNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    walletAddress?: boolean
    effectiveGasPrice?: boolean
    error?: boolean
    fromAddress?: boolean
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
    transactionAttempts?: boolean | BlockchainTransaction$transactionAttemptsArgs<ExtArgs>
    _count?: boolean | BlockchainTransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockchainTransaction"]>

  export type BlockchainTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeId?: boolean
    executionId?: boolean
    toAddress?: boolean
    value?: boolean
    data?: boolean
    chainId?: boolean
    gasLimit?: boolean
    gasUsed?: boolean
    maxFeePerGas?: boolean
    maxPriorityFeePerGas?: boolean
    nonce?: boolean
    status?: boolean
    hash?: boolean
    txHash?: boolean
    blockNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    walletAddress?: boolean
    effectiveGasPrice?: boolean
    error?: boolean
    fromAddress?: boolean
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockchainTransaction"]>

  export type BlockchainTransactionSelectScalar = {
    id?: boolean
    nodeId?: boolean
    executionId?: boolean
    toAddress?: boolean
    value?: boolean
    data?: boolean
    chainId?: boolean
    gasLimit?: boolean
    gasUsed?: boolean
    maxFeePerGas?: boolean
    maxPriorityFeePerGas?: boolean
    nonce?: boolean
    status?: boolean
    hash?: boolean
    txHash?: boolean
    blockNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    walletAddress?: boolean
    effectiveGasPrice?: boolean
    error?: boolean
    fromAddress?: boolean
  }

  export type BlockchainTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
    transactionAttempts?: boolean | BlockchainTransaction$transactionAttemptsArgs<ExtArgs>
    _count?: boolean | BlockchainTransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlockchainTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }

  export type $BlockchainTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockchainTransaction"
    objects: {
      execution: Prisma.$WorkflowExecutionPayload<ExtArgs>
      transactionAttempts: Prisma.$TransactionAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nodeId: string
      executionId: string
      toAddress: string
      value: string
      data: Prisma.JsonValue | null
      chainId: number
      gasLimit: string | null
      gasUsed: string | null
      maxFeePerGas: string | null
      maxPriorityFeePerGas: string | null
      nonce: number | null
      status: string
      hash: string | null
      txHash: string | null
      blockNumber: number | null
      createdAt: Date
      updatedAt: Date
      userId: string | null
      walletAddress: string
      effectiveGasPrice: string | null
      error: string | null
      fromAddress: string | null
    }, ExtArgs["result"]["blockchainTransaction"]>
    composites: {}
  }

  type BlockchainTransactionGetPayload<S extends boolean | null | undefined | BlockchainTransactionDefaultArgs> = $Result.GetResult<Prisma.$BlockchainTransactionPayload, S>

  type BlockchainTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlockchainTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlockchainTransactionCountAggregateInputType | true
    }

  export interface BlockchainTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockchainTransaction'], meta: { name: 'BlockchainTransaction' } }
    /**
     * Find zero or one BlockchainTransaction that matches the filter.
     * @param {BlockchainTransactionFindUniqueArgs} args - Arguments to find a BlockchainTransaction
     * @example
     * // Get one BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockchainTransactionFindUniqueArgs>(args: SelectSubset<T, BlockchainTransactionFindUniqueArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlockchainTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlockchainTransactionFindUniqueOrThrowArgs} args - Arguments to find a BlockchainTransaction
     * @example
     * // Get one BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockchainTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockchainTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlockchainTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionFindFirstArgs} args - Arguments to find a BlockchainTransaction
     * @example
     * // Get one BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockchainTransactionFindFirstArgs>(args?: SelectSubset<T, BlockchainTransactionFindFirstArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlockchainTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionFindFirstOrThrowArgs} args - Arguments to find a BlockchainTransaction
     * @example
     * // Get one BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockchainTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockchainTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlockchainTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockchainTransactions
     * const blockchainTransactions = await prisma.blockchainTransaction.findMany()
     * 
     * // Get first 10 BlockchainTransactions
     * const blockchainTransactions = await prisma.blockchainTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockchainTransactionWithIdOnly = await prisma.blockchainTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockchainTransactionFindManyArgs>(args?: SelectSubset<T, BlockchainTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlockchainTransaction.
     * @param {BlockchainTransactionCreateArgs} args - Arguments to create a BlockchainTransaction.
     * @example
     * // Create one BlockchainTransaction
     * const BlockchainTransaction = await prisma.blockchainTransaction.create({
     *   data: {
     *     // ... data to create a BlockchainTransaction
     *   }
     * })
     * 
     */
    create<T extends BlockchainTransactionCreateArgs>(args: SelectSubset<T, BlockchainTransactionCreateArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlockchainTransactions.
     * @param {BlockchainTransactionCreateManyArgs} args - Arguments to create many BlockchainTransactions.
     * @example
     * // Create many BlockchainTransactions
     * const blockchainTransaction = await prisma.blockchainTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockchainTransactionCreateManyArgs>(args?: SelectSubset<T, BlockchainTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockchainTransactions and returns the data saved in the database.
     * @param {BlockchainTransactionCreateManyAndReturnArgs} args - Arguments to create many BlockchainTransactions.
     * @example
     * // Create many BlockchainTransactions
     * const blockchainTransaction = await prisma.blockchainTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockchainTransactions and only return the `id`
     * const blockchainTransactionWithIdOnly = await prisma.blockchainTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockchainTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockchainTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlockchainTransaction.
     * @param {BlockchainTransactionDeleteArgs} args - Arguments to delete one BlockchainTransaction.
     * @example
     * // Delete one BlockchainTransaction
     * const BlockchainTransaction = await prisma.blockchainTransaction.delete({
     *   where: {
     *     // ... filter to delete one BlockchainTransaction
     *   }
     * })
     * 
     */
    delete<T extends BlockchainTransactionDeleteArgs>(args: SelectSubset<T, BlockchainTransactionDeleteArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlockchainTransaction.
     * @param {BlockchainTransactionUpdateArgs} args - Arguments to update one BlockchainTransaction.
     * @example
     * // Update one BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockchainTransactionUpdateArgs>(args: SelectSubset<T, BlockchainTransactionUpdateArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlockchainTransactions.
     * @param {BlockchainTransactionDeleteManyArgs} args - Arguments to filter BlockchainTransactions to delete.
     * @example
     * // Delete a few BlockchainTransactions
     * const { count } = await prisma.blockchainTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockchainTransactionDeleteManyArgs>(args?: SelectSubset<T, BlockchainTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockchainTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockchainTransactions
     * const blockchainTransaction = await prisma.blockchainTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockchainTransactionUpdateManyArgs>(args: SelectSubset<T, BlockchainTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlockchainTransaction.
     * @param {BlockchainTransactionUpsertArgs} args - Arguments to update or create a BlockchainTransaction.
     * @example
     * // Update or create a BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.upsert({
     *   create: {
     *     // ... data to create a BlockchainTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockchainTransaction we want to update
     *   }
     * })
     */
    upsert<T extends BlockchainTransactionUpsertArgs>(args: SelectSubset<T, BlockchainTransactionUpsertArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlockchainTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionCountArgs} args - Arguments to filter BlockchainTransactions to count.
     * @example
     * // Count the number of BlockchainTransactions
     * const count = await prisma.blockchainTransaction.count({
     *   where: {
     *     // ... the filter for the BlockchainTransactions we want to count
     *   }
     * })
    **/
    count<T extends BlockchainTransactionCountArgs>(
      args?: Subset<T, BlockchainTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockchainTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockchainTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockchainTransactionAggregateArgs>(args: Subset<T, BlockchainTransactionAggregateArgs>): Prisma.PrismaPromise<GetBlockchainTransactionAggregateType<T>>

    /**
     * Group by BlockchainTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockchainTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockchainTransactionGroupByArgs['orderBy'] }
        : { orderBy?: BlockchainTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockchainTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockchainTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockchainTransaction model
   */
  readonly fields: BlockchainTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockchainTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockchainTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    execution<T extends WorkflowExecutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowExecutionDefaultArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactionAttempts<T extends BlockchainTransaction$transactionAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, BlockchainTransaction$transactionAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockchainTransaction model
   */ 
  interface BlockchainTransactionFieldRefs {
    readonly id: FieldRef<"BlockchainTransaction", 'String'>
    readonly nodeId: FieldRef<"BlockchainTransaction", 'String'>
    readonly executionId: FieldRef<"BlockchainTransaction", 'String'>
    readonly toAddress: FieldRef<"BlockchainTransaction", 'String'>
    readonly value: FieldRef<"BlockchainTransaction", 'String'>
    readonly data: FieldRef<"BlockchainTransaction", 'Json'>
    readonly chainId: FieldRef<"BlockchainTransaction", 'Int'>
    readonly gasLimit: FieldRef<"BlockchainTransaction", 'String'>
    readonly gasUsed: FieldRef<"BlockchainTransaction", 'String'>
    readonly maxFeePerGas: FieldRef<"BlockchainTransaction", 'String'>
    readonly maxPriorityFeePerGas: FieldRef<"BlockchainTransaction", 'String'>
    readonly nonce: FieldRef<"BlockchainTransaction", 'Int'>
    readonly status: FieldRef<"BlockchainTransaction", 'String'>
    readonly hash: FieldRef<"BlockchainTransaction", 'String'>
    readonly txHash: FieldRef<"BlockchainTransaction", 'String'>
    readonly blockNumber: FieldRef<"BlockchainTransaction", 'Int'>
    readonly createdAt: FieldRef<"BlockchainTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"BlockchainTransaction", 'DateTime'>
    readonly userId: FieldRef<"BlockchainTransaction", 'String'>
    readonly walletAddress: FieldRef<"BlockchainTransaction", 'String'>
    readonly effectiveGasPrice: FieldRef<"BlockchainTransaction", 'String'>
    readonly error: FieldRef<"BlockchainTransaction", 'String'>
    readonly fromAddress: FieldRef<"BlockchainTransaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BlockchainTransaction findUnique
   */
  export type BlockchainTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainTransaction to fetch.
     */
    where: BlockchainTransactionWhereUniqueInput
  }

  /**
   * BlockchainTransaction findUniqueOrThrow
   */
  export type BlockchainTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainTransaction to fetch.
     */
    where: BlockchainTransactionWhereUniqueInput
  }

  /**
   * BlockchainTransaction findFirst
   */
  export type BlockchainTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainTransaction to fetch.
     */
    where?: BlockchainTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainTransactions to fetch.
     */
    orderBy?: BlockchainTransactionOrderByWithRelationInput | BlockchainTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockchainTransactions.
     */
    cursor?: BlockchainTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockchainTransactions.
     */
    distinct?: BlockchainTransactionScalarFieldEnum | BlockchainTransactionScalarFieldEnum[]
  }

  /**
   * BlockchainTransaction findFirstOrThrow
   */
  export type BlockchainTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainTransaction to fetch.
     */
    where?: BlockchainTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainTransactions to fetch.
     */
    orderBy?: BlockchainTransactionOrderByWithRelationInput | BlockchainTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockchainTransactions.
     */
    cursor?: BlockchainTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockchainTransactions.
     */
    distinct?: BlockchainTransactionScalarFieldEnum | BlockchainTransactionScalarFieldEnum[]
  }

  /**
   * BlockchainTransaction findMany
   */
  export type BlockchainTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainTransactions to fetch.
     */
    where?: BlockchainTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainTransactions to fetch.
     */
    orderBy?: BlockchainTransactionOrderByWithRelationInput | BlockchainTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockchainTransactions.
     */
    cursor?: BlockchainTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainTransactions.
     */
    skip?: number
    distinct?: BlockchainTransactionScalarFieldEnum | BlockchainTransactionScalarFieldEnum[]
  }

  /**
   * BlockchainTransaction create
   */
  export type BlockchainTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockchainTransaction.
     */
    data: XOR<BlockchainTransactionCreateInput, BlockchainTransactionUncheckedCreateInput>
  }

  /**
   * BlockchainTransaction createMany
   */
  export type BlockchainTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockchainTransactions.
     */
    data: BlockchainTransactionCreateManyInput | BlockchainTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockchainTransaction createManyAndReturn
   */
  export type BlockchainTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlockchainTransactions.
     */
    data: BlockchainTransactionCreateManyInput | BlockchainTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockchainTransaction update
   */
  export type BlockchainTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockchainTransaction.
     */
    data: XOR<BlockchainTransactionUpdateInput, BlockchainTransactionUncheckedUpdateInput>
    /**
     * Choose, which BlockchainTransaction to update.
     */
    where: BlockchainTransactionWhereUniqueInput
  }

  /**
   * BlockchainTransaction updateMany
   */
  export type BlockchainTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockchainTransactions.
     */
    data: XOR<BlockchainTransactionUpdateManyMutationInput, BlockchainTransactionUncheckedUpdateManyInput>
    /**
     * Filter which BlockchainTransactions to update
     */
    where?: BlockchainTransactionWhereInput
  }

  /**
   * BlockchainTransaction upsert
   */
  export type BlockchainTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockchainTransaction to update in case it exists.
     */
    where: BlockchainTransactionWhereUniqueInput
    /**
     * In case the BlockchainTransaction found by the `where` argument doesn't exist, create a new BlockchainTransaction with this data.
     */
    create: XOR<BlockchainTransactionCreateInput, BlockchainTransactionUncheckedCreateInput>
    /**
     * In case the BlockchainTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockchainTransactionUpdateInput, BlockchainTransactionUncheckedUpdateInput>
  }

  /**
   * BlockchainTransaction delete
   */
  export type BlockchainTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter which BlockchainTransaction to delete.
     */
    where: BlockchainTransactionWhereUniqueInput
  }

  /**
   * BlockchainTransaction deleteMany
   */
  export type BlockchainTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockchainTransactions to delete
     */
    where?: BlockchainTransactionWhereInput
  }

  /**
   * BlockchainTransaction.transactionAttempts
   */
  export type BlockchainTransaction$transactionAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAttempt
     */
    select?: TransactionAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAttemptInclude<ExtArgs> | null
    where?: TransactionAttemptWhereInput
    orderBy?: TransactionAttemptOrderByWithRelationInput | TransactionAttemptOrderByWithRelationInput[]
    cursor?: TransactionAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionAttemptScalarFieldEnum | TransactionAttemptScalarFieldEnum[]
  }

  /**
   * BlockchainTransaction without action
   */
  export type BlockchainTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
  }


  /**
   * Model TransactionAttempt
   */

  export type AggregateTransactionAttempt = {
    _count: TransactionAttemptCountAggregateOutputType | null
    _avg: TransactionAttemptAvgAggregateOutputType | null
    _sum: TransactionAttemptSumAggregateOutputType | null
    _min: TransactionAttemptMinAggregateOutputType | null
    _max: TransactionAttemptMaxAggregateOutputType | null
  }

  export type TransactionAttemptAvgAggregateOutputType = {
    blockNumber: number | null
  }

  export type TransactionAttemptSumAggregateOutputType = {
    blockNumber: number | null
  }

  export type TransactionAttemptMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    txHash: string | null
    status: string | null
    error: string | null
    blockNumber: number | null
    gasUsed: string | null
    effectiveGasPrice: string | null
    createdAt: Date | null
  }

  export type TransactionAttemptMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    txHash: string | null
    status: string | null
    error: string | null
    blockNumber: number | null
    gasUsed: string | null
    effectiveGasPrice: string | null
    createdAt: Date | null
  }

  export type TransactionAttemptCountAggregateOutputType = {
    id: number
    transactionId: number
    txHash: number
    status: number
    error: number
    blockNumber: number
    gasUsed: number
    effectiveGasPrice: number
    createdAt: number
    _all: number
  }


  export type TransactionAttemptAvgAggregateInputType = {
    blockNumber?: true
  }

  export type TransactionAttemptSumAggregateInputType = {
    blockNumber?: true
  }

  export type TransactionAttemptMinAggregateInputType = {
    id?: true
    transactionId?: true
    txHash?: true
    status?: true
    error?: true
    blockNumber?: true
    gasUsed?: true
    effectiveGasPrice?: true
    createdAt?: true
  }

  export type TransactionAttemptMaxAggregateInputType = {
    id?: true
    transactionId?: true
    txHash?: true
    status?: true
    error?: true
    blockNumber?: true
    gasUsed?: true
    effectiveGasPrice?: true
    createdAt?: true
  }

  export type TransactionAttemptCountAggregateInputType = {
    id?: true
    transactionId?: true
    txHash?: true
    status?: true
    error?: true
    blockNumber?: true
    gasUsed?: true
    effectiveGasPrice?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionAttempt to aggregate.
     */
    where?: TransactionAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionAttempts to fetch.
     */
    orderBy?: TransactionAttemptOrderByWithRelationInput | TransactionAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionAttempts
    **/
    _count?: true | TransactionAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionAttemptMaxAggregateInputType
  }

  export type GetTransactionAttemptAggregateType<T extends TransactionAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionAttempt[P]>
      : GetScalarType<T[P], AggregateTransactionAttempt[P]>
  }




  export type TransactionAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionAttemptWhereInput
    orderBy?: TransactionAttemptOrderByWithAggregationInput | TransactionAttemptOrderByWithAggregationInput[]
    by: TransactionAttemptScalarFieldEnum[] | TransactionAttemptScalarFieldEnum
    having?: TransactionAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionAttemptCountAggregateInputType | true
    _avg?: TransactionAttemptAvgAggregateInputType
    _sum?: TransactionAttemptSumAggregateInputType
    _min?: TransactionAttemptMinAggregateInputType
    _max?: TransactionAttemptMaxAggregateInputType
  }

  export type TransactionAttemptGroupByOutputType = {
    id: string
    transactionId: string
    txHash: string | null
    status: string
    error: string | null
    blockNumber: number | null
    gasUsed: string | null
    effectiveGasPrice: string | null
    createdAt: Date
    _count: TransactionAttemptCountAggregateOutputType | null
    _avg: TransactionAttemptAvgAggregateOutputType | null
    _sum: TransactionAttemptSumAggregateOutputType | null
    _min: TransactionAttemptMinAggregateOutputType | null
    _max: TransactionAttemptMaxAggregateOutputType | null
  }

  type GetTransactionAttemptGroupByPayload<T extends TransactionAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionAttemptGroupByOutputType[P]>
        }
      >
    >


  export type TransactionAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    txHash?: boolean
    status?: boolean
    error?: boolean
    blockNumber?: boolean
    gasUsed?: boolean
    effectiveGasPrice?: boolean
    createdAt?: boolean
    transaction?: boolean | BlockchainTransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionAttempt"]>

  export type TransactionAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    txHash?: boolean
    status?: boolean
    error?: boolean
    blockNumber?: boolean
    gasUsed?: boolean
    effectiveGasPrice?: boolean
    createdAt?: boolean
    transaction?: boolean | BlockchainTransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionAttempt"]>

  export type TransactionAttemptSelectScalar = {
    id?: boolean
    transactionId?: boolean
    txHash?: boolean
    status?: boolean
    error?: boolean
    blockNumber?: boolean
    gasUsed?: boolean
    effectiveGasPrice?: boolean
    createdAt?: boolean
  }

  export type TransactionAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | BlockchainTransactionDefaultArgs<ExtArgs>
  }
  export type TransactionAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | BlockchainTransactionDefaultArgs<ExtArgs>
  }

  export type $TransactionAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionAttempt"
    objects: {
      transaction: Prisma.$BlockchainTransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      txHash: string | null
      status: string
      error: string | null
      blockNumber: number | null
      gasUsed: string | null
      effectiveGasPrice: string | null
      createdAt: Date
    }, ExtArgs["result"]["transactionAttempt"]>
    composites: {}
  }

  type TransactionAttemptGetPayload<S extends boolean | null | undefined | TransactionAttemptDefaultArgs> = $Result.GetResult<Prisma.$TransactionAttemptPayload, S>

  type TransactionAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionAttemptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionAttemptCountAggregateInputType | true
    }

  export interface TransactionAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionAttempt'], meta: { name: 'TransactionAttempt' } }
    /**
     * Find zero or one TransactionAttempt that matches the filter.
     * @param {TransactionAttemptFindUniqueArgs} args - Arguments to find a TransactionAttempt
     * @example
     * // Get one TransactionAttempt
     * const transactionAttempt = await prisma.transactionAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionAttemptFindUniqueArgs>(args: SelectSubset<T, TransactionAttemptFindUniqueArgs<ExtArgs>>): Prisma__TransactionAttemptClient<$Result.GetResult<Prisma.$TransactionAttemptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TransactionAttempt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionAttemptFindUniqueOrThrowArgs} args - Arguments to find a TransactionAttempt
     * @example
     * // Get one TransactionAttempt
     * const transactionAttempt = await prisma.transactionAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionAttemptClient<$Result.GetResult<Prisma.$TransactionAttemptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TransactionAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAttemptFindFirstArgs} args - Arguments to find a TransactionAttempt
     * @example
     * // Get one TransactionAttempt
     * const transactionAttempt = await prisma.transactionAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionAttemptFindFirstArgs>(args?: SelectSubset<T, TransactionAttemptFindFirstArgs<ExtArgs>>): Prisma__TransactionAttemptClient<$Result.GetResult<Prisma.$TransactionAttemptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TransactionAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAttemptFindFirstOrThrowArgs} args - Arguments to find a TransactionAttempt
     * @example
     * // Get one TransactionAttempt
     * const transactionAttempt = await prisma.transactionAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionAttemptClient<$Result.GetResult<Prisma.$TransactionAttemptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TransactionAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionAttempts
     * const transactionAttempts = await prisma.transactionAttempt.findMany()
     * 
     * // Get first 10 TransactionAttempts
     * const transactionAttempts = await prisma.transactionAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionAttemptWithIdOnly = await prisma.transactionAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionAttemptFindManyArgs>(args?: SelectSubset<T, TransactionAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionAttemptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TransactionAttempt.
     * @param {TransactionAttemptCreateArgs} args - Arguments to create a TransactionAttempt.
     * @example
     * // Create one TransactionAttempt
     * const TransactionAttempt = await prisma.transactionAttempt.create({
     *   data: {
     *     // ... data to create a TransactionAttempt
     *   }
     * })
     * 
     */
    create<T extends TransactionAttemptCreateArgs>(args: SelectSubset<T, TransactionAttemptCreateArgs<ExtArgs>>): Prisma__TransactionAttemptClient<$Result.GetResult<Prisma.$TransactionAttemptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TransactionAttempts.
     * @param {TransactionAttemptCreateManyArgs} args - Arguments to create many TransactionAttempts.
     * @example
     * // Create many TransactionAttempts
     * const transactionAttempt = await prisma.transactionAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionAttemptCreateManyArgs>(args?: SelectSubset<T, TransactionAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionAttempts and returns the data saved in the database.
     * @param {TransactionAttemptCreateManyAndReturnArgs} args - Arguments to create many TransactionAttempts.
     * @example
     * // Create many TransactionAttempts
     * const transactionAttempt = await prisma.transactionAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionAttempts and only return the `id`
     * const transactionAttemptWithIdOnly = await prisma.transactionAttempt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionAttemptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TransactionAttempt.
     * @param {TransactionAttemptDeleteArgs} args - Arguments to delete one TransactionAttempt.
     * @example
     * // Delete one TransactionAttempt
     * const TransactionAttempt = await prisma.transactionAttempt.delete({
     *   where: {
     *     // ... filter to delete one TransactionAttempt
     *   }
     * })
     * 
     */
    delete<T extends TransactionAttemptDeleteArgs>(args: SelectSubset<T, TransactionAttemptDeleteArgs<ExtArgs>>): Prisma__TransactionAttemptClient<$Result.GetResult<Prisma.$TransactionAttemptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TransactionAttempt.
     * @param {TransactionAttemptUpdateArgs} args - Arguments to update one TransactionAttempt.
     * @example
     * // Update one TransactionAttempt
     * const transactionAttempt = await prisma.transactionAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionAttemptUpdateArgs>(args: SelectSubset<T, TransactionAttemptUpdateArgs<ExtArgs>>): Prisma__TransactionAttemptClient<$Result.GetResult<Prisma.$TransactionAttemptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TransactionAttempts.
     * @param {TransactionAttemptDeleteManyArgs} args - Arguments to filter TransactionAttempts to delete.
     * @example
     * // Delete a few TransactionAttempts
     * const { count } = await prisma.transactionAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionAttemptDeleteManyArgs>(args?: SelectSubset<T, TransactionAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionAttempts
     * const transactionAttempt = await prisma.transactionAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionAttemptUpdateManyArgs>(args: SelectSubset<T, TransactionAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransactionAttempt.
     * @param {TransactionAttemptUpsertArgs} args - Arguments to update or create a TransactionAttempt.
     * @example
     * // Update or create a TransactionAttempt
     * const transactionAttempt = await prisma.transactionAttempt.upsert({
     *   create: {
     *     // ... data to create a TransactionAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionAttempt we want to update
     *   }
     * })
     */
    upsert<T extends TransactionAttemptUpsertArgs>(args: SelectSubset<T, TransactionAttemptUpsertArgs<ExtArgs>>): Prisma__TransactionAttemptClient<$Result.GetResult<Prisma.$TransactionAttemptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TransactionAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAttemptCountArgs} args - Arguments to filter TransactionAttempts to count.
     * @example
     * // Count the number of TransactionAttempts
     * const count = await prisma.transactionAttempt.count({
     *   where: {
     *     // ... the filter for the TransactionAttempts we want to count
     *   }
     * })
    **/
    count<T extends TransactionAttemptCountArgs>(
      args?: Subset<T, TransactionAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAttemptAggregateArgs>(args: Subset<T, TransactionAttemptAggregateArgs>): Prisma.PrismaPromise<GetTransactionAttemptAggregateType<T>>

    /**
     * Group by TransactionAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionAttemptGroupByArgs['orderBy'] }
        : { orderBy?: TransactionAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionAttempt model
   */
  readonly fields: TransactionAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends BlockchainTransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlockchainTransactionDefaultArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionAttempt model
   */ 
  interface TransactionAttemptFieldRefs {
    readonly id: FieldRef<"TransactionAttempt", 'String'>
    readonly transactionId: FieldRef<"TransactionAttempt", 'String'>
    readonly txHash: FieldRef<"TransactionAttempt", 'String'>
    readonly status: FieldRef<"TransactionAttempt", 'String'>
    readonly error: FieldRef<"TransactionAttempt", 'String'>
    readonly blockNumber: FieldRef<"TransactionAttempt", 'Int'>
    readonly gasUsed: FieldRef<"TransactionAttempt", 'String'>
    readonly effectiveGasPrice: FieldRef<"TransactionAttempt", 'String'>
    readonly createdAt: FieldRef<"TransactionAttempt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionAttempt findUnique
   */
  export type TransactionAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAttempt
     */
    select?: TransactionAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which TransactionAttempt to fetch.
     */
    where: TransactionAttemptWhereUniqueInput
  }

  /**
   * TransactionAttempt findUniqueOrThrow
   */
  export type TransactionAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAttempt
     */
    select?: TransactionAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which TransactionAttempt to fetch.
     */
    where: TransactionAttemptWhereUniqueInput
  }

  /**
   * TransactionAttempt findFirst
   */
  export type TransactionAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAttempt
     */
    select?: TransactionAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which TransactionAttempt to fetch.
     */
    where?: TransactionAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionAttempts to fetch.
     */
    orderBy?: TransactionAttemptOrderByWithRelationInput | TransactionAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionAttempts.
     */
    cursor?: TransactionAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionAttempts.
     */
    distinct?: TransactionAttemptScalarFieldEnum | TransactionAttemptScalarFieldEnum[]
  }

  /**
   * TransactionAttempt findFirstOrThrow
   */
  export type TransactionAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAttempt
     */
    select?: TransactionAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which TransactionAttempt to fetch.
     */
    where?: TransactionAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionAttempts to fetch.
     */
    orderBy?: TransactionAttemptOrderByWithRelationInput | TransactionAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionAttempts.
     */
    cursor?: TransactionAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionAttempts.
     */
    distinct?: TransactionAttemptScalarFieldEnum | TransactionAttemptScalarFieldEnum[]
  }

  /**
   * TransactionAttempt findMany
   */
  export type TransactionAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAttempt
     */
    select?: TransactionAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which TransactionAttempts to fetch.
     */
    where?: TransactionAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionAttempts to fetch.
     */
    orderBy?: TransactionAttemptOrderByWithRelationInput | TransactionAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionAttempts.
     */
    cursor?: TransactionAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionAttempts.
     */
    skip?: number
    distinct?: TransactionAttemptScalarFieldEnum | TransactionAttemptScalarFieldEnum[]
  }

  /**
   * TransactionAttempt create
   */
  export type TransactionAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAttempt
     */
    select?: TransactionAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionAttempt.
     */
    data: XOR<TransactionAttemptCreateInput, TransactionAttemptUncheckedCreateInput>
  }

  /**
   * TransactionAttempt createMany
   */
  export type TransactionAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionAttempts.
     */
    data: TransactionAttemptCreateManyInput | TransactionAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionAttempt createManyAndReturn
   */
  export type TransactionAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAttempt
     */
    select?: TransactionAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TransactionAttempts.
     */
    data: TransactionAttemptCreateManyInput | TransactionAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionAttempt update
   */
  export type TransactionAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAttempt
     */
    select?: TransactionAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionAttempt.
     */
    data: XOR<TransactionAttemptUpdateInput, TransactionAttemptUncheckedUpdateInput>
    /**
     * Choose, which TransactionAttempt to update.
     */
    where: TransactionAttemptWhereUniqueInput
  }

  /**
   * TransactionAttempt updateMany
   */
  export type TransactionAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionAttempts.
     */
    data: XOR<TransactionAttemptUpdateManyMutationInput, TransactionAttemptUncheckedUpdateManyInput>
    /**
     * Filter which TransactionAttempts to update
     */
    where?: TransactionAttemptWhereInput
  }

  /**
   * TransactionAttempt upsert
   */
  export type TransactionAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAttempt
     */
    select?: TransactionAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionAttempt to update in case it exists.
     */
    where: TransactionAttemptWhereUniqueInput
    /**
     * In case the TransactionAttempt found by the `where` argument doesn't exist, create a new TransactionAttempt with this data.
     */
    create: XOR<TransactionAttemptCreateInput, TransactionAttemptUncheckedCreateInput>
    /**
     * In case the TransactionAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionAttemptUpdateInput, TransactionAttemptUncheckedUpdateInput>
  }

  /**
   * TransactionAttempt delete
   */
  export type TransactionAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAttempt
     */
    select?: TransactionAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAttemptInclude<ExtArgs> | null
    /**
     * Filter which TransactionAttempt to delete.
     */
    where: TransactionAttemptWhereUniqueInput
  }

  /**
   * TransactionAttempt deleteMany
   */
  export type TransactionAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionAttempts to delete
     */
    where?: TransactionAttemptWhereInput
  }

  /**
   * TransactionAttempt without action
   */
  export type TransactionAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAttempt
     */
    select?: TransactionAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAttemptInclude<ExtArgs> | null
  }


  /**
   * Model AiBlockchainOperation
   */

  export type AggregateAiBlockchainOperation = {
    _count: AiBlockchainOperationCountAggregateOutputType | null
    _min: AiBlockchainOperationMinAggregateOutputType | null
    _max: AiBlockchainOperationMaxAggregateOutputType | null
  }

  export type AiBlockchainOperationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    executionId: string | null
    nodeId: string | null
    operationType: string | null
    blockchain: string | null
    prompt: string | null
    status: string | null
    error: string | null
    createdAt: Date | null
  }

  export type AiBlockchainOperationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    executionId: string | null
    nodeId: string | null
    operationType: string | null
    blockchain: string | null
    prompt: string | null
    status: string | null
    error: string | null
    createdAt: Date | null
  }

  export type AiBlockchainOperationCountAggregateOutputType = {
    id: number
    userId: number
    executionId: number
    nodeId: number
    operationType: number
    blockchain: number
    prompt: number
    result: number
    status: number
    error: number
    createdAt: number
    _all: number
  }


  export type AiBlockchainOperationMinAggregateInputType = {
    id?: true
    userId?: true
    executionId?: true
    nodeId?: true
    operationType?: true
    blockchain?: true
    prompt?: true
    status?: true
    error?: true
    createdAt?: true
  }

  export type AiBlockchainOperationMaxAggregateInputType = {
    id?: true
    userId?: true
    executionId?: true
    nodeId?: true
    operationType?: true
    blockchain?: true
    prompt?: true
    status?: true
    error?: true
    createdAt?: true
  }

  export type AiBlockchainOperationCountAggregateInputType = {
    id?: true
    userId?: true
    executionId?: true
    nodeId?: true
    operationType?: true
    blockchain?: true
    prompt?: true
    result?: true
    status?: true
    error?: true
    createdAt?: true
    _all?: true
  }

  export type AiBlockchainOperationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiBlockchainOperation to aggregate.
     */
    where?: AiBlockchainOperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiBlockchainOperations to fetch.
     */
    orderBy?: AiBlockchainOperationOrderByWithRelationInput | AiBlockchainOperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiBlockchainOperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiBlockchainOperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiBlockchainOperations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiBlockchainOperations
    **/
    _count?: true | AiBlockchainOperationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiBlockchainOperationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiBlockchainOperationMaxAggregateInputType
  }

  export type GetAiBlockchainOperationAggregateType<T extends AiBlockchainOperationAggregateArgs> = {
        [P in keyof T & keyof AggregateAiBlockchainOperation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiBlockchainOperation[P]>
      : GetScalarType<T[P], AggregateAiBlockchainOperation[P]>
  }




  export type AiBlockchainOperationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiBlockchainOperationWhereInput
    orderBy?: AiBlockchainOperationOrderByWithAggregationInput | AiBlockchainOperationOrderByWithAggregationInput[]
    by: AiBlockchainOperationScalarFieldEnum[] | AiBlockchainOperationScalarFieldEnum
    having?: AiBlockchainOperationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiBlockchainOperationCountAggregateInputType | true
    _min?: AiBlockchainOperationMinAggregateInputType
    _max?: AiBlockchainOperationMaxAggregateInputType
  }

  export type AiBlockchainOperationGroupByOutputType = {
    id: string
    userId: string
    executionId: string
    nodeId: string
    operationType: string
    blockchain: string | null
    prompt: string | null
    result: JsonValue | null
    status: string
    error: string | null
    createdAt: Date
    _count: AiBlockchainOperationCountAggregateOutputType | null
    _min: AiBlockchainOperationMinAggregateOutputType | null
    _max: AiBlockchainOperationMaxAggregateOutputType | null
  }

  type GetAiBlockchainOperationGroupByPayload<T extends AiBlockchainOperationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiBlockchainOperationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiBlockchainOperationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiBlockchainOperationGroupByOutputType[P]>
            : GetScalarType<T[P], AiBlockchainOperationGroupByOutputType[P]>
        }
      >
    >


  export type AiBlockchainOperationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    executionId?: boolean
    nodeId?: boolean
    operationType?: boolean
    blockchain?: boolean
    prompt?: boolean
    result?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aiBlockchainOperation"]>

  export type AiBlockchainOperationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    executionId?: boolean
    nodeId?: boolean
    operationType?: boolean
    blockchain?: boolean
    prompt?: boolean
    result?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aiBlockchainOperation"]>

  export type AiBlockchainOperationSelectScalar = {
    id?: boolean
    userId?: boolean
    executionId?: boolean
    nodeId?: boolean
    operationType?: boolean
    blockchain?: boolean
    prompt?: boolean
    result?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
  }


  export type $AiBlockchainOperationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiBlockchainOperation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      executionId: string
      nodeId: string
      operationType: string
      blockchain: string | null
      prompt: string | null
      result: Prisma.JsonValue | null
      status: string
      error: string | null
      createdAt: Date
    }, ExtArgs["result"]["aiBlockchainOperation"]>
    composites: {}
  }

  type AiBlockchainOperationGetPayload<S extends boolean | null | undefined | AiBlockchainOperationDefaultArgs> = $Result.GetResult<Prisma.$AiBlockchainOperationPayload, S>

  type AiBlockchainOperationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AiBlockchainOperationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AiBlockchainOperationCountAggregateInputType | true
    }

  export interface AiBlockchainOperationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiBlockchainOperation'], meta: { name: 'AiBlockchainOperation' } }
    /**
     * Find zero or one AiBlockchainOperation that matches the filter.
     * @param {AiBlockchainOperationFindUniqueArgs} args - Arguments to find a AiBlockchainOperation
     * @example
     * // Get one AiBlockchainOperation
     * const aiBlockchainOperation = await prisma.aiBlockchainOperation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiBlockchainOperationFindUniqueArgs>(args: SelectSubset<T, AiBlockchainOperationFindUniqueArgs<ExtArgs>>): Prisma__AiBlockchainOperationClient<$Result.GetResult<Prisma.$AiBlockchainOperationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AiBlockchainOperation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AiBlockchainOperationFindUniqueOrThrowArgs} args - Arguments to find a AiBlockchainOperation
     * @example
     * // Get one AiBlockchainOperation
     * const aiBlockchainOperation = await prisma.aiBlockchainOperation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiBlockchainOperationFindUniqueOrThrowArgs>(args: SelectSubset<T, AiBlockchainOperationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiBlockchainOperationClient<$Result.GetResult<Prisma.$AiBlockchainOperationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AiBlockchainOperation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiBlockchainOperationFindFirstArgs} args - Arguments to find a AiBlockchainOperation
     * @example
     * // Get one AiBlockchainOperation
     * const aiBlockchainOperation = await prisma.aiBlockchainOperation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiBlockchainOperationFindFirstArgs>(args?: SelectSubset<T, AiBlockchainOperationFindFirstArgs<ExtArgs>>): Prisma__AiBlockchainOperationClient<$Result.GetResult<Prisma.$AiBlockchainOperationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AiBlockchainOperation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiBlockchainOperationFindFirstOrThrowArgs} args - Arguments to find a AiBlockchainOperation
     * @example
     * // Get one AiBlockchainOperation
     * const aiBlockchainOperation = await prisma.aiBlockchainOperation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiBlockchainOperationFindFirstOrThrowArgs>(args?: SelectSubset<T, AiBlockchainOperationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiBlockchainOperationClient<$Result.GetResult<Prisma.$AiBlockchainOperationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AiBlockchainOperations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiBlockchainOperationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiBlockchainOperations
     * const aiBlockchainOperations = await prisma.aiBlockchainOperation.findMany()
     * 
     * // Get first 10 AiBlockchainOperations
     * const aiBlockchainOperations = await prisma.aiBlockchainOperation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiBlockchainOperationWithIdOnly = await prisma.aiBlockchainOperation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiBlockchainOperationFindManyArgs>(args?: SelectSubset<T, AiBlockchainOperationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiBlockchainOperationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AiBlockchainOperation.
     * @param {AiBlockchainOperationCreateArgs} args - Arguments to create a AiBlockchainOperation.
     * @example
     * // Create one AiBlockchainOperation
     * const AiBlockchainOperation = await prisma.aiBlockchainOperation.create({
     *   data: {
     *     // ... data to create a AiBlockchainOperation
     *   }
     * })
     * 
     */
    create<T extends AiBlockchainOperationCreateArgs>(args: SelectSubset<T, AiBlockchainOperationCreateArgs<ExtArgs>>): Prisma__AiBlockchainOperationClient<$Result.GetResult<Prisma.$AiBlockchainOperationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AiBlockchainOperations.
     * @param {AiBlockchainOperationCreateManyArgs} args - Arguments to create many AiBlockchainOperations.
     * @example
     * // Create many AiBlockchainOperations
     * const aiBlockchainOperation = await prisma.aiBlockchainOperation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiBlockchainOperationCreateManyArgs>(args?: SelectSubset<T, AiBlockchainOperationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiBlockchainOperations and returns the data saved in the database.
     * @param {AiBlockchainOperationCreateManyAndReturnArgs} args - Arguments to create many AiBlockchainOperations.
     * @example
     * // Create many AiBlockchainOperations
     * const aiBlockchainOperation = await prisma.aiBlockchainOperation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiBlockchainOperations and only return the `id`
     * const aiBlockchainOperationWithIdOnly = await prisma.aiBlockchainOperation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiBlockchainOperationCreateManyAndReturnArgs>(args?: SelectSubset<T, AiBlockchainOperationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiBlockchainOperationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AiBlockchainOperation.
     * @param {AiBlockchainOperationDeleteArgs} args - Arguments to delete one AiBlockchainOperation.
     * @example
     * // Delete one AiBlockchainOperation
     * const AiBlockchainOperation = await prisma.aiBlockchainOperation.delete({
     *   where: {
     *     // ... filter to delete one AiBlockchainOperation
     *   }
     * })
     * 
     */
    delete<T extends AiBlockchainOperationDeleteArgs>(args: SelectSubset<T, AiBlockchainOperationDeleteArgs<ExtArgs>>): Prisma__AiBlockchainOperationClient<$Result.GetResult<Prisma.$AiBlockchainOperationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AiBlockchainOperation.
     * @param {AiBlockchainOperationUpdateArgs} args - Arguments to update one AiBlockchainOperation.
     * @example
     * // Update one AiBlockchainOperation
     * const aiBlockchainOperation = await prisma.aiBlockchainOperation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiBlockchainOperationUpdateArgs>(args: SelectSubset<T, AiBlockchainOperationUpdateArgs<ExtArgs>>): Prisma__AiBlockchainOperationClient<$Result.GetResult<Prisma.$AiBlockchainOperationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AiBlockchainOperations.
     * @param {AiBlockchainOperationDeleteManyArgs} args - Arguments to filter AiBlockchainOperations to delete.
     * @example
     * // Delete a few AiBlockchainOperations
     * const { count } = await prisma.aiBlockchainOperation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiBlockchainOperationDeleteManyArgs>(args?: SelectSubset<T, AiBlockchainOperationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiBlockchainOperations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiBlockchainOperationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiBlockchainOperations
     * const aiBlockchainOperation = await prisma.aiBlockchainOperation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiBlockchainOperationUpdateManyArgs>(args: SelectSubset<T, AiBlockchainOperationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiBlockchainOperation.
     * @param {AiBlockchainOperationUpsertArgs} args - Arguments to update or create a AiBlockchainOperation.
     * @example
     * // Update or create a AiBlockchainOperation
     * const aiBlockchainOperation = await prisma.aiBlockchainOperation.upsert({
     *   create: {
     *     // ... data to create a AiBlockchainOperation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiBlockchainOperation we want to update
     *   }
     * })
     */
    upsert<T extends AiBlockchainOperationUpsertArgs>(args: SelectSubset<T, AiBlockchainOperationUpsertArgs<ExtArgs>>): Prisma__AiBlockchainOperationClient<$Result.GetResult<Prisma.$AiBlockchainOperationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AiBlockchainOperations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiBlockchainOperationCountArgs} args - Arguments to filter AiBlockchainOperations to count.
     * @example
     * // Count the number of AiBlockchainOperations
     * const count = await prisma.aiBlockchainOperation.count({
     *   where: {
     *     // ... the filter for the AiBlockchainOperations we want to count
     *   }
     * })
    **/
    count<T extends AiBlockchainOperationCountArgs>(
      args?: Subset<T, AiBlockchainOperationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiBlockchainOperationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiBlockchainOperation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiBlockchainOperationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiBlockchainOperationAggregateArgs>(args: Subset<T, AiBlockchainOperationAggregateArgs>): Prisma.PrismaPromise<GetAiBlockchainOperationAggregateType<T>>

    /**
     * Group by AiBlockchainOperation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiBlockchainOperationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiBlockchainOperationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiBlockchainOperationGroupByArgs['orderBy'] }
        : { orderBy?: AiBlockchainOperationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiBlockchainOperationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiBlockchainOperationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiBlockchainOperation model
   */
  readonly fields: AiBlockchainOperationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiBlockchainOperation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiBlockchainOperationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiBlockchainOperation model
   */ 
  interface AiBlockchainOperationFieldRefs {
    readonly id: FieldRef<"AiBlockchainOperation", 'String'>
    readonly userId: FieldRef<"AiBlockchainOperation", 'String'>
    readonly executionId: FieldRef<"AiBlockchainOperation", 'String'>
    readonly nodeId: FieldRef<"AiBlockchainOperation", 'String'>
    readonly operationType: FieldRef<"AiBlockchainOperation", 'String'>
    readonly blockchain: FieldRef<"AiBlockchainOperation", 'String'>
    readonly prompt: FieldRef<"AiBlockchainOperation", 'String'>
    readonly result: FieldRef<"AiBlockchainOperation", 'Json'>
    readonly status: FieldRef<"AiBlockchainOperation", 'String'>
    readonly error: FieldRef<"AiBlockchainOperation", 'String'>
    readonly createdAt: FieldRef<"AiBlockchainOperation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiBlockchainOperation findUnique
   */
  export type AiBlockchainOperationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiBlockchainOperation
     */
    select?: AiBlockchainOperationSelect<ExtArgs> | null
    /**
     * Filter, which AiBlockchainOperation to fetch.
     */
    where: AiBlockchainOperationWhereUniqueInput
  }

  /**
   * AiBlockchainOperation findUniqueOrThrow
   */
  export type AiBlockchainOperationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiBlockchainOperation
     */
    select?: AiBlockchainOperationSelect<ExtArgs> | null
    /**
     * Filter, which AiBlockchainOperation to fetch.
     */
    where: AiBlockchainOperationWhereUniqueInput
  }

  /**
   * AiBlockchainOperation findFirst
   */
  export type AiBlockchainOperationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiBlockchainOperation
     */
    select?: AiBlockchainOperationSelect<ExtArgs> | null
    /**
     * Filter, which AiBlockchainOperation to fetch.
     */
    where?: AiBlockchainOperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiBlockchainOperations to fetch.
     */
    orderBy?: AiBlockchainOperationOrderByWithRelationInput | AiBlockchainOperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiBlockchainOperations.
     */
    cursor?: AiBlockchainOperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiBlockchainOperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiBlockchainOperations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiBlockchainOperations.
     */
    distinct?: AiBlockchainOperationScalarFieldEnum | AiBlockchainOperationScalarFieldEnum[]
  }

  /**
   * AiBlockchainOperation findFirstOrThrow
   */
  export type AiBlockchainOperationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiBlockchainOperation
     */
    select?: AiBlockchainOperationSelect<ExtArgs> | null
    /**
     * Filter, which AiBlockchainOperation to fetch.
     */
    where?: AiBlockchainOperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiBlockchainOperations to fetch.
     */
    orderBy?: AiBlockchainOperationOrderByWithRelationInput | AiBlockchainOperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiBlockchainOperations.
     */
    cursor?: AiBlockchainOperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiBlockchainOperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiBlockchainOperations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiBlockchainOperations.
     */
    distinct?: AiBlockchainOperationScalarFieldEnum | AiBlockchainOperationScalarFieldEnum[]
  }

  /**
   * AiBlockchainOperation findMany
   */
  export type AiBlockchainOperationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiBlockchainOperation
     */
    select?: AiBlockchainOperationSelect<ExtArgs> | null
    /**
     * Filter, which AiBlockchainOperations to fetch.
     */
    where?: AiBlockchainOperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiBlockchainOperations to fetch.
     */
    orderBy?: AiBlockchainOperationOrderByWithRelationInput | AiBlockchainOperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiBlockchainOperations.
     */
    cursor?: AiBlockchainOperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiBlockchainOperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiBlockchainOperations.
     */
    skip?: number
    distinct?: AiBlockchainOperationScalarFieldEnum | AiBlockchainOperationScalarFieldEnum[]
  }

  /**
   * AiBlockchainOperation create
   */
  export type AiBlockchainOperationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiBlockchainOperation
     */
    select?: AiBlockchainOperationSelect<ExtArgs> | null
    /**
     * The data needed to create a AiBlockchainOperation.
     */
    data: XOR<AiBlockchainOperationCreateInput, AiBlockchainOperationUncheckedCreateInput>
  }

  /**
   * AiBlockchainOperation createMany
   */
  export type AiBlockchainOperationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiBlockchainOperations.
     */
    data: AiBlockchainOperationCreateManyInput | AiBlockchainOperationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiBlockchainOperation createManyAndReturn
   */
  export type AiBlockchainOperationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiBlockchainOperation
     */
    select?: AiBlockchainOperationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AiBlockchainOperations.
     */
    data: AiBlockchainOperationCreateManyInput | AiBlockchainOperationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiBlockchainOperation update
   */
  export type AiBlockchainOperationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiBlockchainOperation
     */
    select?: AiBlockchainOperationSelect<ExtArgs> | null
    /**
     * The data needed to update a AiBlockchainOperation.
     */
    data: XOR<AiBlockchainOperationUpdateInput, AiBlockchainOperationUncheckedUpdateInput>
    /**
     * Choose, which AiBlockchainOperation to update.
     */
    where: AiBlockchainOperationWhereUniqueInput
  }

  /**
   * AiBlockchainOperation updateMany
   */
  export type AiBlockchainOperationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiBlockchainOperations.
     */
    data: XOR<AiBlockchainOperationUpdateManyMutationInput, AiBlockchainOperationUncheckedUpdateManyInput>
    /**
     * Filter which AiBlockchainOperations to update
     */
    where?: AiBlockchainOperationWhereInput
  }

  /**
   * AiBlockchainOperation upsert
   */
  export type AiBlockchainOperationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiBlockchainOperation
     */
    select?: AiBlockchainOperationSelect<ExtArgs> | null
    /**
     * The filter to search for the AiBlockchainOperation to update in case it exists.
     */
    where: AiBlockchainOperationWhereUniqueInput
    /**
     * In case the AiBlockchainOperation found by the `where` argument doesn't exist, create a new AiBlockchainOperation with this data.
     */
    create: XOR<AiBlockchainOperationCreateInput, AiBlockchainOperationUncheckedCreateInput>
    /**
     * In case the AiBlockchainOperation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiBlockchainOperationUpdateInput, AiBlockchainOperationUncheckedUpdateInput>
  }

  /**
   * AiBlockchainOperation delete
   */
  export type AiBlockchainOperationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiBlockchainOperation
     */
    select?: AiBlockchainOperationSelect<ExtArgs> | null
    /**
     * Filter which AiBlockchainOperation to delete.
     */
    where: AiBlockchainOperationWhereUniqueInput
  }

  /**
   * AiBlockchainOperation deleteMany
   */
  export type AiBlockchainOperationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiBlockchainOperations to delete
     */
    where?: AiBlockchainOperationWhereInput
  }

  /**
   * AiBlockchainOperation without action
   */
  export type AiBlockchainOperationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiBlockchainOperation
     */
    select?: AiBlockchainOperationSelect<ExtArgs> | null
  }


  /**
   * Model BlockExecution
   */

  export type AggregateBlockExecution = {
    _count: BlockExecutionCountAggregateOutputType | null
    _min: BlockExecutionMinAggregateOutputType | null
    _max: BlockExecutionMaxAggregateOutputType | null
  }

  export type BlockExecutionMinAggregateOutputType = {
    id: string | null
    executionId: string | null
    nodeId: string | null
    blockType: string | null
    status: $Enums.BlockStatus | null
    error: string | null
    startTime: Date | null
    endTime: Date | null
  }

  export type BlockExecutionMaxAggregateOutputType = {
    id: string | null
    executionId: string | null
    nodeId: string | null
    blockType: string | null
    status: $Enums.BlockStatus | null
    error: string | null
    startTime: Date | null
    endTime: Date | null
  }

  export type BlockExecutionCountAggregateOutputType = {
    id: number
    executionId: number
    nodeId: number
    blockType: number
    status: number
    input: number
    output: number
    error: number
    startTime: number
    endTime: number
    _all: number
  }


  export type BlockExecutionMinAggregateInputType = {
    id?: true
    executionId?: true
    nodeId?: true
    blockType?: true
    status?: true
    error?: true
    startTime?: true
    endTime?: true
  }

  export type BlockExecutionMaxAggregateInputType = {
    id?: true
    executionId?: true
    nodeId?: true
    blockType?: true
    status?: true
    error?: true
    startTime?: true
    endTime?: true
  }

  export type BlockExecutionCountAggregateInputType = {
    id?: true
    executionId?: true
    nodeId?: true
    blockType?: true
    status?: true
    input?: true
    output?: true
    error?: true
    startTime?: true
    endTime?: true
    _all?: true
  }

  export type BlockExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockExecution to aggregate.
     */
    where?: BlockExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockExecutions to fetch.
     */
    orderBy?: BlockExecutionOrderByWithRelationInput | BlockExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockExecutions
    **/
    _count?: true | BlockExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockExecutionMaxAggregateInputType
  }

  export type GetBlockExecutionAggregateType<T extends BlockExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockExecution[P]>
      : GetScalarType<T[P], AggregateBlockExecution[P]>
  }




  export type BlockExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockExecutionWhereInput
    orderBy?: BlockExecutionOrderByWithAggregationInput | BlockExecutionOrderByWithAggregationInput[]
    by: BlockExecutionScalarFieldEnum[] | BlockExecutionScalarFieldEnum
    having?: BlockExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockExecutionCountAggregateInputType | true
    _min?: BlockExecutionMinAggregateInputType
    _max?: BlockExecutionMaxAggregateInputType
  }

  export type BlockExecutionGroupByOutputType = {
    id: string
    executionId: string
    nodeId: string
    blockType: string
    status: $Enums.BlockStatus
    input: JsonValue | null
    output: JsonValue | null
    error: string | null
    startTime: Date
    endTime: Date | null
    _count: BlockExecutionCountAggregateOutputType | null
    _min: BlockExecutionMinAggregateOutputType | null
    _max: BlockExecutionMaxAggregateOutputType | null
  }

  type GetBlockExecutionGroupByPayload<T extends BlockExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], BlockExecutionGroupByOutputType[P]>
        }
      >
    >


  export type BlockExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    nodeId?: boolean
    blockType?: boolean
    status?: boolean
    input?: boolean
    output?: boolean
    error?: boolean
    startTime?: boolean
    endTime?: boolean
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
    logs?: boolean | BlockExecution$logsArgs<ExtArgs>
    _count?: boolean | BlockExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockExecution"]>

  export type BlockExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    nodeId?: boolean
    blockType?: boolean
    status?: boolean
    input?: boolean
    output?: boolean
    error?: boolean
    startTime?: boolean
    endTime?: boolean
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockExecution"]>

  export type BlockExecutionSelectScalar = {
    id?: boolean
    executionId?: boolean
    nodeId?: boolean
    blockType?: boolean
    status?: boolean
    input?: boolean
    output?: boolean
    error?: boolean
    startTime?: boolean
    endTime?: boolean
  }

  export type BlockExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
    logs?: boolean | BlockExecution$logsArgs<ExtArgs>
    _count?: boolean | BlockExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlockExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }

  export type $BlockExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockExecution"
    objects: {
      execution: Prisma.$WorkflowExecutionPayload<ExtArgs>
      logs: Prisma.$BlockExecutionLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      executionId: string
      nodeId: string
      blockType: string
      status: $Enums.BlockStatus
      input: Prisma.JsonValue | null
      output: Prisma.JsonValue | null
      error: string | null
      startTime: Date
      endTime: Date | null
    }, ExtArgs["result"]["blockExecution"]>
    composites: {}
  }

  type BlockExecutionGetPayload<S extends boolean | null | undefined | BlockExecutionDefaultArgs> = $Result.GetResult<Prisma.$BlockExecutionPayload, S>

  type BlockExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlockExecutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlockExecutionCountAggregateInputType | true
    }

  export interface BlockExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockExecution'], meta: { name: 'BlockExecution' } }
    /**
     * Find zero or one BlockExecution that matches the filter.
     * @param {BlockExecutionFindUniqueArgs} args - Arguments to find a BlockExecution
     * @example
     * // Get one BlockExecution
     * const blockExecution = await prisma.blockExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockExecutionFindUniqueArgs>(args: SelectSubset<T, BlockExecutionFindUniqueArgs<ExtArgs>>): Prisma__BlockExecutionClient<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlockExecution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlockExecutionFindUniqueOrThrowArgs} args - Arguments to find a BlockExecution
     * @example
     * // Get one BlockExecution
     * const blockExecution = await prisma.blockExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockExecutionClient<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlockExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionFindFirstArgs} args - Arguments to find a BlockExecution
     * @example
     * // Get one BlockExecution
     * const blockExecution = await prisma.blockExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockExecutionFindFirstArgs>(args?: SelectSubset<T, BlockExecutionFindFirstArgs<ExtArgs>>): Prisma__BlockExecutionClient<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlockExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionFindFirstOrThrowArgs} args - Arguments to find a BlockExecution
     * @example
     * // Get one BlockExecution
     * const blockExecution = await prisma.blockExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockExecutionClient<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlockExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockExecutions
     * const blockExecutions = await prisma.blockExecution.findMany()
     * 
     * // Get first 10 BlockExecutions
     * const blockExecutions = await prisma.blockExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockExecutionWithIdOnly = await prisma.blockExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockExecutionFindManyArgs>(args?: SelectSubset<T, BlockExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlockExecution.
     * @param {BlockExecutionCreateArgs} args - Arguments to create a BlockExecution.
     * @example
     * // Create one BlockExecution
     * const BlockExecution = await prisma.blockExecution.create({
     *   data: {
     *     // ... data to create a BlockExecution
     *   }
     * })
     * 
     */
    create<T extends BlockExecutionCreateArgs>(args: SelectSubset<T, BlockExecutionCreateArgs<ExtArgs>>): Prisma__BlockExecutionClient<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlockExecutions.
     * @param {BlockExecutionCreateManyArgs} args - Arguments to create many BlockExecutions.
     * @example
     * // Create many BlockExecutions
     * const blockExecution = await prisma.blockExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockExecutionCreateManyArgs>(args?: SelectSubset<T, BlockExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockExecutions and returns the data saved in the database.
     * @param {BlockExecutionCreateManyAndReturnArgs} args - Arguments to create many BlockExecutions.
     * @example
     * // Create many BlockExecutions
     * const blockExecution = await prisma.blockExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockExecutions and only return the `id`
     * const blockExecutionWithIdOnly = await prisma.blockExecution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlockExecution.
     * @param {BlockExecutionDeleteArgs} args - Arguments to delete one BlockExecution.
     * @example
     * // Delete one BlockExecution
     * const BlockExecution = await prisma.blockExecution.delete({
     *   where: {
     *     // ... filter to delete one BlockExecution
     *   }
     * })
     * 
     */
    delete<T extends BlockExecutionDeleteArgs>(args: SelectSubset<T, BlockExecutionDeleteArgs<ExtArgs>>): Prisma__BlockExecutionClient<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlockExecution.
     * @param {BlockExecutionUpdateArgs} args - Arguments to update one BlockExecution.
     * @example
     * // Update one BlockExecution
     * const blockExecution = await prisma.blockExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockExecutionUpdateArgs>(args: SelectSubset<T, BlockExecutionUpdateArgs<ExtArgs>>): Prisma__BlockExecutionClient<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlockExecutions.
     * @param {BlockExecutionDeleteManyArgs} args - Arguments to filter BlockExecutions to delete.
     * @example
     * // Delete a few BlockExecutions
     * const { count } = await prisma.blockExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockExecutionDeleteManyArgs>(args?: SelectSubset<T, BlockExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockExecutions
     * const blockExecution = await prisma.blockExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockExecutionUpdateManyArgs>(args: SelectSubset<T, BlockExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlockExecution.
     * @param {BlockExecutionUpsertArgs} args - Arguments to update or create a BlockExecution.
     * @example
     * // Update or create a BlockExecution
     * const blockExecution = await prisma.blockExecution.upsert({
     *   create: {
     *     // ... data to create a BlockExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockExecution we want to update
     *   }
     * })
     */
    upsert<T extends BlockExecutionUpsertArgs>(args: SelectSubset<T, BlockExecutionUpsertArgs<ExtArgs>>): Prisma__BlockExecutionClient<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlockExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionCountArgs} args - Arguments to filter BlockExecutions to count.
     * @example
     * // Count the number of BlockExecutions
     * const count = await prisma.blockExecution.count({
     *   where: {
     *     // ... the filter for the BlockExecutions we want to count
     *   }
     * })
    **/
    count<T extends BlockExecutionCountArgs>(
      args?: Subset<T, BlockExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockExecutionAggregateArgs>(args: Subset<T, BlockExecutionAggregateArgs>): Prisma.PrismaPromise<GetBlockExecutionAggregateType<T>>

    /**
     * Group by BlockExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockExecutionGroupByArgs['orderBy'] }
        : { orderBy?: BlockExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockExecution model
   */
  readonly fields: BlockExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    execution<T extends WorkflowExecutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowExecutionDefaultArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    logs<T extends BlockExecution$logsArgs<ExtArgs> = {}>(args?: Subset<T, BlockExecution$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockExecutionLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockExecution model
   */ 
  interface BlockExecutionFieldRefs {
    readonly id: FieldRef<"BlockExecution", 'String'>
    readonly executionId: FieldRef<"BlockExecution", 'String'>
    readonly nodeId: FieldRef<"BlockExecution", 'String'>
    readonly blockType: FieldRef<"BlockExecution", 'String'>
    readonly status: FieldRef<"BlockExecution", 'BlockStatus'>
    readonly input: FieldRef<"BlockExecution", 'Json'>
    readonly output: FieldRef<"BlockExecution", 'Json'>
    readonly error: FieldRef<"BlockExecution", 'String'>
    readonly startTime: FieldRef<"BlockExecution", 'DateTime'>
    readonly endTime: FieldRef<"BlockExecution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlockExecution findUnique
   */
  export type BlockExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * Filter, which BlockExecution to fetch.
     */
    where: BlockExecutionWhereUniqueInput
  }

  /**
   * BlockExecution findUniqueOrThrow
   */
  export type BlockExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * Filter, which BlockExecution to fetch.
     */
    where: BlockExecutionWhereUniqueInput
  }

  /**
   * BlockExecution findFirst
   */
  export type BlockExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * Filter, which BlockExecution to fetch.
     */
    where?: BlockExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockExecutions to fetch.
     */
    orderBy?: BlockExecutionOrderByWithRelationInput | BlockExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockExecutions.
     */
    cursor?: BlockExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockExecutions.
     */
    distinct?: BlockExecutionScalarFieldEnum | BlockExecutionScalarFieldEnum[]
  }

  /**
   * BlockExecution findFirstOrThrow
   */
  export type BlockExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * Filter, which BlockExecution to fetch.
     */
    where?: BlockExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockExecutions to fetch.
     */
    orderBy?: BlockExecutionOrderByWithRelationInput | BlockExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockExecutions.
     */
    cursor?: BlockExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockExecutions.
     */
    distinct?: BlockExecutionScalarFieldEnum | BlockExecutionScalarFieldEnum[]
  }

  /**
   * BlockExecution findMany
   */
  export type BlockExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * Filter, which BlockExecutions to fetch.
     */
    where?: BlockExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockExecutions to fetch.
     */
    orderBy?: BlockExecutionOrderByWithRelationInput | BlockExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockExecutions.
     */
    cursor?: BlockExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockExecutions.
     */
    skip?: number
    distinct?: BlockExecutionScalarFieldEnum | BlockExecutionScalarFieldEnum[]
  }

  /**
   * BlockExecution create
   */
  export type BlockExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockExecution.
     */
    data: XOR<BlockExecutionCreateInput, BlockExecutionUncheckedCreateInput>
  }

  /**
   * BlockExecution createMany
   */
  export type BlockExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockExecutions.
     */
    data: BlockExecutionCreateManyInput | BlockExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockExecution createManyAndReturn
   */
  export type BlockExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlockExecutions.
     */
    data: BlockExecutionCreateManyInput | BlockExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockExecution update
   */
  export type BlockExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockExecution.
     */
    data: XOR<BlockExecutionUpdateInput, BlockExecutionUncheckedUpdateInput>
    /**
     * Choose, which BlockExecution to update.
     */
    where: BlockExecutionWhereUniqueInput
  }

  /**
   * BlockExecution updateMany
   */
  export type BlockExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockExecutions.
     */
    data: XOR<BlockExecutionUpdateManyMutationInput, BlockExecutionUncheckedUpdateManyInput>
    /**
     * Filter which BlockExecutions to update
     */
    where?: BlockExecutionWhereInput
  }

  /**
   * BlockExecution upsert
   */
  export type BlockExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockExecution to update in case it exists.
     */
    where: BlockExecutionWhereUniqueInput
    /**
     * In case the BlockExecution found by the `where` argument doesn't exist, create a new BlockExecution with this data.
     */
    create: XOR<BlockExecutionCreateInput, BlockExecutionUncheckedCreateInput>
    /**
     * In case the BlockExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockExecutionUpdateInput, BlockExecutionUncheckedUpdateInput>
  }

  /**
   * BlockExecution delete
   */
  export type BlockExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * Filter which BlockExecution to delete.
     */
    where: BlockExecutionWhereUniqueInput
  }

  /**
   * BlockExecution deleteMany
   */
  export type BlockExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockExecutions to delete
     */
    where?: BlockExecutionWhereInput
  }

  /**
   * BlockExecution.logs
   */
  export type BlockExecution$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecutionLog
     */
    select?: BlockExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionLogInclude<ExtArgs> | null
    where?: BlockExecutionLogWhereInput
    orderBy?: BlockExecutionLogOrderByWithRelationInput | BlockExecutionLogOrderByWithRelationInput[]
    cursor?: BlockExecutionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockExecutionLogScalarFieldEnum | BlockExecutionLogScalarFieldEnum[]
  }

  /**
   * BlockExecution without action
   */
  export type BlockExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
  }


  /**
   * Model BlockExecutionLog
   */

  export type AggregateBlockExecutionLog = {
    _count: BlockExecutionLogCountAggregateOutputType | null
    _min: BlockExecutionLogMinAggregateOutputType | null
    _max: BlockExecutionLogMaxAggregateOutputType | null
  }

  export type BlockExecutionLogMinAggregateOutputType = {
    id: string | null
    blockExecutionId: string | null
    level: $Enums.LogLevel | null
    message: string | null
    timestamp: Date | null
  }

  export type BlockExecutionLogMaxAggregateOutputType = {
    id: string | null
    blockExecutionId: string | null
    level: $Enums.LogLevel | null
    message: string | null
    timestamp: Date | null
  }

  export type BlockExecutionLogCountAggregateOutputType = {
    id: number
    blockExecutionId: number
    level: number
    message: number
    timestamp: number
    _all: number
  }


  export type BlockExecutionLogMinAggregateInputType = {
    id?: true
    blockExecutionId?: true
    level?: true
    message?: true
    timestamp?: true
  }

  export type BlockExecutionLogMaxAggregateInputType = {
    id?: true
    blockExecutionId?: true
    level?: true
    message?: true
    timestamp?: true
  }

  export type BlockExecutionLogCountAggregateInputType = {
    id?: true
    blockExecutionId?: true
    level?: true
    message?: true
    timestamp?: true
    _all?: true
  }

  export type BlockExecutionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockExecutionLog to aggregate.
     */
    where?: BlockExecutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockExecutionLogs to fetch.
     */
    orderBy?: BlockExecutionLogOrderByWithRelationInput | BlockExecutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockExecutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockExecutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockExecutionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockExecutionLogs
    **/
    _count?: true | BlockExecutionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockExecutionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockExecutionLogMaxAggregateInputType
  }

  export type GetBlockExecutionLogAggregateType<T extends BlockExecutionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockExecutionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockExecutionLog[P]>
      : GetScalarType<T[P], AggregateBlockExecutionLog[P]>
  }




  export type BlockExecutionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockExecutionLogWhereInput
    orderBy?: BlockExecutionLogOrderByWithAggregationInput | BlockExecutionLogOrderByWithAggregationInput[]
    by: BlockExecutionLogScalarFieldEnum[] | BlockExecutionLogScalarFieldEnum
    having?: BlockExecutionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockExecutionLogCountAggregateInputType | true
    _min?: BlockExecutionLogMinAggregateInputType
    _max?: BlockExecutionLogMaxAggregateInputType
  }

  export type BlockExecutionLogGroupByOutputType = {
    id: string
    blockExecutionId: string
    level: $Enums.LogLevel
    message: string
    timestamp: Date
    _count: BlockExecutionLogCountAggregateOutputType | null
    _min: BlockExecutionLogMinAggregateOutputType | null
    _max: BlockExecutionLogMaxAggregateOutputType | null
  }

  type GetBlockExecutionLogGroupByPayload<T extends BlockExecutionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockExecutionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockExecutionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockExecutionLogGroupByOutputType[P]>
            : GetScalarType<T[P], BlockExecutionLogGroupByOutputType[P]>
        }
      >
    >


  export type BlockExecutionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockExecutionId?: boolean
    level?: boolean
    message?: boolean
    timestamp?: boolean
    blockExecution?: boolean | BlockExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockExecutionLog"]>

  export type BlockExecutionLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockExecutionId?: boolean
    level?: boolean
    message?: boolean
    timestamp?: boolean
    blockExecution?: boolean | BlockExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockExecutionLog"]>

  export type BlockExecutionLogSelectScalar = {
    id?: boolean
    blockExecutionId?: boolean
    level?: boolean
    message?: boolean
    timestamp?: boolean
  }

  export type BlockExecutionLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blockExecution?: boolean | BlockExecutionDefaultArgs<ExtArgs>
  }
  export type BlockExecutionLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blockExecution?: boolean | BlockExecutionDefaultArgs<ExtArgs>
  }

  export type $BlockExecutionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockExecutionLog"
    objects: {
      blockExecution: Prisma.$BlockExecutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      blockExecutionId: string
      level: $Enums.LogLevel
      message: string
      timestamp: Date
    }, ExtArgs["result"]["blockExecutionLog"]>
    composites: {}
  }

  type BlockExecutionLogGetPayload<S extends boolean | null | undefined | BlockExecutionLogDefaultArgs> = $Result.GetResult<Prisma.$BlockExecutionLogPayload, S>

  type BlockExecutionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlockExecutionLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlockExecutionLogCountAggregateInputType | true
    }

  export interface BlockExecutionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockExecutionLog'], meta: { name: 'BlockExecutionLog' } }
    /**
     * Find zero or one BlockExecutionLog that matches the filter.
     * @param {BlockExecutionLogFindUniqueArgs} args - Arguments to find a BlockExecutionLog
     * @example
     * // Get one BlockExecutionLog
     * const blockExecutionLog = await prisma.blockExecutionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockExecutionLogFindUniqueArgs>(args: SelectSubset<T, BlockExecutionLogFindUniqueArgs<ExtArgs>>): Prisma__BlockExecutionLogClient<$Result.GetResult<Prisma.$BlockExecutionLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlockExecutionLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlockExecutionLogFindUniqueOrThrowArgs} args - Arguments to find a BlockExecutionLog
     * @example
     * // Get one BlockExecutionLog
     * const blockExecutionLog = await prisma.blockExecutionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockExecutionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockExecutionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockExecutionLogClient<$Result.GetResult<Prisma.$BlockExecutionLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlockExecutionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionLogFindFirstArgs} args - Arguments to find a BlockExecutionLog
     * @example
     * // Get one BlockExecutionLog
     * const blockExecutionLog = await prisma.blockExecutionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockExecutionLogFindFirstArgs>(args?: SelectSubset<T, BlockExecutionLogFindFirstArgs<ExtArgs>>): Prisma__BlockExecutionLogClient<$Result.GetResult<Prisma.$BlockExecutionLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlockExecutionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionLogFindFirstOrThrowArgs} args - Arguments to find a BlockExecutionLog
     * @example
     * // Get one BlockExecutionLog
     * const blockExecutionLog = await prisma.blockExecutionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockExecutionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockExecutionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockExecutionLogClient<$Result.GetResult<Prisma.$BlockExecutionLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlockExecutionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockExecutionLogs
     * const blockExecutionLogs = await prisma.blockExecutionLog.findMany()
     * 
     * // Get first 10 BlockExecutionLogs
     * const blockExecutionLogs = await prisma.blockExecutionLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockExecutionLogWithIdOnly = await prisma.blockExecutionLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockExecutionLogFindManyArgs>(args?: SelectSubset<T, BlockExecutionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockExecutionLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlockExecutionLog.
     * @param {BlockExecutionLogCreateArgs} args - Arguments to create a BlockExecutionLog.
     * @example
     * // Create one BlockExecutionLog
     * const BlockExecutionLog = await prisma.blockExecutionLog.create({
     *   data: {
     *     // ... data to create a BlockExecutionLog
     *   }
     * })
     * 
     */
    create<T extends BlockExecutionLogCreateArgs>(args: SelectSubset<T, BlockExecutionLogCreateArgs<ExtArgs>>): Prisma__BlockExecutionLogClient<$Result.GetResult<Prisma.$BlockExecutionLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlockExecutionLogs.
     * @param {BlockExecutionLogCreateManyArgs} args - Arguments to create many BlockExecutionLogs.
     * @example
     * // Create many BlockExecutionLogs
     * const blockExecutionLog = await prisma.blockExecutionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockExecutionLogCreateManyArgs>(args?: SelectSubset<T, BlockExecutionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockExecutionLogs and returns the data saved in the database.
     * @param {BlockExecutionLogCreateManyAndReturnArgs} args - Arguments to create many BlockExecutionLogs.
     * @example
     * // Create many BlockExecutionLogs
     * const blockExecutionLog = await prisma.blockExecutionLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockExecutionLogs and only return the `id`
     * const blockExecutionLogWithIdOnly = await prisma.blockExecutionLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockExecutionLogCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockExecutionLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockExecutionLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlockExecutionLog.
     * @param {BlockExecutionLogDeleteArgs} args - Arguments to delete one BlockExecutionLog.
     * @example
     * // Delete one BlockExecutionLog
     * const BlockExecutionLog = await prisma.blockExecutionLog.delete({
     *   where: {
     *     // ... filter to delete one BlockExecutionLog
     *   }
     * })
     * 
     */
    delete<T extends BlockExecutionLogDeleteArgs>(args: SelectSubset<T, BlockExecutionLogDeleteArgs<ExtArgs>>): Prisma__BlockExecutionLogClient<$Result.GetResult<Prisma.$BlockExecutionLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlockExecutionLog.
     * @param {BlockExecutionLogUpdateArgs} args - Arguments to update one BlockExecutionLog.
     * @example
     * // Update one BlockExecutionLog
     * const blockExecutionLog = await prisma.blockExecutionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockExecutionLogUpdateArgs>(args: SelectSubset<T, BlockExecutionLogUpdateArgs<ExtArgs>>): Prisma__BlockExecutionLogClient<$Result.GetResult<Prisma.$BlockExecutionLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlockExecutionLogs.
     * @param {BlockExecutionLogDeleteManyArgs} args - Arguments to filter BlockExecutionLogs to delete.
     * @example
     * // Delete a few BlockExecutionLogs
     * const { count } = await prisma.blockExecutionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockExecutionLogDeleteManyArgs>(args?: SelectSubset<T, BlockExecutionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockExecutionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockExecutionLogs
     * const blockExecutionLog = await prisma.blockExecutionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockExecutionLogUpdateManyArgs>(args: SelectSubset<T, BlockExecutionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlockExecutionLog.
     * @param {BlockExecutionLogUpsertArgs} args - Arguments to update or create a BlockExecutionLog.
     * @example
     * // Update or create a BlockExecutionLog
     * const blockExecutionLog = await prisma.blockExecutionLog.upsert({
     *   create: {
     *     // ... data to create a BlockExecutionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockExecutionLog we want to update
     *   }
     * })
     */
    upsert<T extends BlockExecutionLogUpsertArgs>(args: SelectSubset<T, BlockExecutionLogUpsertArgs<ExtArgs>>): Prisma__BlockExecutionLogClient<$Result.GetResult<Prisma.$BlockExecutionLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlockExecutionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionLogCountArgs} args - Arguments to filter BlockExecutionLogs to count.
     * @example
     * // Count the number of BlockExecutionLogs
     * const count = await prisma.blockExecutionLog.count({
     *   where: {
     *     // ... the filter for the BlockExecutionLogs we want to count
     *   }
     * })
    **/
    count<T extends BlockExecutionLogCountArgs>(
      args?: Subset<T, BlockExecutionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockExecutionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockExecutionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockExecutionLogAggregateArgs>(args: Subset<T, BlockExecutionLogAggregateArgs>): Prisma.PrismaPromise<GetBlockExecutionLogAggregateType<T>>

    /**
     * Group by BlockExecutionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockExecutionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockExecutionLogGroupByArgs['orderBy'] }
        : { orderBy?: BlockExecutionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockExecutionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockExecutionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockExecutionLog model
   */
  readonly fields: BlockExecutionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockExecutionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockExecutionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blockExecution<T extends BlockExecutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlockExecutionDefaultArgs<ExtArgs>>): Prisma__BlockExecutionClient<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockExecutionLog model
   */ 
  interface BlockExecutionLogFieldRefs {
    readonly id: FieldRef<"BlockExecutionLog", 'String'>
    readonly blockExecutionId: FieldRef<"BlockExecutionLog", 'String'>
    readonly level: FieldRef<"BlockExecutionLog", 'LogLevel'>
    readonly message: FieldRef<"BlockExecutionLog", 'String'>
    readonly timestamp: FieldRef<"BlockExecutionLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlockExecutionLog findUnique
   */
  export type BlockExecutionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecutionLog
     */
    select?: BlockExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which BlockExecutionLog to fetch.
     */
    where: BlockExecutionLogWhereUniqueInput
  }

  /**
   * BlockExecutionLog findUniqueOrThrow
   */
  export type BlockExecutionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecutionLog
     */
    select?: BlockExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which BlockExecutionLog to fetch.
     */
    where: BlockExecutionLogWhereUniqueInput
  }

  /**
   * BlockExecutionLog findFirst
   */
  export type BlockExecutionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecutionLog
     */
    select?: BlockExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which BlockExecutionLog to fetch.
     */
    where?: BlockExecutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockExecutionLogs to fetch.
     */
    orderBy?: BlockExecutionLogOrderByWithRelationInput | BlockExecutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockExecutionLogs.
     */
    cursor?: BlockExecutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockExecutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockExecutionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockExecutionLogs.
     */
    distinct?: BlockExecutionLogScalarFieldEnum | BlockExecutionLogScalarFieldEnum[]
  }

  /**
   * BlockExecutionLog findFirstOrThrow
   */
  export type BlockExecutionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecutionLog
     */
    select?: BlockExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which BlockExecutionLog to fetch.
     */
    where?: BlockExecutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockExecutionLogs to fetch.
     */
    orderBy?: BlockExecutionLogOrderByWithRelationInput | BlockExecutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockExecutionLogs.
     */
    cursor?: BlockExecutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockExecutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockExecutionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockExecutionLogs.
     */
    distinct?: BlockExecutionLogScalarFieldEnum | BlockExecutionLogScalarFieldEnum[]
  }

  /**
   * BlockExecutionLog findMany
   */
  export type BlockExecutionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecutionLog
     */
    select?: BlockExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which BlockExecutionLogs to fetch.
     */
    where?: BlockExecutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockExecutionLogs to fetch.
     */
    orderBy?: BlockExecutionLogOrderByWithRelationInput | BlockExecutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockExecutionLogs.
     */
    cursor?: BlockExecutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockExecutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockExecutionLogs.
     */
    skip?: number
    distinct?: BlockExecutionLogScalarFieldEnum | BlockExecutionLogScalarFieldEnum[]
  }

  /**
   * BlockExecutionLog create
   */
  export type BlockExecutionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecutionLog
     */
    select?: BlockExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionLogInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockExecutionLog.
     */
    data: XOR<BlockExecutionLogCreateInput, BlockExecutionLogUncheckedCreateInput>
  }

  /**
   * BlockExecutionLog createMany
   */
  export type BlockExecutionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockExecutionLogs.
     */
    data: BlockExecutionLogCreateManyInput | BlockExecutionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockExecutionLog createManyAndReturn
   */
  export type BlockExecutionLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecutionLog
     */
    select?: BlockExecutionLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlockExecutionLogs.
     */
    data: BlockExecutionLogCreateManyInput | BlockExecutionLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockExecutionLog update
   */
  export type BlockExecutionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecutionLog
     */
    select?: BlockExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionLogInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockExecutionLog.
     */
    data: XOR<BlockExecutionLogUpdateInput, BlockExecutionLogUncheckedUpdateInput>
    /**
     * Choose, which BlockExecutionLog to update.
     */
    where: BlockExecutionLogWhereUniqueInput
  }

  /**
   * BlockExecutionLog updateMany
   */
  export type BlockExecutionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockExecutionLogs.
     */
    data: XOR<BlockExecutionLogUpdateManyMutationInput, BlockExecutionLogUncheckedUpdateManyInput>
    /**
     * Filter which BlockExecutionLogs to update
     */
    where?: BlockExecutionLogWhereInput
  }

  /**
   * BlockExecutionLog upsert
   */
  export type BlockExecutionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecutionLog
     */
    select?: BlockExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionLogInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockExecutionLog to update in case it exists.
     */
    where: BlockExecutionLogWhereUniqueInput
    /**
     * In case the BlockExecutionLog found by the `where` argument doesn't exist, create a new BlockExecutionLog with this data.
     */
    create: XOR<BlockExecutionLogCreateInput, BlockExecutionLogUncheckedCreateInput>
    /**
     * In case the BlockExecutionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockExecutionLogUpdateInput, BlockExecutionLogUncheckedUpdateInput>
  }

  /**
   * BlockExecutionLog delete
   */
  export type BlockExecutionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecutionLog
     */
    select?: BlockExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionLogInclude<ExtArgs> | null
    /**
     * Filter which BlockExecutionLog to delete.
     */
    where: BlockExecutionLogWhereUniqueInput
  }

  /**
   * BlockExecutionLog deleteMany
   */
  export type BlockExecutionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockExecutionLogs to delete
     */
    where?: BlockExecutionLogWhereInput
  }

  /**
   * BlockExecutionLog without action
   */
  export type BlockExecutionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecutionLog
     */
    select?: BlockExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionLogInclude<ExtArgs> | null
  }


  /**
   * Model BlockLibrary
   */

  export type AggregateBlockLibrary = {
    _count: BlockLibraryCountAggregateOutputType | null
    _avg: BlockLibraryAvgAggregateOutputType | null
    _sum: BlockLibrarySumAggregateOutputType | null
    _min: BlockLibraryMinAggregateOutputType | null
    _max: BlockLibraryMaxAggregateOutputType | null
  }

  export type BlockLibraryAvgAggregateOutputType = {
    rating: number | null
    usageCount: number | null
  }

  export type BlockLibrarySumAggregateOutputType = {
    rating: number | null
    usageCount: number | null
  }

  export type BlockLibraryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    blockType: string | null
    category: string | null
    executionCode: string | null
    userId: string | null
    isPublic: boolean | null
    isVerified: boolean | null
    rating: number | null
    usageCount: number | null
    version: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlockLibraryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    blockType: string | null
    category: string | null
    executionCode: string | null
    userId: string | null
    isPublic: boolean | null
    isVerified: boolean | null
    rating: number | null
    usageCount: number | null
    version: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlockLibraryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    blockType: number
    category: number
    configuration: number
    blockData: number
    executionCode: number
    userId: number
    isPublic: number
    isVerified: number
    rating: number
    usageCount: number
    tags: number
    version: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlockLibraryAvgAggregateInputType = {
    rating?: true
    usageCount?: true
  }

  export type BlockLibrarySumAggregateInputType = {
    rating?: true
    usageCount?: true
  }

  export type BlockLibraryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    blockType?: true
    category?: true
    executionCode?: true
    userId?: true
    isPublic?: true
    isVerified?: true
    rating?: true
    usageCount?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlockLibraryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    blockType?: true
    category?: true
    executionCode?: true
    userId?: true
    isPublic?: true
    isVerified?: true
    rating?: true
    usageCount?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlockLibraryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    blockType?: true
    category?: true
    configuration?: true
    blockData?: true
    executionCode?: true
    userId?: true
    isPublic?: true
    isVerified?: true
    rating?: true
    usageCount?: true
    tags?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlockLibraryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockLibrary to aggregate.
     */
    where?: BlockLibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockLibraries to fetch.
     */
    orderBy?: BlockLibraryOrderByWithRelationInput | BlockLibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockLibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockLibraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockLibraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockLibraries
    **/
    _count?: true | BlockLibraryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockLibraryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockLibrarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockLibraryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockLibraryMaxAggregateInputType
  }

  export type GetBlockLibraryAggregateType<T extends BlockLibraryAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockLibrary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockLibrary[P]>
      : GetScalarType<T[P], AggregateBlockLibrary[P]>
  }




  export type BlockLibraryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockLibraryWhereInput
    orderBy?: BlockLibraryOrderByWithAggregationInput | BlockLibraryOrderByWithAggregationInput[]
    by: BlockLibraryScalarFieldEnum[] | BlockLibraryScalarFieldEnum
    having?: BlockLibraryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockLibraryCountAggregateInputType | true
    _avg?: BlockLibraryAvgAggregateInputType
    _sum?: BlockLibrarySumAggregateInputType
    _min?: BlockLibraryMinAggregateInputType
    _max?: BlockLibraryMaxAggregateInputType
  }

  export type BlockLibraryGroupByOutputType = {
    id: string
    name: string
    description: string
    blockType: string
    category: string | null
    configuration: JsonValue
    blockData: JsonValue | null
    executionCode: string | null
    userId: string
    isPublic: boolean | null
    isVerified: boolean | null
    rating: number | null
    usageCount: number | null
    tags: string[]
    version: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: BlockLibraryCountAggregateOutputType | null
    _avg: BlockLibraryAvgAggregateOutputType | null
    _sum: BlockLibrarySumAggregateOutputType | null
    _min: BlockLibraryMinAggregateOutputType | null
    _max: BlockLibraryMaxAggregateOutputType | null
  }

  type GetBlockLibraryGroupByPayload<T extends BlockLibraryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockLibraryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockLibraryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockLibraryGroupByOutputType[P]>
            : GetScalarType<T[P], BlockLibraryGroupByOutputType[P]>
        }
      >
    >


  export type BlockLibrarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    blockType?: boolean
    category?: boolean
    configuration?: boolean
    blockData?: boolean
    executionCode?: boolean
    userId?: boolean
    isPublic?: boolean
    isVerified?: boolean
    rating?: boolean
    usageCount?: boolean
    tags?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ratings?: boolean | BlockLibrary$ratingsArgs<ExtArgs>
    _count?: boolean | BlockLibraryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockLibrary"]>

  export type BlockLibrarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    blockType?: boolean
    category?: boolean
    configuration?: boolean
    blockData?: boolean
    executionCode?: boolean
    userId?: boolean
    isPublic?: boolean
    isVerified?: boolean
    rating?: boolean
    usageCount?: boolean
    tags?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blockLibrary"]>

  export type BlockLibrarySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    blockType?: boolean
    category?: boolean
    configuration?: boolean
    blockData?: boolean
    executionCode?: boolean
    userId?: boolean
    isPublic?: boolean
    isVerified?: boolean
    rating?: boolean
    usageCount?: boolean
    tags?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlockLibraryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ratings?: boolean | BlockLibrary$ratingsArgs<ExtArgs>
    _count?: boolean | BlockLibraryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlockLibraryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BlockLibraryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockLibrary"
    objects: {
      ratings: Prisma.$BlockLibraryRatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      blockType: string
      category: string | null
      configuration: Prisma.JsonValue
      blockData: Prisma.JsonValue | null
      executionCode: string | null
      userId: string
      isPublic: boolean | null
      isVerified: boolean | null
      rating: number | null
      usageCount: number | null
      tags: string[]
      version: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["blockLibrary"]>
    composites: {}
  }

  type BlockLibraryGetPayload<S extends boolean | null | undefined | BlockLibraryDefaultArgs> = $Result.GetResult<Prisma.$BlockLibraryPayload, S>

  type BlockLibraryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlockLibraryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlockLibraryCountAggregateInputType | true
    }

  export interface BlockLibraryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockLibrary'], meta: { name: 'BlockLibrary' } }
    /**
     * Find zero or one BlockLibrary that matches the filter.
     * @param {BlockLibraryFindUniqueArgs} args - Arguments to find a BlockLibrary
     * @example
     * // Get one BlockLibrary
     * const blockLibrary = await prisma.blockLibrary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockLibraryFindUniqueArgs>(args: SelectSubset<T, BlockLibraryFindUniqueArgs<ExtArgs>>): Prisma__BlockLibraryClient<$Result.GetResult<Prisma.$BlockLibraryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlockLibrary that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlockLibraryFindUniqueOrThrowArgs} args - Arguments to find a BlockLibrary
     * @example
     * // Get one BlockLibrary
     * const blockLibrary = await prisma.blockLibrary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockLibraryFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockLibraryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockLibraryClient<$Result.GetResult<Prisma.$BlockLibraryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlockLibrary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockLibraryFindFirstArgs} args - Arguments to find a BlockLibrary
     * @example
     * // Get one BlockLibrary
     * const blockLibrary = await prisma.blockLibrary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockLibraryFindFirstArgs>(args?: SelectSubset<T, BlockLibraryFindFirstArgs<ExtArgs>>): Prisma__BlockLibraryClient<$Result.GetResult<Prisma.$BlockLibraryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlockLibrary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockLibraryFindFirstOrThrowArgs} args - Arguments to find a BlockLibrary
     * @example
     * // Get one BlockLibrary
     * const blockLibrary = await prisma.blockLibrary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockLibraryFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockLibraryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockLibraryClient<$Result.GetResult<Prisma.$BlockLibraryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlockLibraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockLibraryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockLibraries
     * const blockLibraries = await prisma.blockLibrary.findMany()
     * 
     * // Get first 10 BlockLibraries
     * const blockLibraries = await prisma.blockLibrary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockLibraryWithIdOnly = await prisma.blockLibrary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockLibraryFindManyArgs>(args?: SelectSubset<T, BlockLibraryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockLibraryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlockLibrary.
     * @param {BlockLibraryCreateArgs} args - Arguments to create a BlockLibrary.
     * @example
     * // Create one BlockLibrary
     * const BlockLibrary = await prisma.blockLibrary.create({
     *   data: {
     *     // ... data to create a BlockLibrary
     *   }
     * })
     * 
     */
    create<T extends BlockLibraryCreateArgs>(args: SelectSubset<T, BlockLibraryCreateArgs<ExtArgs>>): Prisma__BlockLibraryClient<$Result.GetResult<Prisma.$BlockLibraryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlockLibraries.
     * @param {BlockLibraryCreateManyArgs} args - Arguments to create many BlockLibraries.
     * @example
     * // Create many BlockLibraries
     * const blockLibrary = await prisma.blockLibrary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockLibraryCreateManyArgs>(args?: SelectSubset<T, BlockLibraryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockLibraries and returns the data saved in the database.
     * @param {BlockLibraryCreateManyAndReturnArgs} args - Arguments to create many BlockLibraries.
     * @example
     * // Create many BlockLibraries
     * const blockLibrary = await prisma.blockLibrary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockLibraries and only return the `id`
     * const blockLibraryWithIdOnly = await prisma.blockLibrary.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockLibraryCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockLibraryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockLibraryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlockLibrary.
     * @param {BlockLibraryDeleteArgs} args - Arguments to delete one BlockLibrary.
     * @example
     * // Delete one BlockLibrary
     * const BlockLibrary = await prisma.blockLibrary.delete({
     *   where: {
     *     // ... filter to delete one BlockLibrary
     *   }
     * })
     * 
     */
    delete<T extends BlockLibraryDeleteArgs>(args: SelectSubset<T, BlockLibraryDeleteArgs<ExtArgs>>): Prisma__BlockLibraryClient<$Result.GetResult<Prisma.$BlockLibraryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlockLibrary.
     * @param {BlockLibraryUpdateArgs} args - Arguments to update one BlockLibrary.
     * @example
     * // Update one BlockLibrary
     * const blockLibrary = await prisma.blockLibrary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockLibraryUpdateArgs>(args: SelectSubset<T, BlockLibraryUpdateArgs<ExtArgs>>): Prisma__BlockLibraryClient<$Result.GetResult<Prisma.$BlockLibraryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlockLibraries.
     * @param {BlockLibraryDeleteManyArgs} args - Arguments to filter BlockLibraries to delete.
     * @example
     * // Delete a few BlockLibraries
     * const { count } = await prisma.blockLibrary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockLibraryDeleteManyArgs>(args?: SelectSubset<T, BlockLibraryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockLibraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockLibraryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockLibraries
     * const blockLibrary = await prisma.blockLibrary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockLibraryUpdateManyArgs>(args: SelectSubset<T, BlockLibraryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlockLibrary.
     * @param {BlockLibraryUpsertArgs} args - Arguments to update or create a BlockLibrary.
     * @example
     * // Update or create a BlockLibrary
     * const blockLibrary = await prisma.blockLibrary.upsert({
     *   create: {
     *     // ... data to create a BlockLibrary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockLibrary we want to update
     *   }
     * })
     */
    upsert<T extends BlockLibraryUpsertArgs>(args: SelectSubset<T, BlockLibraryUpsertArgs<ExtArgs>>): Prisma__BlockLibraryClient<$Result.GetResult<Prisma.$BlockLibraryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlockLibraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockLibraryCountArgs} args - Arguments to filter BlockLibraries to count.
     * @example
     * // Count the number of BlockLibraries
     * const count = await prisma.blockLibrary.count({
     *   where: {
     *     // ... the filter for the BlockLibraries we want to count
     *   }
     * })
    **/
    count<T extends BlockLibraryCountArgs>(
      args?: Subset<T, BlockLibraryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockLibraryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockLibrary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockLibraryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockLibraryAggregateArgs>(args: Subset<T, BlockLibraryAggregateArgs>): Prisma.PrismaPromise<GetBlockLibraryAggregateType<T>>

    /**
     * Group by BlockLibrary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockLibraryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockLibraryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockLibraryGroupByArgs['orderBy'] }
        : { orderBy?: BlockLibraryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockLibraryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockLibraryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockLibrary model
   */
  readonly fields: BlockLibraryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockLibrary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockLibraryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ratings<T extends BlockLibrary$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, BlockLibrary$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockLibraryRatingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockLibrary model
   */ 
  interface BlockLibraryFieldRefs {
    readonly id: FieldRef<"BlockLibrary", 'String'>
    readonly name: FieldRef<"BlockLibrary", 'String'>
    readonly description: FieldRef<"BlockLibrary", 'String'>
    readonly blockType: FieldRef<"BlockLibrary", 'String'>
    readonly category: FieldRef<"BlockLibrary", 'String'>
    readonly configuration: FieldRef<"BlockLibrary", 'Json'>
    readonly blockData: FieldRef<"BlockLibrary", 'Json'>
    readonly executionCode: FieldRef<"BlockLibrary", 'String'>
    readonly userId: FieldRef<"BlockLibrary", 'String'>
    readonly isPublic: FieldRef<"BlockLibrary", 'Boolean'>
    readonly isVerified: FieldRef<"BlockLibrary", 'Boolean'>
    readonly rating: FieldRef<"BlockLibrary", 'Float'>
    readonly usageCount: FieldRef<"BlockLibrary", 'Int'>
    readonly tags: FieldRef<"BlockLibrary", 'String[]'>
    readonly version: FieldRef<"BlockLibrary", 'String'>
    readonly createdAt: FieldRef<"BlockLibrary", 'DateTime'>
    readonly updatedAt: FieldRef<"BlockLibrary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlockLibrary findUnique
   */
  export type BlockLibraryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibrary
     */
    select?: BlockLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryInclude<ExtArgs> | null
    /**
     * Filter, which BlockLibrary to fetch.
     */
    where: BlockLibraryWhereUniqueInput
  }

  /**
   * BlockLibrary findUniqueOrThrow
   */
  export type BlockLibraryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibrary
     */
    select?: BlockLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryInclude<ExtArgs> | null
    /**
     * Filter, which BlockLibrary to fetch.
     */
    where: BlockLibraryWhereUniqueInput
  }

  /**
   * BlockLibrary findFirst
   */
  export type BlockLibraryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibrary
     */
    select?: BlockLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryInclude<ExtArgs> | null
    /**
     * Filter, which BlockLibrary to fetch.
     */
    where?: BlockLibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockLibraries to fetch.
     */
    orderBy?: BlockLibraryOrderByWithRelationInput | BlockLibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockLibraries.
     */
    cursor?: BlockLibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockLibraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockLibraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockLibraries.
     */
    distinct?: BlockLibraryScalarFieldEnum | BlockLibraryScalarFieldEnum[]
  }

  /**
   * BlockLibrary findFirstOrThrow
   */
  export type BlockLibraryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibrary
     */
    select?: BlockLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryInclude<ExtArgs> | null
    /**
     * Filter, which BlockLibrary to fetch.
     */
    where?: BlockLibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockLibraries to fetch.
     */
    orderBy?: BlockLibraryOrderByWithRelationInput | BlockLibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockLibraries.
     */
    cursor?: BlockLibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockLibraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockLibraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockLibraries.
     */
    distinct?: BlockLibraryScalarFieldEnum | BlockLibraryScalarFieldEnum[]
  }

  /**
   * BlockLibrary findMany
   */
  export type BlockLibraryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibrary
     */
    select?: BlockLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryInclude<ExtArgs> | null
    /**
     * Filter, which BlockLibraries to fetch.
     */
    where?: BlockLibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockLibraries to fetch.
     */
    orderBy?: BlockLibraryOrderByWithRelationInput | BlockLibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockLibraries.
     */
    cursor?: BlockLibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockLibraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockLibraries.
     */
    skip?: number
    distinct?: BlockLibraryScalarFieldEnum | BlockLibraryScalarFieldEnum[]
  }

  /**
   * BlockLibrary create
   */
  export type BlockLibraryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibrary
     */
    select?: BlockLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockLibrary.
     */
    data: XOR<BlockLibraryCreateInput, BlockLibraryUncheckedCreateInput>
  }

  /**
   * BlockLibrary createMany
   */
  export type BlockLibraryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockLibraries.
     */
    data: BlockLibraryCreateManyInput | BlockLibraryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockLibrary createManyAndReturn
   */
  export type BlockLibraryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibrary
     */
    select?: BlockLibrarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlockLibraries.
     */
    data: BlockLibraryCreateManyInput | BlockLibraryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockLibrary update
   */
  export type BlockLibraryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibrary
     */
    select?: BlockLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockLibrary.
     */
    data: XOR<BlockLibraryUpdateInput, BlockLibraryUncheckedUpdateInput>
    /**
     * Choose, which BlockLibrary to update.
     */
    where: BlockLibraryWhereUniqueInput
  }

  /**
   * BlockLibrary updateMany
   */
  export type BlockLibraryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockLibraries.
     */
    data: XOR<BlockLibraryUpdateManyMutationInput, BlockLibraryUncheckedUpdateManyInput>
    /**
     * Filter which BlockLibraries to update
     */
    where?: BlockLibraryWhereInput
  }

  /**
   * BlockLibrary upsert
   */
  export type BlockLibraryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibrary
     */
    select?: BlockLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockLibrary to update in case it exists.
     */
    where: BlockLibraryWhereUniqueInput
    /**
     * In case the BlockLibrary found by the `where` argument doesn't exist, create a new BlockLibrary with this data.
     */
    create: XOR<BlockLibraryCreateInput, BlockLibraryUncheckedCreateInput>
    /**
     * In case the BlockLibrary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockLibraryUpdateInput, BlockLibraryUncheckedUpdateInput>
  }

  /**
   * BlockLibrary delete
   */
  export type BlockLibraryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibrary
     */
    select?: BlockLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryInclude<ExtArgs> | null
    /**
     * Filter which BlockLibrary to delete.
     */
    where: BlockLibraryWhereUniqueInput
  }

  /**
   * BlockLibrary deleteMany
   */
  export type BlockLibraryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockLibraries to delete
     */
    where?: BlockLibraryWhereInput
  }

  /**
   * BlockLibrary.ratings
   */
  export type BlockLibrary$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibraryRating
     */
    select?: BlockLibraryRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryRatingInclude<ExtArgs> | null
    where?: BlockLibraryRatingWhereInput
    orderBy?: BlockLibraryRatingOrderByWithRelationInput | BlockLibraryRatingOrderByWithRelationInput[]
    cursor?: BlockLibraryRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockLibraryRatingScalarFieldEnum | BlockLibraryRatingScalarFieldEnum[]
  }

  /**
   * BlockLibrary without action
   */
  export type BlockLibraryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibrary
     */
    select?: BlockLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryInclude<ExtArgs> | null
  }


  /**
   * Model BlockLibraryRating
   */

  export type AggregateBlockLibraryRating = {
    _count: BlockLibraryRatingCountAggregateOutputType | null
    _avg: BlockLibraryRatingAvgAggregateOutputType | null
    _sum: BlockLibraryRatingSumAggregateOutputType | null
    _min: BlockLibraryRatingMinAggregateOutputType | null
    _max: BlockLibraryRatingMaxAggregateOutputType | null
  }

  export type BlockLibraryRatingAvgAggregateOutputType = {
    rating: number | null
  }

  export type BlockLibraryRatingSumAggregateOutputType = {
    rating: number | null
  }

  export type BlockLibraryRatingMinAggregateOutputType = {
    id: string | null
    blockId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type BlockLibraryRatingMaxAggregateOutputType = {
    id: string | null
    blockId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type BlockLibraryRatingCountAggregateOutputType = {
    id: number
    blockId: number
    userId: number
    rating: number
    comment: number
    createdAt: number
    _all: number
  }


  export type BlockLibraryRatingAvgAggregateInputType = {
    rating?: true
  }

  export type BlockLibraryRatingSumAggregateInputType = {
    rating?: true
  }

  export type BlockLibraryRatingMinAggregateInputType = {
    id?: true
    blockId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type BlockLibraryRatingMaxAggregateInputType = {
    id?: true
    blockId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type BlockLibraryRatingCountAggregateInputType = {
    id?: true
    blockId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type BlockLibraryRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockLibraryRating to aggregate.
     */
    where?: BlockLibraryRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockLibraryRatings to fetch.
     */
    orderBy?: BlockLibraryRatingOrderByWithRelationInput | BlockLibraryRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockLibraryRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockLibraryRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockLibraryRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockLibraryRatings
    **/
    _count?: true | BlockLibraryRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockLibraryRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockLibraryRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockLibraryRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockLibraryRatingMaxAggregateInputType
  }

  export type GetBlockLibraryRatingAggregateType<T extends BlockLibraryRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockLibraryRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockLibraryRating[P]>
      : GetScalarType<T[P], AggregateBlockLibraryRating[P]>
  }




  export type BlockLibraryRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockLibraryRatingWhereInput
    orderBy?: BlockLibraryRatingOrderByWithAggregationInput | BlockLibraryRatingOrderByWithAggregationInput[]
    by: BlockLibraryRatingScalarFieldEnum[] | BlockLibraryRatingScalarFieldEnum
    having?: BlockLibraryRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockLibraryRatingCountAggregateInputType | true
    _avg?: BlockLibraryRatingAvgAggregateInputType
    _sum?: BlockLibraryRatingSumAggregateInputType
    _min?: BlockLibraryRatingMinAggregateInputType
    _max?: BlockLibraryRatingMaxAggregateInputType
  }

  export type BlockLibraryRatingGroupByOutputType = {
    id: string
    blockId: string
    userId: string
    rating: number
    comment: string | null
    createdAt: Date
    _count: BlockLibraryRatingCountAggregateOutputType | null
    _avg: BlockLibraryRatingAvgAggregateOutputType | null
    _sum: BlockLibraryRatingSumAggregateOutputType | null
    _min: BlockLibraryRatingMinAggregateOutputType | null
    _max: BlockLibraryRatingMaxAggregateOutputType | null
  }

  type GetBlockLibraryRatingGroupByPayload<T extends BlockLibraryRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockLibraryRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockLibraryRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockLibraryRatingGroupByOutputType[P]>
            : GetScalarType<T[P], BlockLibraryRatingGroupByOutputType[P]>
        }
      >
    >


  export type BlockLibraryRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    block?: boolean | BlockLibraryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockLibraryRating"]>

  export type BlockLibraryRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    block?: boolean | BlockLibraryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockLibraryRating"]>

  export type BlockLibraryRatingSelectScalar = {
    id?: boolean
    blockId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type BlockLibraryRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    block?: boolean | BlockLibraryDefaultArgs<ExtArgs>
  }
  export type BlockLibraryRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    block?: boolean | BlockLibraryDefaultArgs<ExtArgs>
  }

  export type $BlockLibraryRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockLibraryRating"
    objects: {
      block: Prisma.$BlockLibraryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      blockId: string
      userId: string
      rating: number
      comment: string | null
      createdAt: Date
    }, ExtArgs["result"]["blockLibraryRating"]>
    composites: {}
  }

  type BlockLibraryRatingGetPayload<S extends boolean | null | undefined | BlockLibraryRatingDefaultArgs> = $Result.GetResult<Prisma.$BlockLibraryRatingPayload, S>

  type BlockLibraryRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlockLibraryRatingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlockLibraryRatingCountAggregateInputType | true
    }

  export interface BlockLibraryRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockLibraryRating'], meta: { name: 'BlockLibraryRating' } }
    /**
     * Find zero or one BlockLibraryRating that matches the filter.
     * @param {BlockLibraryRatingFindUniqueArgs} args - Arguments to find a BlockLibraryRating
     * @example
     * // Get one BlockLibraryRating
     * const blockLibraryRating = await prisma.blockLibraryRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockLibraryRatingFindUniqueArgs>(args: SelectSubset<T, BlockLibraryRatingFindUniqueArgs<ExtArgs>>): Prisma__BlockLibraryRatingClient<$Result.GetResult<Prisma.$BlockLibraryRatingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlockLibraryRating that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlockLibraryRatingFindUniqueOrThrowArgs} args - Arguments to find a BlockLibraryRating
     * @example
     * // Get one BlockLibraryRating
     * const blockLibraryRating = await prisma.blockLibraryRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockLibraryRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockLibraryRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockLibraryRatingClient<$Result.GetResult<Prisma.$BlockLibraryRatingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlockLibraryRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockLibraryRatingFindFirstArgs} args - Arguments to find a BlockLibraryRating
     * @example
     * // Get one BlockLibraryRating
     * const blockLibraryRating = await prisma.blockLibraryRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockLibraryRatingFindFirstArgs>(args?: SelectSubset<T, BlockLibraryRatingFindFirstArgs<ExtArgs>>): Prisma__BlockLibraryRatingClient<$Result.GetResult<Prisma.$BlockLibraryRatingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlockLibraryRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockLibraryRatingFindFirstOrThrowArgs} args - Arguments to find a BlockLibraryRating
     * @example
     * // Get one BlockLibraryRating
     * const blockLibraryRating = await prisma.blockLibraryRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockLibraryRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockLibraryRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockLibraryRatingClient<$Result.GetResult<Prisma.$BlockLibraryRatingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlockLibraryRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockLibraryRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockLibraryRatings
     * const blockLibraryRatings = await prisma.blockLibraryRating.findMany()
     * 
     * // Get first 10 BlockLibraryRatings
     * const blockLibraryRatings = await prisma.blockLibraryRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockLibraryRatingWithIdOnly = await prisma.blockLibraryRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockLibraryRatingFindManyArgs>(args?: SelectSubset<T, BlockLibraryRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockLibraryRatingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlockLibraryRating.
     * @param {BlockLibraryRatingCreateArgs} args - Arguments to create a BlockLibraryRating.
     * @example
     * // Create one BlockLibraryRating
     * const BlockLibraryRating = await prisma.blockLibraryRating.create({
     *   data: {
     *     // ... data to create a BlockLibraryRating
     *   }
     * })
     * 
     */
    create<T extends BlockLibraryRatingCreateArgs>(args: SelectSubset<T, BlockLibraryRatingCreateArgs<ExtArgs>>): Prisma__BlockLibraryRatingClient<$Result.GetResult<Prisma.$BlockLibraryRatingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlockLibraryRatings.
     * @param {BlockLibraryRatingCreateManyArgs} args - Arguments to create many BlockLibraryRatings.
     * @example
     * // Create many BlockLibraryRatings
     * const blockLibraryRating = await prisma.blockLibraryRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockLibraryRatingCreateManyArgs>(args?: SelectSubset<T, BlockLibraryRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockLibraryRatings and returns the data saved in the database.
     * @param {BlockLibraryRatingCreateManyAndReturnArgs} args - Arguments to create many BlockLibraryRatings.
     * @example
     * // Create many BlockLibraryRatings
     * const blockLibraryRating = await prisma.blockLibraryRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockLibraryRatings and only return the `id`
     * const blockLibraryRatingWithIdOnly = await prisma.blockLibraryRating.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockLibraryRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockLibraryRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockLibraryRatingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlockLibraryRating.
     * @param {BlockLibraryRatingDeleteArgs} args - Arguments to delete one BlockLibraryRating.
     * @example
     * // Delete one BlockLibraryRating
     * const BlockLibraryRating = await prisma.blockLibraryRating.delete({
     *   where: {
     *     // ... filter to delete one BlockLibraryRating
     *   }
     * })
     * 
     */
    delete<T extends BlockLibraryRatingDeleteArgs>(args: SelectSubset<T, BlockLibraryRatingDeleteArgs<ExtArgs>>): Prisma__BlockLibraryRatingClient<$Result.GetResult<Prisma.$BlockLibraryRatingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlockLibraryRating.
     * @param {BlockLibraryRatingUpdateArgs} args - Arguments to update one BlockLibraryRating.
     * @example
     * // Update one BlockLibraryRating
     * const blockLibraryRating = await prisma.blockLibraryRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockLibraryRatingUpdateArgs>(args: SelectSubset<T, BlockLibraryRatingUpdateArgs<ExtArgs>>): Prisma__BlockLibraryRatingClient<$Result.GetResult<Prisma.$BlockLibraryRatingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlockLibraryRatings.
     * @param {BlockLibraryRatingDeleteManyArgs} args - Arguments to filter BlockLibraryRatings to delete.
     * @example
     * // Delete a few BlockLibraryRatings
     * const { count } = await prisma.blockLibraryRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockLibraryRatingDeleteManyArgs>(args?: SelectSubset<T, BlockLibraryRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockLibraryRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockLibraryRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockLibraryRatings
     * const blockLibraryRating = await prisma.blockLibraryRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockLibraryRatingUpdateManyArgs>(args: SelectSubset<T, BlockLibraryRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlockLibraryRating.
     * @param {BlockLibraryRatingUpsertArgs} args - Arguments to update or create a BlockLibraryRating.
     * @example
     * // Update or create a BlockLibraryRating
     * const blockLibraryRating = await prisma.blockLibraryRating.upsert({
     *   create: {
     *     // ... data to create a BlockLibraryRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockLibraryRating we want to update
     *   }
     * })
     */
    upsert<T extends BlockLibraryRatingUpsertArgs>(args: SelectSubset<T, BlockLibraryRatingUpsertArgs<ExtArgs>>): Prisma__BlockLibraryRatingClient<$Result.GetResult<Prisma.$BlockLibraryRatingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlockLibraryRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockLibraryRatingCountArgs} args - Arguments to filter BlockLibraryRatings to count.
     * @example
     * // Count the number of BlockLibraryRatings
     * const count = await prisma.blockLibraryRating.count({
     *   where: {
     *     // ... the filter for the BlockLibraryRatings we want to count
     *   }
     * })
    **/
    count<T extends BlockLibraryRatingCountArgs>(
      args?: Subset<T, BlockLibraryRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockLibraryRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockLibraryRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockLibraryRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockLibraryRatingAggregateArgs>(args: Subset<T, BlockLibraryRatingAggregateArgs>): Prisma.PrismaPromise<GetBlockLibraryRatingAggregateType<T>>

    /**
     * Group by BlockLibraryRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockLibraryRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockLibraryRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockLibraryRatingGroupByArgs['orderBy'] }
        : { orderBy?: BlockLibraryRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockLibraryRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockLibraryRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockLibraryRating model
   */
  readonly fields: BlockLibraryRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockLibraryRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockLibraryRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    block<T extends BlockLibraryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlockLibraryDefaultArgs<ExtArgs>>): Prisma__BlockLibraryClient<$Result.GetResult<Prisma.$BlockLibraryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockLibraryRating model
   */ 
  interface BlockLibraryRatingFieldRefs {
    readonly id: FieldRef<"BlockLibraryRating", 'String'>
    readonly blockId: FieldRef<"BlockLibraryRating", 'String'>
    readonly userId: FieldRef<"BlockLibraryRating", 'String'>
    readonly rating: FieldRef<"BlockLibraryRating", 'Int'>
    readonly comment: FieldRef<"BlockLibraryRating", 'String'>
    readonly createdAt: FieldRef<"BlockLibraryRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlockLibraryRating findUnique
   */
  export type BlockLibraryRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibraryRating
     */
    select?: BlockLibraryRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryRatingInclude<ExtArgs> | null
    /**
     * Filter, which BlockLibraryRating to fetch.
     */
    where: BlockLibraryRatingWhereUniqueInput
  }

  /**
   * BlockLibraryRating findUniqueOrThrow
   */
  export type BlockLibraryRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibraryRating
     */
    select?: BlockLibraryRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryRatingInclude<ExtArgs> | null
    /**
     * Filter, which BlockLibraryRating to fetch.
     */
    where: BlockLibraryRatingWhereUniqueInput
  }

  /**
   * BlockLibraryRating findFirst
   */
  export type BlockLibraryRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibraryRating
     */
    select?: BlockLibraryRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryRatingInclude<ExtArgs> | null
    /**
     * Filter, which BlockLibraryRating to fetch.
     */
    where?: BlockLibraryRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockLibraryRatings to fetch.
     */
    orderBy?: BlockLibraryRatingOrderByWithRelationInput | BlockLibraryRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockLibraryRatings.
     */
    cursor?: BlockLibraryRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockLibraryRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockLibraryRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockLibraryRatings.
     */
    distinct?: BlockLibraryRatingScalarFieldEnum | BlockLibraryRatingScalarFieldEnum[]
  }

  /**
   * BlockLibraryRating findFirstOrThrow
   */
  export type BlockLibraryRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibraryRating
     */
    select?: BlockLibraryRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryRatingInclude<ExtArgs> | null
    /**
     * Filter, which BlockLibraryRating to fetch.
     */
    where?: BlockLibraryRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockLibraryRatings to fetch.
     */
    orderBy?: BlockLibraryRatingOrderByWithRelationInput | BlockLibraryRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockLibraryRatings.
     */
    cursor?: BlockLibraryRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockLibraryRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockLibraryRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockLibraryRatings.
     */
    distinct?: BlockLibraryRatingScalarFieldEnum | BlockLibraryRatingScalarFieldEnum[]
  }

  /**
   * BlockLibraryRating findMany
   */
  export type BlockLibraryRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibraryRating
     */
    select?: BlockLibraryRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryRatingInclude<ExtArgs> | null
    /**
     * Filter, which BlockLibraryRatings to fetch.
     */
    where?: BlockLibraryRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockLibraryRatings to fetch.
     */
    orderBy?: BlockLibraryRatingOrderByWithRelationInput | BlockLibraryRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockLibraryRatings.
     */
    cursor?: BlockLibraryRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockLibraryRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockLibraryRatings.
     */
    skip?: number
    distinct?: BlockLibraryRatingScalarFieldEnum | BlockLibraryRatingScalarFieldEnum[]
  }

  /**
   * BlockLibraryRating create
   */
  export type BlockLibraryRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibraryRating
     */
    select?: BlockLibraryRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockLibraryRating.
     */
    data: XOR<BlockLibraryRatingCreateInput, BlockLibraryRatingUncheckedCreateInput>
  }

  /**
   * BlockLibraryRating createMany
   */
  export type BlockLibraryRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockLibraryRatings.
     */
    data: BlockLibraryRatingCreateManyInput | BlockLibraryRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockLibraryRating createManyAndReturn
   */
  export type BlockLibraryRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibraryRating
     */
    select?: BlockLibraryRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlockLibraryRatings.
     */
    data: BlockLibraryRatingCreateManyInput | BlockLibraryRatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockLibraryRating update
   */
  export type BlockLibraryRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibraryRating
     */
    select?: BlockLibraryRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockLibraryRating.
     */
    data: XOR<BlockLibraryRatingUpdateInput, BlockLibraryRatingUncheckedUpdateInput>
    /**
     * Choose, which BlockLibraryRating to update.
     */
    where: BlockLibraryRatingWhereUniqueInput
  }

  /**
   * BlockLibraryRating updateMany
   */
  export type BlockLibraryRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockLibraryRatings.
     */
    data: XOR<BlockLibraryRatingUpdateManyMutationInput, BlockLibraryRatingUncheckedUpdateManyInput>
    /**
     * Filter which BlockLibraryRatings to update
     */
    where?: BlockLibraryRatingWhereInput
  }

  /**
   * BlockLibraryRating upsert
   */
  export type BlockLibraryRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibraryRating
     */
    select?: BlockLibraryRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockLibraryRating to update in case it exists.
     */
    where: BlockLibraryRatingWhereUniqueInput
    /**
     * In case the BlockLibraryRating found by the `where` argument doesn't exist, create a new BlockLibraryRating with this data.
     */
    create: XOR<BlockLibraryRatingCreateInput, BlockLibraryRatingUncheckedCreateInput>
    /**
     * In case the BlockLibraryRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockLibraryRatingUpdateInput, BlockLibraryRatingUncheckedUpdateInput>
  }

  /**
   * BlockLibraryRating delete
   */
  export type BlockLibraryRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibraryRating
     */
    select?: BlockLibraryRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryRatingInclude<ExtArgs> | null
    /**
     * Filter which BlockLibraryRating to delete.
     */
    where: BlockLibraryRatingWhereUniqueInput
  }

  /**
   * BlockLibraryRating deleteMany
   */
  export type BlockLibraryRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockLibraryRatings to delete
     */
    where?: BlockLibraryRatingWhereInput
  }

  /**
   * BlockLibraryRating without action
   */
  export type BlockLibraryRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockLibraryRating
     */
    select?: BlockLibraryRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockLibraryRatingInclude<ExtArgs> | null
  }


  /**
   * Model CustomBlock
   */

  export type AggregateCustomBlock = {
    _count: CustomBlockCountAggregateOutputType | null
    _avg: CustomBlockAvgAggregateOutputType | null
    _sum: CustomBlockSumAggregateOutputType | null
    _min: CustomBlockMinAggregateOutputType | null
    _max: CustomBlockMaxAggregateOutputType | null
  }

  export type CustomBlockAvgAggregateOutputType = {
    rating: number | null
    usageCount: number | null
  }

  export type CustomBlockSumAggregateOutputType = {
    rating: number | null
    usageCount: number | null
  }

  export type CustomBlockMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    blockType: string | null
    category: string | null
    code: string | null
    logic: string | null
    logicType: string | null
    createdBy: string | null
    icon: string | null
    isPublic: boolean | null
    isVerified: boolean | null
    rating: number | null
    usageCount: number | null
    version: string | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type CustomBlockMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    blockType: string | null
    category: string | null
    code: string | null
    logic: string | null
    logicType: string | null
    createdBy: string | null
    icon: string | null
    isPublic: boolean | null
    isVerified: boolean | null
    rating: number | null
    usageCount: number | null
    version: string | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type CustomBlockCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    blockType: number
    category: number
    code: number
    logic: number
    logicType: number
    blockData: number
    tags: number
    createdBy: number
    icon: number
    isPublic: number
    isVerified: number
    rating: number
    usageCount: number
    version: number
    createdAt: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type CustomBlockAvgAggregateInputType = {
    rating?: true
    usageCount?: true
  }

  export type CustomBlockSumAggregateInputType = {
    rating?: true
    usageCount?: true
  }

  export type CustomBlockMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    blockType?: true
    category?: true
    code?: true
    logic?: true
    logicType?: true
    createdBy?: true
    icon?: true
    isPublic?: true
    isVerified?: true
    rating?: true
    usageCount?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type CustomBlockMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    blockType?: true
    category?: true
    code?: true
    logic?: true
    logicType?: true
    createdBy?: true
    icon?: true
    isPublic?: true
    isVerified?: true
    rating?: true
    usageCount?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type CustomBlockCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    blockType?: true
    category?: true
    code?: true
    logic?: true
    logicType?: true
    blockData?: true
    tags?: true
    createdBy?: true
    icon?: true
    isPublic?: true
    isVerified?: true
    rating?: true
    usageCount?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type CustomBlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomBlock to aggregate.
     */
    where?: CustomBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomBlocks to fetch.
     */
    orderBy?: CustomBlockOrderByWithRelationInput | CustomBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomBlocks
    **/
    _count?: true | CustomBlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomBlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomBlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomBlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomBlockMaxAggregateInputType
  }

  export type GetCustomBlockAggregateType<T extends CustomBlockAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomBlock[P]>
      : GetScalarType<T[P], AggregateCustomBlock[P]>
  }




  export type CustomBlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomBlockWhereInput
    orderBy?: CustomBlockOrderByWithAggregationInput | CustomBlockOrderByWithAggregationInput[]
    by: CustomBlockScalarFieldEnum[] | CustomBlockScalarFieldEnum
    having?: CustomBlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomBlockCountAggregateInputType | true
    _avg?: CustomBlockAvgAggregateInputType
    _sum?: CustomBlockSumAggregateInputType
    _min?: CustomBlockMinAggregateInputType
    _max?: CustomBlockMaxAggregateInputType
  }

  export type CustomBlockGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string | null
    blockType: string | null
    category: string
    code: string
    logic: string
    logicType: string
    blockData: JsonValue | null
    tags: JsonValue
    createdBy: string | null
    icon: string | null
    isPublic: boolean | null
    isVerified: boolean | null
    rating: number | null
    usageCount: number | null
    version: string | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    _count: CustomBlockCountAggregateOutputType | null
    _avg: CustomBlockAvgAggregateOutputType | null
    _sum: CustomBlockSumAggregateOutputType | null
    _min: CustomBlockMinAggregateOutputType | null
    _max: CustomBlockMaxAggregateOutputType | null
  }

  type GetCustomBlockGroupByPayload<T extends CustomBlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomBlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomBlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomBlockGroupByOutputType[P]>
            : GetScalarType<T[P], CustomBlockGroupByOutputType[P]>
        }
      >
    >


  export type CustomBlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    blockType?: boolean
    category?: boolean
    code?: boolean
    logic?: boolean
    logicType?: boolean
    blockData?: boolean
    tags?: boolean
    createdBy?: boolean
    icon?: boolean
    isPublic?: boolean
    isVerified?: boolean
    rating?: boolean
    usageCount?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["customBlock"]>

  export type CustomBlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    blockType?: boolean
    category?: boolean
    code?: boolean
    logic?: boolean
    logicType?: boolean
    blockData?: boolean
    tags?: boolean
    createdBy?: boolean
    icon?: boolean
    isPublic?: boolean
    isVerified?: boolean
    rating?: boolean
    usageCount?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["customBlock"]>

  export type CustomBlockSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    blockType?: boolean
    category?: boolean
    code?: boolean
    logic?: boolean
    logicType?: boolean
    blockData?: boolean
    tags?: boolean
    createdBy?: boolean
    icon?: boolean
    isPublic?: boolean
    isVerified?: boolean
    rating?: boolean
    usageCount?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $CustomBlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomBlock"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string | null
      blockType: string | null
      category: string
      code: string
      logic: string
      logicType: string
      blockData: Prisma.JsonValue | null
      tags: Prisma.JsonValue
      createdBy: string | null
      icon: string | null
      isPublic: boolean | null
      isVerified: boolean | null
      rating: number | null
      usageCount: number | null
      version: string | null
      createdAt: Date | null
      updatedAt: Date | null
      updatedBy: string | null
    }, ExtArgs["result"]["customBlock"]>
    composites: {}
  }

  type CustomBlockGetPayload<S extends boolean | null | undefined | CustomBlockDefaultArgs> = $Result.GetResult<Prisma.$CustomBlockPayload, S>

  type CustomBlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomBlockFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomBlockCountAggregateInputType | true
    }

  export interface CustomBlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomBlock'], meta: { name: 'CustomBlock' } }
    /**
     * Find zero or one CustomBlock that matches the filter.
     * @param {CustomBlockFindUniqueArgs} args - Arguments to find a CustomBlock
     * @example
     * // Get one CustomBlock
     * const customBlock = await prisma.customBlock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomBlockFindUniqueArgs>(args: SelectSubset<T, CustomBlockFindUniqueArgs<ExtArgs>>): Prisma__CustomBlockClient<$Result.GetResult<Prisma.$CustomBlockPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomBlock that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomBlockFindUniqueOrThrowArgs} args - Arguments to find a CustomBlock
     * @example
     * // Get one CustomBlock
     * const customBlock = await prisma.customBlock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomBlockFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomBlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomBlockClient<$Result.GetResult<Prisma.$CustomBlockPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomBlock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomBlockFindFirstArgs} args - Arguments to find a CustomBlock
     * @example
     * // Get one CustomBlock
     * const customBlock = await prisma.customBlock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomBlockFindFirstArgs>(args?: SelectSubset<T, CustomBlockFindFirstArgs<ExtArgs>>): Prisma__CustomBlockClient<$Result.GetResult<Prisma.$CustomBlockPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomBlock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomBlockFindFirstOrThrowArgs} args - Arguments to find a CustomBlock
     * @example
     * // Get one CustomBlock
     * const customBlock = await prisma.customBlock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomBlockFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomBlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomBlockClient<$Result.GetResult<Prisma.$CustomBlockPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomBlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomBlocks
     * const customBlocks = await prisma.customBlock.findMany()
     * 
     * // Get first 10 CustomBlocks
     * const customBlocks = await prisma.customBlock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customBlockWithIdOnly = await prisma.customBlock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomBlockFindManyArgs>(args?: SelectSubset<T, CustomBlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomBlockPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomBlock.
     * @param {CustomBlockCreateArgs} args - Arguments to create a CustomBlock.
     * @example
     * // Create one CustomBlock
     * const CustomBlock = await prisma.customBlock.create({
     *   data: {
     *     // ... data to create a CustomBlock
     *   }
     * })
     * 
     */
    create<T extends CustomBlockCreateArgs>(args: SelectSubset<T, CustomBlockCreateArgs<ExtArgs>>): Prisma__CustomBlockClient<$Result.GetResult<Prisma.$CustomBlockPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomBlocks.
     * @param {CustomBlockCreateManyArgs} args - Arguments to create many CustomBlocks.
     * @example
     * // Create many CustomBlocks
     * const customBlock = await prisma.customBlock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomBlockCreateManyArgs>(args?: SelectSubset<T, CustomBlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomBlocks and returns the data saved in the database.
     * @param {CustomBlockCreateManyAndReturnArgs} args - Arguments to create many CustomBlocks.
     * @example
     * // Create many CustomBlocks
     * const customBlock = await prisma.customBlock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomBlocks and only return the `id`
     * const customBlockWithIdOnly = await prisma.customBlock.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomBlockCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomBlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomBlockPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomBlock.
     * @param {CustomBlockDeleteArgs} args - Arguments to delete one CustomBlock.
     * @example
     * // Delete one CustomBlock
     * const CustomBlock = await prisma.customBlock.delete({
     *   where: {
     *     // ... filter to delete one CustomBlock
     *   }
     * })
     * 
     */
    delete<T extends CustomBlockDeleteArgs>(args: SelectSubset<T, CustomBlockDeleteArgs<ExtArgs>>): Prisma__CustomBlockClient<$Result.GetResult<Prisma.$CustomBlockPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomBlock.
     * @param {CustomBlockUpdateArgs} args - Arguments to update one CustomBlock.
     * @example
     * // Update one CustomBlock
     * const customBlock = await prisma.customBlock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomBlockUpdateArgs>(args: SelectSubset<T, CustomBlockUpdateArgs<ExtArgs>>): Prisma__CustomBlockClient<$Result.GetResult<Prisma.$CustomBlockPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomBlocks.
     * @param {CustomBlockDeleteManyArgs} args - Arguments to filter CustomBlocks to delete.
     * @example
     * // Delete a few CustomBlocks
     * const { count } = await prisma.customBlock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomBlockDeleteManyArgs>(args?: SelectSubset<T, CustomBlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomBlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomBlocks
     * const customBlock = await prisma.customBlock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomBlockUpdateManyArgs>(args: SelectSubset<T, CustomBlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomBlock.
     * @param {CustomBlockUpsertArgs} args - Arguments to update or create a CustomBlock.
     * @example
     * // Update or create a CustomBlock
     * const customBlock = await prisma.customBlock.upsert({
     *   create: {
     *     // ... data to create a CustomBlock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomBlock we want to update
     *   }
     * })
     */
    upsert<T extends CustomBlockUpsertArgs>(args: SelectSubset<T, CustomBlockUpsertArgs<ExtArgs>>): Prisma__CustomBlockClient<$Result.GetResult<Prisma.$CustomBlockPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomBlockCountArgs} args - Arguments to filter CustomBlocks to count.
     * @example
     * // Count the number of CustomBlocks
     * const count = await prisma.customBlock.count({
     *   where: {
     *     // ... the filter for the CustomBlocks we want to count
     *   }
     * })
    **/
    count<T extends CustomBlockCountArgs>(
      args?: Subset<T, CustomBlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomBlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomBlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomBlockAggregateArgs>(args: Subset<T, CustomBlockAggregateArgs>): Prisma.PrismaPromise<GetCustomBlockAggregateType<T>>

    /**
     * Group by CustomBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomBlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomBlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomBlockGroupByArgs['orderBy'] }
        : { orderBy?: CustomBlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomBlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomBlock model
   */
  readonly fields: CustomBlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomBlock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomBlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomBlock model
   */ 
  interface CustomBlockFieldRefs {
    readonly id: FieldRef<"CustomBlock", 'String'>
    readonly userId: FieldRef<"CustomBlock", 'String'>
    readonly name: FieldRef<"CustomBlock", 'String'>
    readonly description: FieldRef<"CustomBlock", 'String'>
    readonly blockType: FieldRef<"CustomBlock", 'String'>
    readonly category: FieldRef<"CustomBlock", 'String'>
    readonly code: FieldRef<"CustomBlock", 'String'>
    readonly logic: FieldRef<"CustomBlock", 'String'>
    readonly logicType: FieldRef<"CustomBlock", 'String'>
    readonly blockData: FieldRef<"CustomBlock", 'Json'>
    readonly tags: FieldRef<"CustomBlock", 'Json'>
    readonly createdBy: FieldRef<"CustomBlock", 'String'>
    readonly icon: FieldRef<"CustomBlock", 'String'>
    readonly isPublic: FieldRef<"CustomBlock", 'Boolean'>
    readonly isVerified: FieldRef<"CustomBlock", 'Boolean'>
    readonly rating: FieldRef<"CustomBlock", 'Float'>
    readonly usageCount: FieldRef<"CustomBlock", 'Int'>
    readonly version: FieldRef<"CustomBlock", 'String'>
    readonly createdAt: FieldRef<"CustomBlock", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomBlock", 'DateTime'>
    readonly updatedBy: FieldRef<"CustomBlock", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CustomBlock findUnique
   */
  export type CustomBlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomBlock
     */
    select?: CustomBlockSelect<ExtArgs> | null
    /**
     * Filter, which CustomBlock to fetch.
     */
    where: CustomBlockWhereUniqueInput
  }

  /**
   * CustomBlock findUniqueOrThrow
   */
  export type CustomBlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomBlock
     */
    select?: CustomBlockSelect<ExtArgs> | null
    /**
     * Filter, which CustomBlock to fetch.
     */
    where: CustomBlockWhereUniqueInput
  }

  /**
   * CustomBlock findFirst
   */
  export type CustomBlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomBlock
     */
    select?: CustomBlockSelect<ExtArgs> | null
    /**
     * Filter, which CustomBlock to fetch.
     */
    where?: CustomBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomBlocks to fetch.
     */
    orderBy?: CustomBlockOrderByWithRelationInput | CustomBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomBlocks.
     */
    cursor?: CustomBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomBlocks.
     */
    distinct?: CustomBlockScalarFieldEnum | CustomBlockScalarFieldEnum[]
  }

  /**
   * CustomBlock findFirstOrThrow
   */
  export type CustomBlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomBlock
     */
    select?: CustomBlockSelect<ExtArgs> | null
    /**
     * Filter, which CustomBlock to fetch.
     */
    where?: CustomBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomBlocks to fetch.
     */
    orderBy?: CustomBlockOrderByWithRelationInput | CustomBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomBlocks.
     */
    cursor?: CustomBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomBlocks.
     */
    distinct?: CustomBlockScalarFieldEnum | CustomBlockScalarFieldEnum[]
  }

  /**
   * CustomBlock findMany
   */
  export type CustomBlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomBlock
     */
    select?: CustomBlockSelect<ExtArgs> | null
    /**
     * Filter, which CustomBlocks to fetch.
     */
    where?: CustomBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomBlocks to fetch.
     */
    orderBy?: CustomBlockOrderByWithRelationInput | CustomBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomBlocks.
     */
    cursor?: CustomBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomBlocks.
     */
    skip?: number
    distinct?: CustomBlockScalarFieldEnum | CustomBlockScalarFieldEnum[]
  }

  /**
   * CustomBlock create
   */
  export type CustomBlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomBlock
     */
    select?: CustomBlockSelect<ExtArgs> | null
    /**
     * The data needed to create a CustomBlock.
     */
    data: XOR<CustomBlockCreateInput, CustomBlockUncheckedCreateInput>
  }

  /**
   * CustomBlock createMany
   */
  export type CustomBlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomBlocks.
     */
    data: CustomBlockCreateManyInput | CustomBlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomBlock createManyAndReturn
   */
  export type CustomBlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomBlock
     */
    select?: CustomBlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomBlocks.
     */
    data: CustomBlockCreateManyInput | CustomBlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomBlock update
   */
  export type CustomBlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomBlock
     */
    select?: CustomBlockSelect<ExtArgs> | null
    /**
     * The data needed to update a CustomBlock.
     */
    data: XOR<CustomBlockUpdateInput, CustomBlockUncheckedUpdateInput>
    /**
     * Choose, which CustomBlock to update.
     */
    where: CustomBlockWhereUniqueInput
  }

  /**
   * CustomBlock updateMany
   */
  export type CustomBlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomBlocks.
     */
    data: XOR<CustomBlockUpdateManyMutationInput, CustomBlockUncheckedUpdateManyInput>
    /**
     * Filter which CustomBlocks to update
     */
    where?: CustomBlockWhereInput
  }

  /**
   * CustomBlock upsert
   */
  export type CustomBlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomBlock
     */
    select?: CustomBlockSelect<ExtArgs> | null
    /**
     * The filter to search for the CustomBlock to update in case it exists.
     */
    where: CustomBlockWhereUniqueInput
    /**
     * In case the CustomBlock found by the `where` argument doesn't exist, create a new CustomBlock with this data.
     */
    create: XOR<CustomBlockCreateInput, CustomBlockUncheckedCreateInput>
    /**
     * In case the CustomBlock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomBlockUpdateInput, CustomBlockUncheckedUpdateInput>
  }

  /**
   * CustomBlock delete
   */
  export type CustomBlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomBlock
     */
    select?: CustomBlockSelect<ExtArgs> | null
    /**
     * Filter which CustomBlock to delete.
     */
    where: CustomBlockWhereUniqueInput
  }

  /**
   * CustomBlock deleteMany
   */
  export type CustomBlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomBlocks to delete
     */
    where?: CustomBlockWhereInput
  }

  /**
   * CustomBlock without action
   */
  export type CustomBlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomBlock
     */
    select?: CustomBlockSelect<ExtArgs> | null
  }


  /**
   * Model ExecutionQueue
   */

  export type AggregateExecutionQueue = {
    _count: ExecutionQueueCountAggregateOutputType | null
    _avg: ExecutionQueueAvgAggregateOutputType | null
    _sum: ExecutionQueueSumAggregateOutputType | null
    _min: ExecutionQueueMinAggregateOutputType | null
    _max: ExecutionQueueMaxAggregateOutputType | null
  }

  export type ExecutionQueueAvgAggregateOutputType = {
    priority: number | null
    retryCount: number | null
    maxRetries: number | null
  }

  export type ExecutionQueueSumAggregateOutputType = {
    priority: number | null
    retryCount: number | null
    maxRetries: number | null
  }

  export type ExecutionQueueMinAggregateOutputType = {
    id: string | null
    workflowId: string | null
    executionId: string | null
    userId: string | null
    priority: number | null
    status: string | null
    error: string | null
    retryCount: number | null
    maxRetries: number | null
    lockedBy: string | null
    lockedUntil: Date | null
    scheduledFor: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExecutionQueueMaxAggregateOutputType = {
    id: string | null
    workflowId: string | null
    executionId: string | null
    userId: string | null
    priority: number | null
    status: string | null
    error: string | null
    retryCount: number | null
    maxRetries: number | null
    lockedBy: string | null
    lockedUntil: Date | null
    scheduledFor: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExecutionQueueCountAggregateOutputType = {
    id: number
    workflowId: number
    executionId: number
    userId: number
    priority: number
    status: number
    payload: number
    error: number
    retryCount: number
    maxRetries: number
    lockedBy: number
    lockedUntil: number
    scheduledFor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExecutionQueueAvgAggregateInputType = {
    priority?: true
    retryCount?: true
    maxRetries?: true
  }

  export type ExecutionQueueSumAggregateInputType = {
    priority?: true
    retryCount?: true
    maxRetries?: true
  }

  export type ExecutionQueueMinAggregateInputType = {
    id?: true
    workflowId?: true
    executionId?: true
    userId?: true
    priority?: true
    status?: true
    error?: true
    retryCount?: true
    maxRetries?: true
    lockedBy?: true
    lockedUntil?: true
    scheduledFor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExecutionQueueMaxAggregateInputType = {
    id?: true
    workflowId?: true
    executionId?: true
    userId?: true
    priority?: true
    status?: true
    error?: true
    retryCount?: true
    maxRetries?: true
    lockedBy?: true
    lockedUntil?: true
    scheduledFor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExecutionQueueCountAggregateInputType = {
    id?: true
    workflowId?: true
    executionId?: true
    userId?: true
    priority?: true
    status?: true
    payload?: true
    error?: true
    retryCount?: true
    maxRetries?: true
    lockedBy?: true
    lockedUntil?: true
    scheduledFor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExecutionQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExecutionQueue to aggregate.
     */
    where?: ExecutionQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionQueues to fetch.
     */
    orderBy?: ExecutionQueueOrderByWithRelationInput | ExecutionQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExecutionQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExecutionQueues
    **/
    _count?: true | ExecutionQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExecutionQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExecutionQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExecutionQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExecutionQueueMaxAggregateInputType
  }

  export type GetExecutionQueueAggregateType<T extends ExecutionQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateExecutionQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExecutionQueue[P]>
      : GetScalarType<T[P], AggregateExecutionQueue[P]>
  }




  export type ExecutionQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExecutionQueueWhereInput
    orderBy?: ExecutionQueueOrderByWithAggregationInput | ExecutionQueueOrderByWithAggregationInput[]
    by: ExecutionQueueScalarFieldEnum[] | ExecutionQueueScalarFieldEnum
    having?: ExecutionQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExecutionQueueCountAggregateInputType | true
    _avg?: ExecutionQueueAvgAggregateInputType
    _sum?: ExecutionQueueSumAggregateInputType
    _min?: ExecutionQueueMinAggregateInputType
    _max?: ExecutionQueueMaxAggregateInputType
  }

  export type ExecutionQueueGroupByOutputType = {
    id: string
    workflowId: string
    executionId: string
    userId: string | null
    priority: number
    status: string
    payload: JsonValue | null
    error: string | null
    retryCount: number
    maxRetries: number
    lockedBy: string | null
    lockedUntil: Date | null
    scheduledFor: Date
    createdAt: Date
    updatedAt: Date
    _count: ExecutionQueueCountAggregateOutputType | null
    _avg: ExecutionQueueAvgAggregateOutputType | null
    _sum: ExecutionQueueSumAggregateOutputType | null
    _min: ExecutionQueueMinAggregateOutputType | null
    _max: ExecutionQueueMaxAggregateOutputType | null
  }

  type GetExecutionQueueGroupByPayload<T extends ExecutionQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExecutionQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExecutionQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExecutionQueueGroupByOutputType[P]>
            : GetScalarType<T[P], ExecutionQueueGroupByOutputType[P]>
        }
      >
    >


  export type ExecutionQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    executionId?: boolean
    userId?: boolean
    priority?: boolean
    status?: boolean
    payload?: boolean
    error?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    lockedBy?: boolean
    lockedUntil?: boolean
    scheduledFor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["executionQueue"]>

  export type ExecutionQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    executionId?: boolean
    userId?: boolean
    priority?: boolean
    status?: boolean
    payload?: boolean
    error?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    lockedBy?: boolean
    lockedUntil?: boolean
    scheduledFor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["executionQueue"]>

  export type ExecutionQueueSelectScalar = {
    id?: boolean
    workflowId?: boolean
    executionId?: boolean
    userId?: boolean
    priority?: boolean
    status?: boolean
    payload?: boolean
    error?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    lockedBy?: boolean
    lockedUntil?: boolean
    scheduledFor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $ExecutionQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExecutionQueue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowId: string
      executionId: string
      userId: string | null
      priority: number
      status: string
      payload: Prisma.JsonValue | null
      error: string | null
      retryCount: number
      maxRetries: number
      lockedBy: string | null
      lockedUntil: Date | null
      scheduledFor: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["executionQueue"]>
    composites: {}
  }

  type ExecutionQueueGetPayload<S extends boolean | null | undefined | ExecutionQueueDefaultArgs> = $Result.GetResult<Prisma.$ExecutionQueuePayload, S>

  type ExecutionQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExecutionQueueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExecutionQueueCountAggregateInputType | true
    }

  export interface ExecutionQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExecutionQueue'], meta: { name: 'ExecutionQueue' } }
    /**
     * Find zero or one ExecutionQueue that matches the filter.
     * @param {ExecutionQueueFindUniqueArgs} args - Arguments to find a ExecutionQueue
     * @example
     * // Get one ExecutionQueue
     * const executionQueue = await prisma.executionQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExecutionQueueFindUniqueArgs>(args: SelectSubset<T, ExecutionQueueFindUniqueArgs<ExtArgs>>): Prisma__ExecutionQueueClient<$Result.GetResult<Prisma.$ExecutionQueuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExecutionQueue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExecutionQueueFindUniqueOrThrowArgs} args - Arguments to find a ExecutionQueue
     * @example
     * // Get one ExecutionQueue
     * const executionQueue = await prisma.executionQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExecutionQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, ExecutionQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExecutionQueueClient<$Result.GetResult<Prisma.$ExecutionQueuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExecutionQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionQueueFindFirstArgs} args - Arguments to find a ExecutionQueue
     * @example
     * // Get one ExecutionQueue
     * const executionQueue = await prisma.executionQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExecutionQueueFindFirstArgs>(args?: SelectSubset<T, ExecutionQueueFindFirstArgs<ExtArgs>>): Prisma__ExecutionQueueClient<$Result.GetResult<Prisma.$ExecutionQueuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExecutionQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionQueueFindFirstOrThrowArgs} args - Arguments to find a ExecutionQueue
     * @example
     * // Get one ExecutionQueue
     * const executionQueue = await prisma.executionQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExecutionQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, ExecutionQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExecutionQueueClient<$Result.GetResult<Prisma.$ExecutionQueuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExecutionQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExecutionQueues
     * const executionQueues = await prisma.executionQueue.findMany()
     * 
     * // Get first 10 ExecutionQueues
     * const executionQueues = await prisma.executionQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const executionQueueWithIdOnly = await prisma.executionQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExecutionQueueFindManyArgs>(args?: SelectSubset<T, ExecutionQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionQueuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExecutionQueue.
     * @param {ExecutionQueueCreateArgs} args - Arguments to create a ExecutionQueue.
     * @example
     * // Create one ExecutionQueue
     * const ExecutionQueue = await prisma.executionQueue.create({
     *   data: {
     *     // ... data to create a ExecutionQueue
     *   }
     * })
     * 
     */
    create<T extends ExecutionQueueCreateArgs>(args: SelectSubset<T, ExecutionQueueCreateArgs<ExtArgs>>): Prisma__ExecutionQueueClient<$Result.GetResult<Prisma.$ExecutionQueuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExecutionQueues.
     * @param {ExecutionQueueCreateManyArgs} args - Arguments to create many ExecutionQueues.
     * @example
     * // Create many ExecutionQueues
     * const executionQueue = await prisma.executionQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExecutionQueueCreateManyArgs>(args?: SelectSubset<T, ExecutionQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExecutionQueues and returns the data saved in the database.
     * @param {ExecutionQueueCreateManyAndReturnArgs} args - Arguments to create many ExecutionQueues.
     * @example
     * // Create many ExecutionQueues
     * const executionQueue = await prisma.executionQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExecutionQueues and only return the `id`
     * const executionQueueWithIdOnly = await prisma.executionQueue.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExecutionQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, ExecutionQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionQueuePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExecutionQueue.
     * @param {ExecutionQueueDeleteArgs} args - Arguments to delete one ExecutionQueue.
     * @example
     * // Delete one ExecutionQueue
     * const ExecutionQueue = await prisma.executionQueue.delete({
     *   where: {
     *     // ... filter to delete one ExecutionQueue
     *   }
     * })
     * 
     */
    delete<T extends ExecutionQueueDeleteArgs>(args: SelectSubset<T, ExecutionQueueDeleteArgs<ExtArgs>>): Prisma__ExecutionQueueClient<$Result.GetResult<Prisma.$ExecutionQueuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExecutionQueue.
     * @param {ExecutionQueueUpdateArgs} args - Arguments to update one ExecutionQueue.
     * @example
     * // Update one ExecutionQueue
     * const executionQueue = await prisma.executionQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExecutionQueueUpdateArgs>(args: SelectSubset<T, ExecutionQueueUpdateArgs<ExtArgs>>): Prisma__ExecutionQueueClient<$Result.GetResult<Prisma.$ExecutionQueuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExecutionQueues.
     * @param {ExecutionQueueDeleteManyArgs} args - Arguments to filter ExecutionQueues to delete.
     * @example
     * // Delete a few ExecutionQueues
     * const { count } = await prisma.executionQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExecutionQueueDeleteManyArgs>(args?: SelectSubset<T, ExecutionQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExecutionQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExecutionQueues
     * const executionQueue = await prisma.executionQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExecutionQueueUpdateManyArgs>(args: SelectSubset<T, ExecutionQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExecutionQueue.
     * @param {ExecutionQueueUpsertArgs} args - Arguments to update or create a ExecutionQueue.
     * @example
     * // Update or create a ExecutionQueue
     * const executionQueue = await prisma.executionQueue.upsert({
     *   create: {
     *     // ... data to create a ExecutionQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExecutionQueue we want to update
     *   }
     * })
     */
    upsert<T extends ExecutionQueueUpsertArgs>(args: SelectSubset<T, ExecutionQueueUpsertArgs<ExtArgs>>): Prisma__ExecutionQueueClient<$Result.GetResult<Prisma.$ExecutionQueuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExecutionQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionQueueCountArgs} args - Arguments to filter ExecutionQueues to count.
     * @example
     * // Count the number of ExecutionQueues
     * const count = await prisma.executionQueue.count({
     *   where: {
     *     // ... the filter for the ExecutionQueues we want to count
     *   }
     * })
    **/
    count<T extends ExecutionQueueCountArgs>(
      args?: Subset<T, ExecutionQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExecutionQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExecutionQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExecutionQueueAggregateArgs>(args: Subset<T, ExecutionQueueAggregateArgs>): Prisma.PrismaPromise<GetExecutionQueueAggregateType<T>>

    /**
     * Group by ExecutionQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExecutionQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExecutionQueueGroupByArgs['orderBy'] }
        : { orderBy?: ExecutionQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExecutionQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExecutionQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExecutionQueue model
   */
  readonly fields: ExecutionQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExecutionQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExecutionQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExecutionQueue model
   */ 
  interface ExecutionQueueFieldRefs {
    readonly id: FieldRef<"ExecutionQueue", 'String'>
    readonly workflowId: FieldRef<"ExecutionQueue", 'String'>
    readonly executionId: FieldRef<"ExecutionQueue", 'String'>
    readonly userId: FieldRef<"ExecutionQueue", 'String'>
    readonly priority: FieldRef<"ExecutionQueue", 'Int'>
    readonly status: FieldRef<"ExecutionQueue", 'String'>
    readonly payload: FieldRef<"ExecutionQueue", 'Json'>
    readonly error: FieldRef<"ExecutionQueue", 'String'>
    readonly retryCount: FieldRef<"ExecutionQueue", 'Int'>
    readonly maxRetries: FieldRef<"ExecutionQueue", 'Int'>
    readonly lockedBy: FieldRef<"ExecutionQueue", 'String'>
    readonly lockedUntil: FieldRef<"ExecutionQueue", 'DateTime'>
    readonly scheduledFor: FieldRef<"ExecutionQueue", 'DateTime'>
    readonly createdAt: FieldRef<"ExecutionQueue", 'DateTime'>
    readonly updatedAt: FieldRef<"ExecutionQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExecutionQueue findUnique
   */
  export type ExecutionQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionQueue
     */
    select?: ExecutionQueueSelect<ExtArgs> | null
    /**
     * Filter, which ExecutionQueue to fetch.
     */
    where: ExecutionQueueWhereUniqueInput
  }

  /**
   * ExecutionQueue findUniqueOrThrow
   */
  export type ExecutionQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionQueue
     */
    select?: ExecutionQueueSelect<ExtArgs> | null
    /**
     * Filter, which ExecutionQueue to fetch.
     */
    where: ExecutionQueueWhereUniqueInput
  }

  /**
   * ExecutionQueue findFirst
   */
  export type ExecutionQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionQueue
     */
    select?: ExecutionQueueSelect<ExtArgs> | null
    /**
     * Filter, which ExecutionQueue to fetch.
     */
    where?: ExecutionQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionQueues to fetch.
     */
    orderBy?: ExecutionQueueOrderByWithRelationInput | ExecutionQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExecutionQueues.
     */
    cursor?: ExecutionQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExecutionQueues.
     */
    distinct?: ExecutionQueueScalarFieldEnum | ExecutionQueueScalarFieldEnum[]
  }

  /**
   * ExecutionQueue findFirstOrThrow
   */
  export type ExecutionQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionQueue
     */
    select?: ExecutionQueueSelect<ExtArgs> | null
    /**
     * Filter, which ExecutionQueue to fetch.
     */
    where?: ExecutionQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionQueues to fetch.
     */
    orderBy?: ExecutionQueueOrderByWithRelationInput | ExecutionQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExecutionQueues.
     */
    cursor?: ExecutionQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExecutionQueues.
     */
    distinct?: ExecutionQueueScalarFieldEnum | ExecutionQueueScalarFieldEnum[]
  }

  /**
   * ExecutionQueue findMany
   */
  export type ExecutionQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionQueue
     */
    select?: ExecutionQueueSelect<ExtArgs> | null
    /**
     * Filter, which ExecutionQueues to fetch.
     */
    where?: ExecutionQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionQueues to fetch.
     */
    orderBy?: ExecutionQueueOrderByWithRelationInput | ExecutionQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExecutionQueues.
     */
    cursor?: ExecutionQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionQueues.
     */
    skip?: number
    distinct?: ExecutionQueueScalarFieldEnum | ExecutionQueueScalarFieldEnum[]
  }

  /**
   * ExecutionQueue create
   */
  export type ExecutionQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionQueue
     */
    select?: ExecutionQueueSelect<ExtArgs> | null
    /**
     * The data needed to create a ExecutionQueue.
     */
    data: XOR<ExecutionQueueCreateInput, ExecutionQueueUncheckedCreateInput>
  }

  /**
   * ExecutionQueue createMany
   */
  export type ExecutionQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExecutionQueues.
     */
    data: ExecutionQueueCreateManyInput | ExecutionQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExecutionQueue createManyAndReturn
   */
  export type ExecutionQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionQueue
     */
    select?: ExecutionQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExecutionQueues.
     */
    data: ExecutionQueueCreateManyInput | ExecutionQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExecutionQueue update
   */
  export type ExecutionQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionQueue
     */
    select?: ExecutionQueueSelect<ExtArgs> | null
    /**
     * The data needed to update a ExecutionQueue.
     */
    data: XOR<ExecutionQueueUpdateInput, ExecutionQueueUncheckedUpdateInput>
    /**
     * Choose, which ExecutionQueue to update.
     */
    where: ExecutionQueueWhereUniqueInput
  }

  /**
   * ExecutionQueue updateMany
   */
  export type ExecutionQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExecutionQueues.
     */
    data: XOR<ExecutionQueueUpdateManyMutationInput, ExecutionQueueUncheckedUpdateManyInput>
    /**
     * Filter which ExecutionQueues to update
     */
    where?: ExecutionQueueWhereInput
  }

  /**
   * ExecutionQueue upsert
   */
  export type ExecutionQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionQueue
     */
    select?: ExecutionQueueSelect<ExtArgs> | null
    /**
     * The filter to search for the ExecutionQueue to update in case it exists.
     */
    where: ExecutionQueueWhereUniqueInput
    /**
     * In case the ExecutionQueue found by the `where` argument doesn't exist, create a new ExecutionQueue with this data.
     */
    create: XOR<ExecutionQueueCreateInput, ExecutionQueueUncheckedCreateInput>
    /**
     * In case the ExecutionQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExecutionQueueUpdateInput, ExecutionQueueUncheckedUpdateInput>
  }

  /**
   * ExecutionQueue delete
   */
  export type ExecutionQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionQueue
     */
    select?: ExecutionQueueSelect<ExtArgs> | null
    /**
     * Filter which ExecutionQueue to delete.
     */
    where: ExecutionQueueWhereUniqueInput
  }

  /**
   * ExecutionQueue deleteMany
   */
  export type ExecutionQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExecutionQueues to delete
     */
    where?: ExecutionQueueWhereInput
  }

  /**
   * ExecutionQueue without action
   */
  export type ExecutionQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionQueue
     */
    select?: ExecutionQueueSelect<ExtArgs> | null
  }


  /**
   * Model ExecutionNodeStatus
   */

  export type AggregateExecutionNodeStatus = {
    _count: ExecutionNodeStatusCountAggregateOutputType | null
    _min: ExecutionNodeStatusMinAggregateOutputType | null
    _max: ExecutionNodeStatusMaxAggregateOutputType | null
  }

  export type ExecutionNodeStatusMinAggregateOutputType = {
    id: string | null
    nodeId: string | null
    status: string | null
    lastHeartbeat: Date | null
  }

  export type ExecutionNodeStatusMaxAggregateOutputType = {
    id: string | null
    nodeId: string | null
    status: string | null
    lastHeartbeat: Date | null
  }

  export type ExecutionNodeStatusCountAggregateOutputType = {
    id: number
    nodeId: number
    status: number
    lastHeartbeat: number
    metadata: number
    _all: number
  }


  export type ExecutionNodeStatusMinAggregateInputType = {
    id?: true
    nodeId?: true
    status?: true
    lastHeartbeat?: true
  }

  export type ExecutionNodeStatusMaxAggregateInputType = {
    id?: true
    nodeId?: true
    status?: true
    lastHeartbeat?: true
  }

  export type ExecutionNodeStatusCountAggregateInputType = {
    id?: true
    nodeId?: true
    status?: true
    lastHeartbeat?: true
    metadata?: true
    _all?: true
  }

  export type ExecutionNodeStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExecutionNodeStatus to aggregate.
     */
    where?: ExecutionNodeStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionNodeStatuses to fetch.
     */
    orderBy?: ExecutionNodeStatusOrderByWithRelationInput | ExecutionNodeStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExecutionNodeStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionNodeStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionNodeStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExecutionNodeStatuses
    **/
    _count?: true | ExecutionNodeStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExecutionNodeStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExecutionNodeStatusMaxAggregateInputType
  }

  export type GetExecutionNodeStatusAggregateType<T extends ExecutionNodeStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateExecutionNodeStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExecutionNodeStatus[P]>
      : GetScalarType<T[P], AggregateExecutionNodeStatus[P]>
  }




  export type ExecutionNodeStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExecutionNodeStatusWhereInput
    orderBy?: ExecutionNodeStatusOrderByWithAggregationInput | ExecutionNodeStatusOrderByWithAggregationInput[]
    by: ExecutionNodeStatusScalarFieldEnum[] | ExecutionNodeStatusScalarFieldEnum
    having?: ExecutionNodeStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExecutionNodeStatusCountAggregateInputType | true
    _min?: ExecutionNodeStatusMinAggregateInputType
    _max?: ExecutionNodeStatusMaxAggregateInputType
  }

  export type ExecutionNodeStatusGroupByOutputType = {
    id: string
    nodeId: string
    status: string
    lastHeartbeat: Date
    metadata: JsonValue | null
    _count: ExecutionNodeStatusCountAggregateOutputType | null
    _min: ExecutionNodeStatusMinAggregateOutputType | null
    _max: ExecutionNodeStatusMaxAggregateOutputType | null
  }

  type GetExecutionNodeStatusGroupByPayload<T extends ExecutionNodeStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExecutionNodeStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExecutionNodeStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExecutionNodeStatusGroupByOutputType[P]>
            : GetScalarType<T[P], ExecutionNodeStatusGroupByOutputType[P]>
        }
      >
    >


  export type ExecutionNodeStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeId?: boolean
    status?: boolean
    lastHeartbeat?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["executionNodeStatus"]>

  export type ExecutionNodeStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeId?: boolean
    status?: boolean
    lastHeartbeat?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["executionNodeStatus"]>

  export type ExecutionNodeStatusSelectScalar = {
    id?: boolean
    nodeId?: boolean
    status?: boolean
    lastHeartbeat?: boolean
    metadata?: boolean
  }


  export type $ExecutionNodeStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExecutionNodeStatus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nodeId: string
      status: string
      lastHeartbeat: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["executionNodeStatus"]>
    composites: {}
  }

  type ExecutionNodeStatusGetPayload<S extends boolean | null | undefined | ExecutionNodeStatusDefaultArgs> = $Result.GetResult<Prisma.$ExecutionNodeStatusPayload, S>

  type ExecutionNodeStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExecutionNodeStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExecutionNodeStatusCountAggregateInputType | true
    }

  export interface ExecutionNodeStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExecutionNodeStatus'], meta: { name: 'ExecutionNodeStatus' } }
    /**
     * Find zero or one ExecutionNodeStatus that matches the filter.
     * @param {ExecutionNodeStatusFindUniqueArgs} args - Arguments to find a ExecutionNodeStatus
     * @example
     * // Get one ExecutionNodeStatus
     * const executionNodeStatus = await prisma.executionNodeStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExecutionNodeStatusFindUniqueArgs>(args: SelectSubset<T, ExecutionNodeStatusFindUniqueArgs<ExtArgs>>): Prisma__ExecutionNodeStatusClient<$Result.GetResult<Prisma.$ExecutionNodeStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExecutionNodeStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExecutionNodeStatusFindUniqueOrThrowArgs} args - Arguments to find a ExecutionNodeStatus
     * @example
     * // Get one ExecutionNodeStatus
     * const executionNodeStatus = await prisma.executionNodeStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExecutionNodeStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, ExecutionNodeStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExecutionNodeStatusClient<$Result.GetResult<Prisma.$ExecutionNodeStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExecutionNodeStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionNodeStatusFindFirstArgs} args - Arguments to find a ExecutionNodeStatus
     * @example
     * // Get one ExecutionNodeStatus
     * const executionNodeStatus = await prisma.executionNodeStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExecutionNodeStatusFindFirstArgs>(args?: SelectSubset<T, ExecutionNodeStatusFindFirstArgs<ExtArgs>>): Prisma__ExecutionNodeStatusClient<$Result.GetResult<Prisma.$ExecutionNodeStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExecutionNodeStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionNodeStatusFindFirstOrThrowArgs} args - Arguments to find a ExecutionNodeStatus
     * @example
     * // Get one ExecutionNodeStatus
     * const executionNodeStatus = await prisma.executionNodeStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExecutionNodeStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, ExecutionNodeStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExecutionNodeStatusClient<$Result.GetResult<Prisma.$ExecutionNodeStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExecutionNodeStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionNodeStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExecutionNodeStatuses
     * const executionNodeStatuses = await prisma.executionNodeStatus.findMany()
     * 
     * // Get first 10 ExecutionNodeStatuses
     * const executionNodeStatuses = await prisma.executionNodeStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const executionNodeStatusWithIdOnly = await prisma.executionNodeStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExecutionNodeStatusFindManyArgs>(args?: SelectSubset<T, ExecutionNodeStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionNodeStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExecutionNodeStatus.
     * @param {ExecutionNodeStatusCreateArgs} args - Arguments to create a ExecutionNodeStatus.
     * @example
     * // Create one ExecutionNodeStatus
     * const ExecutionNodeStatus = await prisma.executionNodeStatus.create({
     *   data: {
     *     // ... data to create a ExecutionNodeStatus
     *   }
     * })
     * 
     */
    create<T extends ExecutionNodeStatusCreateArgs>(args: SelectSubset<T, ExecutionNodeStatusCreateArgs<ExtArgs>>): Prisma__ExecutionNodeStatusClient<$Result.GetResult<Prisma.$ExecutionNodeStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExecutionNodeStatuses.
     * @param {ExecutionNodeStatusCreateManyArgs} args - Arguments to create many ExecutionNodeStatuses.
     * @example
     * // Create many ExecutionNodeStatuses
     * const executionNodeStatus = await prisma.executionNodeStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExecutionNodeStatusCreateManyArgs>(args?: SelectSubset<T, ExecutionNodeStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExecutionNodeStatuses and returns the data saved in the database.
     * @param {ExecutionNodeStatusCreateManyAndReturnArgs} args - Arguments to create many ExecutionNodeStatuses.
     * @example
     * // Create many ExecutionNodeStatuses
     * const executionNodeStatus = await prisma.executionNodeStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExecutionNodeStatuses and only return the `id`
     * const executionNodeStatusWithIdOnly = await prisma.executionNodeStatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExecutionNodeStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, ExecutionNodeStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionNodeStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExecutionNodeStatus.
     * @param {ExecutionNodeStatusDeleteArgs} args - Arguments to delete one ExecutionNodeStatus.
     * @example
     * // Delete one ExecutionNodeStatus
     * const ExecutionNodeStatus = await prisma.executionNodeStatus.delete({
     *   where: {
     *     // ... filter to delete one ExecutionNodeStatus
     *   }
     * })
     * 
     */
    delete<T extends ExecutionNodeStatusDeleteArgs>(args: SelectSubset<T, ExecutionNodeStatusDeleteArgs<ExtArgs>>): Prisma__ExecutionNodeStatusClient<$Result.GetResult<Prisma.$ExecutionNodeStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExecutionNodeStatus.
     * @param {ExecutionNodeStatusUpdateArgs} args - Arguments to update one ExecutionNodeStatus.
     * @example
     * // Update one ExecutionNodeStatus
     * const executionNodeStatus = await prisma.executionNodeStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExecutionNodeStatusUpdateArgs>(args: SelectSubset<T, ExecutionNodeStatusUpdateArgs<ExtArgs>>): Prisma__ExecutionNodeStatusClient<$Result.GetResult<Prisma.$ExecutionNodeStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExecutionNodeStatuses.
     * @param {ExecutionNodeStatusDeleteManyArgs} args - Arguments to filter ExecutionNodeStatuses to delete.
     * @example
     * // Delete a few ExecutionNodeStatuses
     * const { count } = await prisma.executionNodeStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExecutionNodeStatusDeleteManyArgs>(args?: SelectSubset<T, ExecutionNodeStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExecutionNodeStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionNodeStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExecutionNodeStatuses
     * const executionNodeStatus = await prisma.executionNodeStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExecutionNodeStatusUpdateManyArgs>(args: SelectSubset<T, ExecutionNodeStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExecutionNodeStatus.
     * @param {ExecutionNodeStatusUpsertArgs} args - Arguments to update or create a ExecutionNodeStatus.
     * @example
     * // Update or create a ExecutionNodeStatus
     * const executionNodeStatus = await prisma.executionNodeStatus.upsert({
     *   create: {
     *     // ... data to create a ExecutionNodeStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExecutionNodeStatus we want to update
     *   }
     * })
     */
    upsert<T extends ExecutionNodeStatusUpsertArgs>(args: SelectSubset<T, ExecutionNodeStatusUpsertArgs<ExtArgs>>): Prisma__ExecutionNodeStatusClient<$Result.GetResult<Prisma.$ExecutionNodeStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExecutionNodeStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionNodeStatusCountArgs} args - Arguments to filter ExecutionNodeStatuses to count.
     * @example
     * // Count the number of ExecutionNodeStatuses
     * const count = await prisma.executionNodeStatus.count({
     *   where: {
     *     // ... the filter for the ExecutionNodeStatuses we want to count
     *   }
     * })
    **/
    count<T extends ExecutionNodeStatusCountArgs>(
      args?: Subset<T, ExecutionNodeStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExecutionNodeStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExecutionNodeStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionNodeStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExecutionNodeStatusAggregateArgs>(args: Subset<T, ExecutionNodeStatusAggregateArgs>): Prisma.PrismaPromise<GetExecutionNodeStatusAggregateType<T>>

    /**
     * Group by ExecutionNodeStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionNodeStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExecutionNodeStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExecutionNodeStatusGroupByArgs['orderBy'] }
        : { orderBy?: ExecutionNodeStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExecutionNodeStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExecutionNodeStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExecutionNodeStatus model
   */
  readonly fields: ExecutionNodeStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExecutionNodeStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExecutionNodeStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExecutionNodeStatus model
   */ 
  interface ExecutionNodeStatusFieldRefs {
    readonly id: FieldRef<"ExecutionNodeStatus", 'String'>
    readonly nodeId: FieldRef<"ExecutionNodeStatus", 'String'>
    readonly status: FieldRef<"ExecutionNodeStatus", 'String'>
    readonly lastHeartbeat: FieldRef<"ExecutionNodeStatus", 'DateTime'>
    readonly metadata: FieldRef<"ExecutionNodeStatus", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ExecutionNodeStatus findUnique
   */
  export type ExecutionNodeStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionNodeStatus
     */
    select?: ExecutionNodeStatusSelect<ExtArgs> | null
    /**
     * Filter, which ExecutionNodeStatus to fetch.
     */
    where: ExecutionNodeStatusWhereUniqueInput
  }

  /**
   * ExecutionNodeStatus findUniqueOrThrow
   */
  export type ExecutionNodeStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionNodeStatus
     */
    select?: ExecutionNodeStatusSelect<ExtArgs> | null
    /**
     * Filter, which ExecutionNodeStatus to fetch.
     */
    where: ExecutionNodeStatusWhereUniqueInput
  }

  /**
   * ExecutionNodeStatus findFirst
   */
  export type ExecutionNodeStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionNodeStatus
     */
    select?: ExecutionNodeStatusSelect<ExtArgs> | null
    /**
     * Filter, which ExecutionNodeStatus to fetch.
     */
    where?: ExecutionNodeStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionNodeStatuses to fetch.
     */
    orderBy?: ExecutionNodeStatusOrderByWithRelationInput | ExecutionNodeStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExecutionNodeStatuses.
     */
    cursor?: ExecutionNodeStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionNodeStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionNodeStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExecutionNodeStatuses.
     */
    distinct?: ExecutionNodeStatusScalarFieldEnum | ExecutionNodeStatusScalarFieldEnum[]
  }

  /**
   * ExecutionNodeStatus findFirstOrThrow
   */
  export type ExecutionNodeStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionNodeStatus
     */
    select?: ExecutionNodeStatusSelect<ExtArgs> | null
    /**
     * Filter, which ExecutionNodeStatus to fetch.
     */
    where?: ExecutionNodeStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionNodeStatuses to fetch.
     */
    orderBy?: ExecutionNodeStatusOrderByWithRelationInput | ExecutionNodeStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExecutionNodeStatuses.
     */
    cursor?: ExecutionNodeStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionNodeStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionNodeStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExecutionNodeStatuses.
     */
    distinct?: ExecutionNodeStatusScalarFieldEnum | ExecutionNodeStatusScalarFieldEnum[]
  }

  /**
   * ExecutionNodeStatus findMany
   */
  export type ExecutionNodeStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionNodeStatus
     */
    select?: ExecutionNodeStatusSelect<ExtArgs> | null
    /**
     * Filter, which ExecutionNodeStatuses to fetch.
     */
    where?: ExecutionNodeStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionNodeStatuses to fetch.
     */
    orderBy?: ExecutionNodeStatusOrderByWithRelationInput | ExecutionNodeStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExecutionNodeStatuses.
     */
    cursor?: ExecutionNodeStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionNodeStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionNodeStatuses.
     */
    skip?: number
    distinct?: ExecutionNodeStatusScalarFieldEnum | ExecutionNodeStatusScalarFieldEnum[]
  }

  /**
   * ExecutionNodeStatus create
   */
  export type ExecutionNodeStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionNodeStatus
     */
    select?: ExecutionNodeStatusSelect<ExtArgs> | null
    /**
     * The data needed to create a ExecutionNodeStatus.
     */
    data: XOR<ExecutionNodeStatusCreateInput, ExecutionNodeStatusUncheckedCreateInput>
  }

  /**
   * ExecutionNodeStatus createMany
   */
  export type ExecutionNodeStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExecutionNodeStatuses.
     */
    data: ExecutionNodeStatusCreateManyInput | ExecutionNodeStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExecutionNodeStatus createManyAndReturn
   */
  export type ExecutionNodeStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionNodeStatus
     */
    select?: ExecutionNodeStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExecutionNodeStatuses.
     */
    data: ExecutionNodeStatusCreateManyInput | ExecutionNodeStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExecutionNodeStatus update
   */
  export type ExecutionNodeStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionNodeStatus
     */
    select?: ExecutionNodeStatusSelect<ExtArgs> | null
    /**
     * The data needed to update a ExecutionNodeStatus.
     */
    data: XOR<ExecutionNodeStatusUpdateInput, ExecutionNodeStatusUncheckedUpdateInput>
    /**
     * Choose, which ExecutionNodeStatus to update.
     */
    where: ExecutionNodeStatusWhereUniqueInput
  }

  /**
   * ExecutionNodeStatus updateMany
   */
  export type ExecutionNodeStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExecutionNodeStatuses.
     */
    data: XOR<ExecutionNodeStatusUpdateManyMutationInput, ExecutionNodeStatusUncheckedUpdateManyInput>
    /**
     * Filter which ExecutionNodeStatuses to update
     */
    where?: ExecutionNodeStatusWhereInput
  }

  /**
   * ExecutionNodeStatus upsert
   */
  export type ExecutionNodeStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionNodeStatus
     */
    select?: ExecutionNodeStatusSelect<ExtArgs> | null
    /**
     * The filter to search for the ExecutionNodeStatus to update in case it exists.
     */
    where: ExecutionNodeStatusWhereUniqueInput
    /**
     * In case the ExecutionNodeStatus found by the `where` argument doesn't exist, create a new ExecutionNodeStatus with this data.
     */
    create: XOR<ExecutionNodeStatusCreateInput, ExecutionNodeStatusUncheckedCreateInput>
    /**
     * In case the ExecutionNodeStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExecutionNodeStatusUpdateInput, ExecutionNodeStatusUncheckedUpdateInput>
  }

  /**
   * ExecutionNodeStatus delete
   */
  export type ExecutionNodeStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionNodeStatus
     */
    select?: ExecutionNodeStatusSelect<ExtArgs> | null
    /**
     * Filter which ExecutionNodeStatus to delete.
     */
    where: ExecutionNodeStatusWhereUniqueInput
  }

  /**
   * ExecutionNodeStatus deleteMany
   */
  export type ExecutionNodeStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExecutionNodeStatuses to delete
     */
    where?: ExecutionNodeStatusWhereInput
  }

  /**
   * ExecutionNodeStatus without action
   */
  export type ExecutionNodeStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionNodeStatus
     */
    select?: ExecutionNodeStatusSelect<ExtArgs> | null
  }


  /**
   * Model CircuitBreakerState
   */

  export type AggregateCircuitBreakerState = {
    _count: CircuitBreakerStateCountAggregateOutputType | null
    _avg: CircuitBreakerStateAvgAggregateOutputType | null
    _sum: CircuitBreakerStateSumAggregateOutputType | null
    _min: CircuitBreakerStateMinAggregateOutputType | null
    _max: CircuitBreakerStateMaxAggregateOutputType | null
  }

  export type CircuitBreakerStateAvgAggregateOutputType = {
    failureCount: number | null
    successCount: number | null
  }

  export type CircuitBreakerStateSumAggregateOutputType = {
    failureCount: number | null
    successCount: number | null
  }

  export type CircuitBreakerStateMinAggregateOutputType = {
    id: string | null
    circuitId: string | null
    state: string | null
    failureCount: number | null
    successCount: number | null
    lastFailureTime: Date | null
    lastSuccessTime: Date | null
    lastHalfOpenTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CircuitBreakerStateMaxAggregateOutputType = {
    id: string | null
    circuitId: string | null
    state: string | null
    failureCount: number | null
    successCount: number | null
    lastFailureTime: Date | null
    lastSuccessTime: Date | null
    lastHalfOpenTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CircuitBreakerStateCountAggregateOutputType = {
    id: number
    circuitId: number
    state: number
    failureCount: number
    successCount: number
    lastFailureTime: number
    lastSuccessTime: number
    lastHalfOpenTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CircuitBreakerStateAvgAggregateInputType = {
    failureCount?: true
    successCount?: true
  }

  export type CircuitBreakerStateSumAggregateInputType = {
    failureCount?: true
    successCount?: true
  }

  export type CircuitBreakerStateMinAggregateInputType = {
    id?: true
    circuitId?: true
    state?: true
    failureCount?: true
    successCount?: true
    lastFailureTime?: true
    lastSuccessTime?: true
    lastHalfOpenTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CircuitBreakerStateMaxAggregateInputType = {
    id?: true
    circuitId?: true
    state?: true
    failureCount?: true
    successCount?: true
    lastFailureTime?: true
    lastSuccessTime?: true
    lastHalfOpenTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CircuitBreakerStateCountAggregateInputType = {
    id?: true
    circuitId?: true
    state?: true
    failureCount?: true
    successCount?: true
    lastFailureTime?: true
    lastSuccessTime?: true
    lastHalfOpenTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CircuitBreakerStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CircuitBreakerState to aggregate.
     */
    where?: CircuitBreakerStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CircuitBreakerStates to fetch.
     */
    orderBy?: CircuitBreakerStateOrderByWithRelationInput | CircuitBreakerStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CircuitBreakerStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CircuitBreakerStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CircuitBreakerStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CircuitBreakerStates
    **/
    _count?: true | CircuitBreakerStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CircuitBreakerStateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CircuitBreakerStateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CircuitBreakerStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CircuitBreakerStateMaxAggregateInputType
  }

  export type GetCircuitBreakerStateAggregateType<T extends CircuitBreakerStateAggregateArgs> = {
        [P in keyof T & keyof AggregateCircuitBreakerState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCircuitBreakerState[P]>
      : GetScalarType<T[P], AggregateCircuitBreakerState[P]>
  }




  export type CircuitBreakerStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CircuitBreakerStateWhereInput
    orderBy?: CircuitBreakerStateOrderByWithAggregationInput | CircuitBreakerStateOrderByWithAggregationInput[]
    by: CircuitBreakerStateScalarFieldEnum[] | CircuitBreakerStateScalarFieldEnum
    having?: CircuitBreakerStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CircuitBreakerStateCountAggregateInputType | true
    _avg?: CircuitBreakerStateAvgAggregateInputType
    _sum?: CircuitBreakerStateSumAggregateInputType
    _min?: CircuitBreakerStateMinAggregateInputType
    _max?: CircuitBreakerStateMaxAggregateInputType
  }

  export type CircuitBreakerStateGroupByOutputType = {
    id: string
    circuitId: string
    state: string
    failureCount: number
    successCount: number
    lastFailureTime: Date | null
    lastSuccessTime: Date | null
    lastHalfOpenTime: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CircuitBreakerStateCountAggregateOutputType | null
    _avg: CircuitBreakerStateAvgAggregateOutputType | null
    _sum: CircuitBreakerStateSumAggregateOutputType | null
    _min: CircuitBreakerStateMinAggregateOutputType | null
    _max: CircuitBreakerStateMaxAggregateOutputType | null
  }

  type GetCircuitBreakerStateGroupByPayload<T extends CircuitBreakerStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CircuitBreakerStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CircuitBreakerStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CircuitBreakerStateGroupByOutputType[P]>
            : GetScalarType<T[P], CircuitBreakerStateGroupByOutputType[P]>
        }
      >
    >


  export type CircuitBreakerStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    circuitId?: boolean
    state?: boolean
    failureCount?: boolean
    successCount?: boolean
    lastFailureTime?: boolean
    lastSuccessTime?: boolean
    lastHalfOpenTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["circuitBreakerState"]>

  export type CircuitBreakerStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    circuitId?: boolean
    state?: boolean
    failureCount?: boolean
    successCount?: boolean
    lastFailureTime?: boolean
    lastSuccessTime?: boolean
    lastHalfOpenTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["circuitBreakerState"]>

  export type CircuitBreakerStateSelectScalar = {
    id?: boolean
    circuitId?: boolean
    state?: boolean
    failureCount?: boolean
    successCount?: boolean
    lastFailureTime?: boolean
    lastSuccessTime?: boolean
    lastHalfOpenTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CircuitBreakerStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CircuitBreakerState"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      circuitId: string
      state: string
      failureCount: number
      successCount: number
      lastFailureTime: Date | null
      lastSuccessTime: Date | null
      lastHalfOpenTime: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["circuitBreakerState"]>
    composites: {}
  }

  type CircuitBreakerStateGetPayload<S extends boolean | null | undefined | CircuitBreakerStateDefaultArgs> = $Result.GetResult<Prisma.$CircuitBreakerStatePayload, S>

  type CircuitBreakerStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CircuitBreakerStateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CircuitBreakerStateCountAggregateInputType | true
    }

  export interface CircuitBreakerStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CircuitBreakerState'], meta: { name: 'CircuitBreakerState' } }
    /**
     * Find zero or one CircuitBreakerState that matches the filter.
     * @param {CircuitBreakerStateFindUniqueArgs} args - Arguments to find a CircuitBreakerState
     * @example
     * // Get one CircuitBreakerState
     * const circuitBreakerState = await prisma.circuitBreakerState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CircuitBreakerStateFindUniqueArgs>(args: SelectSubset<T, CircuitBreakerStateFindUniqueArgs<ExtArgs>>): Prisma__CircuitBreakerStateClient<$Result.GetResult<Prisma.$CircuitBreakerStatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CircuitBreakerState that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CircuitBreakerStateFindUniqueOrThrowArgs} args - Arguments to find a CircuitBreakerState
     * @example
     * // Get one CircuitBreakerState
     * const circuitBreakerState = await prisma.circuitBreakerState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CircuitBreakerStateFindUniqueOrThrowArgs>(args: SelectSubset<T, CircuitBreakerStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CircuitBreakerStateClient<$Result.GetResult<Prisma.$CircuitBreakerStatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CircuitBreakerState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircuitBreakerStateFindFirstArgs} args - Arguments to find a CircuitBreakerState
     * @example
     * // Get one CircuitBreakerState
     * const circuitBreakerState = await prisma.circuitBreakerState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CircuitBreakerStateFindFirstArgs>(args?: SelectSubset<T, CircuitBreakerStateFindFirstArgs<ExtArgs>>): Prisma__CircuitBreakerStateClient<$Result.GetResult<Prisma.$CircuitBreakerStatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CircuitBreakerState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircuitBreakerStateFindFirstOrThrowArgs} args - Arguments to find a CircuitBreakerState
     * @example
     * // Get one CircuitBreakerState
     * const circuitBreakerState = await prisma.circuitBreakerState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CircuitBreakerStateFindFirstOrThrowArgs>(args?: SelectSubset<T, CircuitBreakerStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CircuitBreakerStateClient<$Result.GetResult<Prisma.$CircuitBreakerStatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CircuitBreakerStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircuitBreakerStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CircuitBreakerStates
     * const circuitBreakerStates = await prisma.circuitBreakerState.findMany()
     * 
     * // Get first 10 CircuitBreakerStates
     * const circuitBreakerStates = await prisma.circuitBreakerState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const circuitBreakerStateWithIdOnly = await prisma.circuitBreakerState.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CircuitBreakerStateFindManyArgs>(args?: SelectSubset<T, CircuitBreakerStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CircuitBreakerStatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CircuitBreakerState.
     * @param {CircuitBreakerStateCreateArgs} args - Arguments to create a CircuitBreakerState.
     * @example
     * // Create one CircuitBreakerState
     * const CircuitBreakerState = await prisma.circuitBreakerState.create({
     *   data: {
     *     // ... data to create a CircuitBreakerState
     *   }
     * })
     * 
     */
    create<T extends CircuitBreakerStateCreateArgs>(args: SelectSubset<T, CircuitBreakerStateCreateArgs<ExtArgs>>): Prisma__CircuitBreakerStateClient<$Result.GetResult<Prisma.$CircuitBreakerStatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CircuitBreakerStates.
     * @param {CircuitBreakerStateCreateManyArgs} args - Arguments to create many CircuitBreakerStates.
     * @example
     * // Create many CircuitBreakerStates
     * const circuitBreakerState = await prisma.circuitBreakerState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CircuitBreakerStateCreateManyArgs>(args?: SelectSubset<T, CircuitBreakerStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CircuitBreakerStates and returns the data saved in the database.
     * @param {CircuitBreakerStateCreateManyAndReturnArgs} args - Arguments to create many CircuitBreakerStates.
     * @example
     * // Create many CircuitBreakerStates
     * const circuitBreakerState = await prisma.circuitBreakerState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CircuitBreakerStates and only return the `id`
     * const circuitBreakerStateWithIdOnly = await prisma.circuitBreakerState.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CircuitBreakerStateCreateManyAndReturnArgs>(args?: SelectSubset<T, CircuitBreakerStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CircuitBreakerStatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CircuitBreakerState.
     * @param {CircuitBreakerStateDeleteArgs} args - Arguments to delete one CircuitBreakerState.
     * @example
     * // Delete one CircuitBreakerState
     * const CircuitBreakerState = await prisma.circuitBreakerState.delete({
     *   where: {
     *     // ... filter to delete one CircuitBreakerState
     *   }
     * })
     * 
     */
    delete<T extends CircuitBreakerStateDeleteArgs>(args: SelectSubset<T, CircuitBreakerStateDeleteArgs<ExtArgs>>): Prisma__CircuitBreakerStateClient<$Result.GetResult<Prisma.$CircuitBreakerStatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CircuitBreakerState.
     * @param {CircuitBreakerStateUpdateArgs} args - Arguments to update one CircuitBreakerState.
     * @example
     * // Update one CircuitBreakerState
     * const circuitBreakerState = await prisma.circuitBreakerState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CircuitBreakerStateUpdateArgs>(args: SelectSubset<T, CircuitBreakerStateUpdateArgs<ExtArgs>>): Prisma__CircuitBreakerStateClient<$Result.GetResult<Prisma.$CircuitBreakerStatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CircuitBreakerStates.
     * @param {CircuitBreakerStateDeleteManyArgs} args - Arguments to filter CircuitBreakerStates to delete.
     * @example
     * // Delete a few CircuitBreakerStates
     * const { count } = await prisma.circuitBreakerState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CircuitBreakerStateDeleteManyArgs>(args?: SelectSubset<T, CircuitBreakerStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CircuitBreakerStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircuitBreakerStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CircuitBreakerStates
     * const circuitBreakerState = await prisma.circuitBreakerState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CircuitBreakerStateUpdateManyArgs>(args: SelectSubset<T, CircuitBreakerStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CircuitBreakerState.
     * @param {CircuitBreakerStateUpsertArgs} args - Arguments to update or create a CircuitBreakerState.
     * @example
     * // Update or create a CircuitBreakerState
     * const circuitBreakerState = await prisma.circuitBreakerState.upsert({
     *   create: {
     *     // ... data to create a CircuitBreakerState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CircuitBreakerState we want to update
     *   }
     * })
     */
    upsert<T extends CircuitBreakerStateUpsertArgs>(args: SelectSubset<T, CircuitBreakerStateUpsertArgs<ExtArgs>>): Prisma__CircuitBreakerStateClient<$Result.GetResult<Prisma.$CircuitBreakerStatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CircuitBreakerStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircuitBreakerStateCountArgs} args - Arguments to filter CircuitBreakerStates to count.
     * @example
     * // Count the number of CircuitBreakerStates
     * const count = await prisma.circuitBreakerState.count({
     *   where: {
     *     // ... the filter for the CircuitBreakerStates we want to count
     *   }
     * })
    **/
    count<T extends CircuitBreakerStateCountArgs>(
      args?: Subset<T, CircuitBreakerStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CircuitBreakerStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CircuitBreakerState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircuitBreakerStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CircuitBreakerStateAggregateArgs>(args: Subset<T, CircuitBreakerStateAggregateArgs>): Prisma.PrismaPromise<GetCircuitBreakerStateAggregateType<T>>

    /**
     * Group by CircuitBreakerState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircuitBreakerStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CircuitBreakerStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CircuitBreakerStateGroupByArgs['orderBy'] }
        : { orderBy?: CircuitBreakerStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CircuitBreakerStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCircuitBreakerStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CircuitBreakerState model
   */
  readonly fields: CircuitBreakerStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CircuitBreakerState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CircuitBreakerStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CircuitBreakerState model
   */ 
  interface CircuitBreakerStateFieldRefs {
    readonly id: FieldRef<"CircuitBreakerState", 'String'>
    readonly circuitId: FieldRef<"CircuitBreakerState", 'String'>
    readonly state: FieldRef<"CircuitBreakerState", 'String'>
    readonly failureCount: FieldRef<"CircuitBreakerState", 'Int'>
    readonly successCount: FieldRef<"CircuitBreakerState", 'Int'>
    readonly lastFailureTime: FieldRef<"CircuitBreakerState", 'DateTime'>
    readonly lastSuccessTime: FieldRef<"CircuitBreakerState", 'DateTime'>
    readonly lastHalfOpenTime: FieldRef<"CircuitBreakerState", 'DateTime'>
    readonly createdAt: FieldRef<"CircuitBreakerState", 'DateTime'>
    readonly updatedAt: FieldRef<"CircuitBreakerState", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CircuitBreakerState findUnique
   */
  export type CircuitBreakerStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreakerState
     */
    select?: CircuitBreakerStateSelect<ExtArgs> | null
    /**
     * Filter, which CircuitBreakerState to fetch.
     */
    where: CircuitBreakerStateWhereUniqueInput
  }

  /**
   * CircuitBreakerState findUniqueOrThrow
   */
  export type CircuitBreakerStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreakerState
     */
    select?: CircuitBreakerStateSelect<ExtArgs> | null
    /**
     * Filter, which CircuitBreakerState to fetch.
     */
    where: CircuitBreakerStateWhereUniqueInput
  }

  /**
   * CircuitBreakerState findFirst
   */
  export type CircuitBreakerStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreakerState
     */
    select?: CircuitBreakerStateSelect<ExtArgs> | null
    /**
     * Filter, which CircuitBreakerState to fetch.
     */
    where?: CircuitBreakerStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CircuitBreakerStates to fetch.
     */
    orderBy?: CircuitBreakerStateOrderByWithRelationInput | CircuitBreakerStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CircuitBreakerStates.
     */
    cursor?: CircuitBreakerStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CircuitBreakerStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CircuitBreakerStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CircuitBreakerStates.
     */
    distinct?: CircuitBreakerStateScalarFieldEnum | CircuitBreakerStateScalarFieldEnum[]
  }

  /**
   * CircuitBreakerState findFirstOrThrow
   */
  export type CircuitBreakerStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreakerState
     */
    select?: CircuitBreakerStateSelect<ExtArgs> | null
    /**
     * Filter, which CircuitBreakerState to fetch.
     */
    where?: CircuitBreakerStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CircuitBreakerStates to fetch.
     */
    orderBy?: CircuitBreakerStateOrderByWithRelationInput | CircuitBreakerStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CircuitBreakerStates.
     */
    cursor?: CircuitBreakerStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CircuitBreakerStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CircuitBreakerStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CircuitBreakerStates.
     */
    distinct?: CircuitBreakerStateScalarFieldEnum | CircuitBreakerStateScalarFieldEnum[]
  }

  /**
   * CircuitBreakerState findMany
   */
  export type CircuitBreakerStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreakerState
     */
    select?: CircuitBreakerStateSelect<ExtArgs> | null
    /**
     * Filter, which CircuitBreakerStates to fetch.
     */
    where?: CircuitBreakerStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CircuitBreakerStates to fetch.
     */
    orderBy?: CircuitBreakerStateOrderByWithRelationInput | CircuitBreakerStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CircuitBreakerStates.
     */
    cursor?: CircuitBreakerStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CircuitBreakerStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CircuitBreakerStates.
     */
    skip?: number
    distinct?: CircuitBreakerStateScalarFieldEnum | CircuitBreakerStateScalarFieldEnum[]
  }

  /**
   * CircuitBreakerState create
   */
  export type CircuitBreakerStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreakerState
     */
    select?: CircuitBreakerStateSelect<ExtArgs> | null
    /**
     * The data needed to create a CircuitBreakerState.
     */
    data: XOR<CircuitBreakerStateCreateInput, CircuitBreakerStateUncheckedCreateInput>
  }

  /**
   * CircuitBreakerState createMany
   */
  export type CircuitBreakerStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CircuitBreakerStates.
     */
    data: CircuitBreakerStateCreateManyInput | CircuitBreakerStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CircuitBreakerState createManyAndReturn
   */
  export type CircuitBreakerStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreakerState
     */
    select?: CircuitBreakerStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CircuitBreakerStates.
     */
    data: CircuitBreakerStateCreateManyInput | CircuitBreakerStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CircuitBreakerState update
   */
  export type CircuitBreakerStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreakerState
     */
    select?: CircuitBreakerStateSelect<ExtArgs> | null
    /**
     * The data needed to update a CircuitBreakerState.
     */
    data: XOR<CircuitBreakerStateUpdateInput, CircuitBreakerStateUncheckedUpdateInput>
    /**
     * Choose, which CircuitBreakerState to update.
     */
    where: CircuitBreakerStateWhereUniqueInput
  }

  /**
   * CircuitBreakerState updateMany
   */
  export type CircuitBreakerStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CircuitBreakerStates.
     */
    data: XOR<CircuitBreakerStateUpdateManyMutationInput, CircuitBreakerStateUncheckedUpdateManyInput>
    /**
     * Filter which CircuitBreakerStates to update
     */
    where?: CircuitBreakerStateWhereInput
  }

  /**
   * CircuitBreakerState upsert
   */
  export type CircuitBreakerStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreakerState
     */
    select?: CircuitBreakerStateSelect<ExtArgs> | null
    /**
     * The filter to search for the CircuitBreakerState to update in case it exists.
     */
    where: CircuitBreakerStateWhereUniqueInput
    /**
     * In case the CircuitBreakerState found by the `where` argument doesn't exist, create a new CircuitBreakerState with this data.
     */
    create: XOR<CircuitBreakerStateCreateInput, CircuitBreakerStateUncheckedCreateInput>
    /**
     * In case the CircuitBreakerState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CircuitBreakerStateUpdateInput, CircuitBreakerStateUncheckedUpdateInput>
  }

  /**
   * CircuitBreakerState delete
   */
  export type CircuitBreakerStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreakerState
     */
    select?: CircuitBreakerStateSelect<ExtArgs> | null
    /**
     * Filter which CircuitBreakerState to delete.
     */
    where: CircuitBreakerStateWhereUniqueInput
  }

  /**
   * CircuitBreakerState deleteMany
   */
  export type CircuitBreakerStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CircuitBreakerStates to delete
     */
    where?: CircuitBreakerStateWhereInput
  }

  /**
   * CircuitBreakerState without action
   */
  export type CircuitBreakerStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreakerState
     */
    select?: CircuitBreakerStateSelect<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    read: number
    data: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    type: string
    read: boolean
    data: JsonValue | null
    createdAt: Date | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    data?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    data?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    data?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      type: string
      read: boolean
      data: Prisma.JsonValue | null
      createdAt: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly data: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    emailEnabled: boolean | null
    pushEnabled: boolean | null
    webhookEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    telegramChatId: string | null
    discordWebhookUrl: string | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    emailEnabled: boolean | null
    pushEnabled: boolean | null
    webhookEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    telegramChatId: string | null
    discordWebhookUrl: string | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    emailEnabled: number
    pushEnabled: number
    webhookEnabled: number
    createdAt: number
    updatedAt: number
    telegramChatId: number
    discordWebhookUrl: number
    _all: number
  }


  export type NotificationPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    pushEnabled?: true
    webhookEnabled?: true
    createdAt?: true
    updatedAt?: true
    telegramChatId?: true
    discordWebhookUrl?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    pushEnabled?: true
    webhookEnabled?: true
    createdAt?: true
    updatedAt?: true
    telegramChatId?: true
    discordWebhookUrl?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    pushEnabled?: true
    webhookEnabled?: true
    createdAt?: true
    updatedAt?: true
    telegramChatId?: true
    discordWebhookUrl?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    id: string
    userId: string
    emailEnabled: boolean
    pushEnabled: boolean
    webhookEnabled: boolean
    createdAt: Date | null
    updatedAt: Date | null
    telegramChatId: string | null
    discordWebhookUrl: string | null
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    pushEnabled?: boolean
    webhookEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    telegramChatId?: boolean
    discordWebhookUrl?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    pushEnabled?: boolean
    webhookEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    telegramChatId?: boolean
    discordWebhookUrl?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    pushEnabled?: boolean
    webhookEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    telegramChatId?: boolean
    discordWebhookUrl?: boolean
  }

  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      emailEnabled: boolean
      pushEnabled: boolean
      webhookEnabled: boolean
      createdAt: Date | null
      updatedAt: Date | null
      telegramChatId: string | null
      discordWebhookUrl: string | null
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */ 
  interface NotificationPreferenceFieldRefs {
    readonly id: FieldRef<"NotificationPreference", 'String'>
    readonly userId: FieldRef<"NotificationPreference", 'String'>
    readonly emailEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly pushEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly webhookEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPreference", 'DateTime'>
    readonly telegramChatId: FieldRef<"NotificationPreference", 'String'>
    readonly discordWebhookUrl: FieldRef<"NotificationPreference", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model NotificationTemplate
   */

  export type AggregateNotificationTemplate = {
    _count: NotificationTemplateCountAggregateOutputType | null
    _min: NotificationTemplateMinAggregateOutputType | null
    _max: NotificationTemplateMaxAggregateOutputType | null
  }

  export type NotificationTemplateMinAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationTemplateMaxAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationTemplateCountAggregateOutputType = {
    id: number
    type: number
    title: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationTemplateMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationTemplateMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationTemplateCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationTemplate to aggregate.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationTemplates
    **/
    _count?: true | NotificationTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationTemplateMaxAggregateInputType
  }

  export type GetNotificationTemplateAggregateType<T extends NotificationTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationTemplate[P]>
      : GetScalarType<T[P], AggregateNotificationTemplate[P]>
  }




  export type NotificationTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationTemplateWhereInput
    orderBy?: NotificationTemplateOrderByWithAggregationInput | NotificationTemplateOrderByWithAggregationInput[]
    by: NotificationTemplateScalarFieldEnum[] | NotificationTemplateScalarFieldEnum
    having?: NotificationTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationTemplateCountAggregateInputType | true
    _min?: NotificationTemplateMinAggregateInputType
    _max?: NotificationTemplateMaxAggregateInputType
  }

  export type NotificationTemplateGroupByOutputType = {
    id: string
    type: string
    title: string
    message: string
    createdAt: Date
    updatedAt: Date
    _count: NotificationTemplateCountAggregateOutputType | null
    _min: NotificationTemplateMinAggregateOutputType | null
    _max: NotificationTemplateMaxAggregateOutputType | null
  }

  type GetNotificationTemplateGroupByPayload<T extends NotificationTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationTemplateGroupByOutputType[P]>
        }
      >
    >


  export type NotificationTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notificationTemplate"]>

  export type NotificationTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notificationTemplate"]>

  export type NotificationTemplateSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $NotificationTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      title: string
      message: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationTemplate"]>
    composites: {}
  }

  type NotificationTemplateGetPayload<S extends boolean | null | undefined | NotificationTemplateDefaultArgs> = $Result.GetResult<Prisma.$NotificationTemplatePayload, S>

  type NotificationTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationTemplateCountAggregateInputType | true
    }

  export interface NotificationTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationTemplate'], meta: { name: 'NotificationTemplate' } }
    /**
     * Find zero or one NotificationTemplate that matches the filter.
     * @param {NotificationTemplateFindUniqueArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationTemplateFindUniqueArgs>(args: SelectSubset<T, NotificationTemplateFindUniqueArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationTemplateFindUniqueOrThrowArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindFirstArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationTemplateFindFirstArgs>(args?: SelectSubset<T, NotificationTemplateFindFirstArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindFirstOrThrowArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationTemplates
     * const notificationTemplates = await prisma.notificationTemplate.findMany()
     * 
     * // Get first 10 NotificationTemplates
     * const notificationTemplates = await prisma.notificationTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationTemplateWithIdOnly = await prisma.notificationTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationTemplateFindManyArgs>(args?: SelectSubset<T, NotificationTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationTemplate.
     * @param {NotificationTemplateCreateArgs} args - Arguments to create a NotificationTemplate.
     * @example
     * // Create one NotificationTemplate
     * const NotificationTemplate = await prisma.notificationTemplate.create({
     *   data: {
     *     // ... data to create a NotificationTemplate
     *   }
     * })
     * 
     */
    create<T extends NotificationTemplateCreateArgs>(args: SelectSubset<T, NotificationTemplateCreateArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationTemplates.
     * @param {NotificationTemplateCreateManyArgs} args - Arguments to create many NotificationTemplates.
     * @example
     * // Create many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationTemplateCreateManyArgs>(args?: SelectSubset<T, NotificationTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationTemplates and returns the data saved in the database.
     * @param {NotificationTemplateCreateManyAndReturnArgs} args - Arguments to create many NotificationTemplates.
     * @example
     * // Create many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationTemplates and only return the `id`
     * const notificationTemplateWithIdOnly = await prisma.notificationTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationTemplate.
     * @param {NotificationTemplateDeleteArgs} args - Arguments to delete one NotificationTemplate.
     * @example
     * // Delete one NotificationTemplate
     * const NotificationTemplate = await prisma.notificationTemplate.delete({
     *   where: {
     *     // ... filter to delete one NotificationTemplate
     *   }
     * })
     * 
     */
    delete<T extends NotificationTemplateDeleteArgs>(args: SelectSubset<T, NotificationTemplateDeleteArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationTemplate.
     * @param {NotificationTemplateUpdateArgs} args - Arguments to update one NotificationTemplate.
     * @example
     * // Update one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationTemplateUpdateArgs>(args: SelectSubset<T, NotificationTemplateUpdateArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationTemplates.
     * @param {NotificationTemplateDeleteManyArgs} args - Arguments to filter NotificationTemplates to delete.
     * @example
     * // Delete a few NotificationTemplates
     * const { count } = await prisma.notificationTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationTemplateDeleteManyArgs>(args?: SelectSubset<T, NotificationTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationTemplateUpdateManyArgs>(args: SelectSubset<T, NotificationTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationTemplate.
     * @param {NotificationTemplateUpsertArgs} args - Arguments to update or create a NotificationTemplate.
     * @example
     * // Update or create a NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.upsert({
     *   create: {
     *     // ... data to create a NotificationTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationTemplate we want to update
     *   }
     * })
     */
    upsert<T extends NotificationTemplateUpsertArgs>(args: SelectSubset<T, NotificationTemplateUpsertArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateCountArgs} args - Arguments to filter NotificationTemplates to count.
     * @example
     * // Count the number of NotificationTemplates
     * const count = await prisma.notificationTemplate.count({
     *   where: {
     *     // ... the filter for the NotificationTemplates we want to count
     *   }
     * })
    **/
    count<T extends NotificationTemplateCountArgs>(
      args?: Subset<T, NotificationTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationTemplateAggregateArgs>(args: Subset<T, NotificationTemplateAggregateArgs>): Prisma.PrismaPromise<GetNotificationTemplateAggregateType<T>>

    /**
     * Group by NotificationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationTemplateGroupByArgs['orderBy'] }
        : { orderBy?: NotificationTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationTemplate model
   */
  readonly fields: NotificationTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationTemplate model
   */ 
  interface NotificationTemplateFieldRefs {
    readonly id: FieldRef<"NotificationTemplate", 'String'>
    readonly type: FieldRef<"NotificationTemplate", 'String'>
    readonly title: FieldRef<"NotificationTemplate", 'String'>
    readonly message: FieldRef<"NotificationTemplate", 'String'>
    readonly createdAt: FieldRef<"NotificationTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationTemplate findUnique
   */
  export type NotificationTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate findUniqueOrThrow
   */
  export type NotificationTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate findFirst
   */
  export type NotificationTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationTemplates.
     */
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[]
  }

  /**
   * NotificationTemplate findFirstOrThrow
   */
  export type NotificationTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationTemplates.
     */
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[]
  }

  /**
   * NotificationTemplate findMany
   */
  export type NotificationTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Filter, which NotificationTemplates to fetch.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[]
  }

  /**
   * NotificationTemplate create
   */
  export type NotificationTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * The data needed to create a NotificationTemplate.
     */
    data: XOR<NotificationTemplateCreateInput, NotificationTemplateUncheckedCreateInput>
  }

  /**
   * NotificationTemplate createMany
   */
  export type NotificationTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationTemplates.
     */
    data: NotificationTemplateCreateManyInput | NotificationTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationTemplate createManyAndReturn
   */
  export type NotificationTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationTemplates.
     */
    data: NotificationTemplateCreateManyInput | NotificationTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationTemplate update
   */
  export type NotificationTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * The data needed to update a NotificationTemplate.
     */
    data: XOR<NotificationTemplateUpdateInput, NotificationTemplateUncheckedUpdateInput>
    /**
     * Choose, which NotificationTemplate to update.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate updateMany
   */
  export type NotificationTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationTemplates.
     */
    data: XOR<NotificationTemplateUpdateManyMutationInput, NotificationTemplateUncheckedUpdateManyInput>
    /**
     * Filter which NotificationTemplates to update
     */
    where?: NotificationTemplateWhereInput
  }

  /**
   * NotificationTemplate upsert
   */
  export type NotificationTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * The filter to search for the NotificationTemplate to update in case it exists.
     */
    where: NotificationTemplateWhereUniqueInput
    /**
     * In case the NotificationTemplate found by the `where` argument doesn't exist, create a new NotificationTemplate with this data.
     */
    create: XOR<NotificationTemplateCreateInput, NotificationTemplateUncheckedCreateInput>
    /**
     * In case the NotificationTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationTemplateUpdateInput, NotificationTemplateUncheckedUpdateInput>
  }

  /**
   * NotificationTemplate delete
   */
  export type NotificationTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Filter which NotificationTemplate to delete.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate deleteMany
   */
  export type NotificationTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationTemplates to delete
     */
    where?: NotificationTemplateWhereInput
  }

  /**
   * NotificationTemplate without action
   */
  export type NotificationTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
  }


  /**
   * Model NotificationLog
   */

  export type AggregateNotificationLog = {
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  export type NotificationLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    channel: string | null
    status: string | null
    error: string | null
    notificationId: string | null
    createdAt: Date | null
  }

  export type NotificationLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    channel: string | null
    status: string | null
    error: string | null
    notificationId: string | null
    createdAt: Date | null
  }

  export type NotificationLogCountAggregateOutputType = {
    id: number
    userId: number
    channel: number
    status: number
    error: number
    notificationId: number
    createdAt: number
    _all: number
  }


  export type NotificationLogMinAggregateInputType = {
    id?: true
    userId?: true
    channel?: true
    status?: true
    error?: true
    notificationId?: true
    createdAt?: true
  }

  export type NotificationLogMaxAggregateInputType = {
    id?: true
    userId?: true
    channel?: true
    status?: true
    error?: true
    notificationId?: true
    createdAt?: true
  }

  export type NotificationLogCountAggregateInputType = {
    id?: true
    userId?: true
    channel?: true
    status?: true
    error?: true
    notificationId?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLog to aggregate.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationLogs
    **/
    _count?: true | NotificationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationLogMaxAggregateInputType
  }

  export type GetNotificationLogAggregateType<T extends NotificationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationLog[P]>
      : GetScalarType<T[P], AggregateNotificationLog[P]>
  }




  export type NotificationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithAggregationInput | NotificationLogOrderByWithAggregationInput[]
    by: NotificationLogScalarFieldEnum[] | NotificationLogScalarFieldEnum
    having?: NotificationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationLogCountAggregateInputType | true
    _min?: NotificationLogMinAggregateInputType
    _max?: NotificationLogMaxAggregateInputType
  }

  export type NotificationLogGroupByOutputType = {
    id: string
    userId: string
    channel: string
    status: string
    error: string | null
    notificationId: string | null
    createdAt: Date
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  type GetNotificationLogGroupByPayload<T extends NotificationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
        }
      >
    >


  export type NotificationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    channel?: boolean
    status?: boolean
    error?: boolean
    notificationId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    channel?: boolean
    status?: boolean
    error?: boolean
    notificationId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectScalar = {
    id?: boolean
    userId?: boolean
    channel?: boolean
    status?: boolean
    error?: boolean
    notificationId?: boolean
    createdAt?: boolean
  }


  export type $NotificationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      channel: string
      status: string
      error: string | null
      notificationId: string | null
      createdAt: Date
    }, ExtArgs["result"]["notificationLog"]>
    composites: {}
  }

  type NotificationLogGetPayload<S extends boolean | null | undefined | NotificationLogDefaultArgs> = $Result.GetResult<Prisma.$NotificationLogPayload, S>

  type NotificationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationLogCountAggregateInputType | true
    }

  export interface NotificationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationLog'], meta: { name: 'NotificationLog' } }
    /**
     * Find zero or one NotificationLog that matches the filter.
     * @param {NotificationLogFindUniqueArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationLogFindUniqueArgs>(args: SelectSubset<T, NotificationLogFindUniqueArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationLogFindUniqueOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationLogFindFirstArgs>(args?: SelectSubset<T, NotificationLogFindFirstArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany()
     * 
     * // Get first 10 NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationLogFindManyArgs>(args?: SelectSubset<T, NotificationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationLog.
     * @param {NotificationLogCreateArgs} args - Arguments to create a NotificationLog.
     * @example
     * // Create one NotificationLog
     * const NotificationLog = await prisma.notificationLog.create({
     *   data: {
     *     // ... data to create a NotificationLog
     *   }
     * })
     * 
     */
    create<T extends NotificationLogCreateArgs>(args: SelectSubset<T, NotificationLogCreateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationLogs.
     * @param {NotificationLogCreateManyArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationLogCreateManyArgs>(args?: SelectSubset<T, NotificationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationLogs and returns the data saved in the database.
     * @param {NotificationLogCreateManyAndReturnArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationLogs and only return the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationLog.
     * @param {NotificationLogDeleteArgs} args - Arguments to delete one NotificationLog.
     * @example
     * // Delete one NotificationLog
     * const NotificationLog = await prisma.notificationLog.delete({
     *   where: {
     *     // ... filter to delete one NotificationLog
     *   }
     * })
     * 
     */
    delete<T extends NotificationLogDeleteArgs>(args: SelectSubset<T, NotificationLogDeleteArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationLog.
     * @param {NotificationLogUpdateArgs} args - Arguments to update one NotificationLog.
     * @example
     * // Update one NotificationLog
     * const notificationLog = await prisma.notificationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationLogUpdateArgs>(args: SelectSubset<T, NotificationLogUpdateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationLogs.
     * @param {NotificationLogDeleteManyArgs} args - Arguments to filter NotificationLogs to delete.
     * @example
     * // Delete a few NotificationLogs
     * const { count } = await prisma.notificationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationLogDeleteManyArgs>(args?: SelectSubset<T, NotificationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationLogs
     * const notificationLog = await prisma.notificationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationLogUpdateManyArgs>(args: SelectSubset<T, NotificationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationLog.
     * @param {NotificationLogUpsertArgs} args - Arguments to update or create a NotificationLog.
     * @example
     * // Update or create a NotificationLog
     * const notificationLog = await prisma.notificationLog.upsert({
     *   create: {
     *     // ... data to create a NotificationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationLog we want to update
     *   }
     * })
     */
    upsert<T extends NotificationLogUpsertArgs>(args: SelectSubset<T, NotificationLogUpsertArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogCountArgs} args - Arguments to filter NotificationLogs to count.
     * @example
     * // Count the number of NotificationLogs
     * const count = await prisma.notificationLog.count({
     *   where: {
     *     // ... the filter for the NotificationLogs we want to count
     *   }
     * })
    **/
    count<T extends NotificationLogCountArgs>(
      args?: Subset<T, NotificationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationLogAggregateArgs>(args: Subset<T, NotificationLogAggregateArgs>): Prisma.PrismaPromise<GetNotificationLogAggregateType<T>>

    /**
     * Group by NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationLogGroupByArgs['orderBy'] }
        : { orderBy?: NotificationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationLog model
   */
  readonly fields: NotificationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationLog model
   */ 
  interface NotificationLogFieldRefs {
    readonly id: FieldRef<"NotificationLog", 'String'>
    readonly userId: FieldRef<"NotificationLog", 'String'>
    readonly channel: FieldRef<"NotificationLog", 'String'>
    readonly status: FieldRef<"NotificationLog", 'String'>
    readonly error: FieldRef<"NotificationLog", 'String'>
    readonly notificationId: FieldRef<"NotificationLog", 'String'>
    readonly createdAt: FieldRef<"NotificationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationLog findUnique
   */
  export type NotificationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findUniqueOrThrow
   */
  export type NotificationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findFirst
   */
  export type NotificationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findFirstOrThrow
   */
  export type NotificationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findMany
   */
  export type NotificationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLogs to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog create
   */
  export type NotificationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * The data needed to create a NotificationLog.
     */
    data: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
  }

  /**
   * NotificationLog createMany
   */
  export type NotificationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationLog createManyAndReturn
   */
  export type NotificationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationLog update
   */
  export type NotificationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * The data needed to update a NotificationLog.
     */
    data: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
    /**
     * Choose, which NotificationLog to update.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog updateMany
   */
  export type NotificationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationLogs.
     */
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which NotificationLogs to update
     */
    where?: NotificationLogWhereInput
  }

  /**
   * NotificationLog upsert
   */
  export type NotificationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * The filter to search for the NotificationLog to update in case it exists.
     */
    where: NotificationLogWhereUniqueInput
    /**
     * In case the NotificationLog found by the `where` argument doesn't exist, create a new NotificationLog with this data.
     */
    create: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
    /**
     * In case the NotificationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
  }

  /**
   * NotificationLog delete
   */
  export type NotificationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter which NotificationLog to delete.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog deleteMany
   */
  export type NotificationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLogs to delete
     */
    where?: NotificationLogWhereInput
  }

  /**
   * NotificationLog without action
   */
  export type NotificationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
  }


  /**
   * Model PricingTier
   */

  export type AggregatePricingTier = {
    _count: PricingTierCountAggregateOutputType | null
    _avg: PricingTierAvgAggregateOutputType | null
    _sum: PricingTierSumAggregateOutputType | null
    _min: PricingTierMinAggregateOutputType | null
    _max: PricingTierMaxAggregateOutputType | null
  }

  export type PricingTierAvgAggregateOutputType = {
    priceMonthly: Decimal | null
    priceYearly: Decimal | null
    workflowLimit: number | null
    executionLimit: number | null
  }

  export type PricingTierSumAggregateOutputType = {
    priceMonthly: Decimal | null
    priceYearly: Decimal | null
    workflowLimit: number | null
    executionLimit: number | null
  }

  export type PricingTierMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    priceMonthly: Decimal | null
    priceYearly: Decimal | null
    workflowLimit: number | null
    executionLimit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricingTierMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    priceMonthly: Decimal | null
    priceYearly: Decimal | null
    workflowLimit: number | null
    executionLimit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricingTierCountAggregateOutputType = {
    id: number
    name: number
    description: number
    priceMonthly: number
    priceYearly: number
    workflowLimit: number
    executionLimit: number
    features: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PricingTierAvgAggregateInputType = {
    priceMonthly?: true
    priceYearly?: true
    workflowLimit?: true
    executionLimit?: true
  }

  export type PricingTierSumAggregateInputType = {
    priceMonthly?: true
    priceYearly?: true
    workflowLimit?: true
    executionLimit?: true
  }

  export type PricingTierMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priceMonthly?: true
    priceYearly?: true
    workflowLimit?: true
    executionLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricingTierMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priceMonthly?: true
    priceYearly?: true
    workflowLimit?: true
    executionLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricingTierCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priceMonthly?: true
    priceYearly?: true
    workflowLimit?: true
    executionLimit?: true
    features?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PricingTierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PricingTier to aggregate.
     */
    where?: PricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingTiers to fetch.
     */
    orderBy?: PricingTierOrderByWithRelationInput | PricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PricingTiers
    **/
    _count?: true | PricingTierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricingTierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricingTierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricingTierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricingTierMaxAggregateInputType
  }

  export type GetPricingTierAggregateType<T extends PricingTierAggregateArgs> = {
        [P in keyof T & keyof AggregatePricingTier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricingTier[P]>
      : GetScalarType<T[P], AggregatePricingTier[P]>
  }




  export type PricingTierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PricingTierWhereInput
    orderBy?: PricingTierOrderByWithAggregationInput | PricingTierOrderByWithAggregationInput[]
    by: PricingTierScalarFieldEnum[] | PricingTierScalarFieldEnum
    having?: PricingTierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricingTierCountAggregateInputType | true
    _avg?: PricingTierAvgAggregateInputType
    _sum?: PricingTierSumAggregateInputType
    _min?: PricingTierMinAggregateInputType
    _max?: PricingTierMaxAggregateInputType
  }

  export type PricingTierGroupByOutputType = {
    id: string
    name: string
    description: string | null
    priceMonthly: Decimal
    priceYearly: Decimal
    workflowLimit: number
    executionLimit: number
    features: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PricingTierCountAggregateOutputType | null
    _avg: PricingTierAvgAggregateOutputType | null
    _sum: PricingTierSumAggregateOutputType | null
    _min: PricingTierMinAggregateOutputType | null
    _max: PricingTierMaxAggregateOutputType | null
  }

  type GetPricingTierGroupByPayload<T extends PricingTierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PricingTierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricingTierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricingTierGroupByOutputType[P]>
            : GetScalarType<T[P], PricingTierGroupByOutputType[P]>
        }
      >
    >


  export type PricingTierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    workflowLimit?: boolean
    executionLimit?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptions?: boolean | PricingTier$subscriptionsArgs<ExtArgs>
    _count?: boolean | PricingTierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pricingTier"]>

  export type PricingTierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    workflowLimit?: boolean
    executionLimit?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pricingTier"]>

  export type PricingTierSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    workflowLimit?: boolean
    executionLimit?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PricingTierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | PricingTier$subscriptionsArgs<ExtArgs>
    _count?: boolean | PricingTierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PricingTierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PricingTierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PricingTier"
    objects: {
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      priceMonthly: Prisma.Decimal
      priceYearly: Prisma.Decimal
      workflowLimit: number
      executionLimit: number
      features: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pricingTier"]>
    composites: {}
  }

  type PricingTierGetPayload<S extends boolean | null | undefined | PricingTierDefaultArgs> = $Result.GetResult<Prisma.$PricingTierPayload, S>

  type PricingTierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PricingTierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PricingTierCountAggregateInputType | true
    }

  export interface PricingTierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PricingTier'], meta: { name: 'PricingTier' } }
    /**
     * Find zero or one PricingTier that matches the filter.
     * @param {PricingTierFindUniqueArgs} args - Arguments to find a PricingTier
     * @example
     * // Get one PricingTier
     * const pricingTier = await prisma.pricingTier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PricingTierFindUniqueArgs>(args: SelectSubset<T, PricingTierFindUniqueArgs<ExtArgs>>): Prisma__PricingTierClient<$Result.GetResult<Prisma.$PricingTierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PricingTier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PricingTierFindUniqueOrThrowArgs} args - Arguments to find a PricingTier
     * @example
     * // Get one PricingTier
     * const pricingTier = await prisma.pricingTier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PricingTierFindUniqueOrThrowArgs>(args: SelectSubset<T, PricingTierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PricingTierClient<$Result.GetResult<Prisma.$PricingTierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PricingTier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingTierFindFirstArgs} args - Arguments to find a PricingTier
     * @example
     * // Get one PricingTier
     * const pricingTier = await prisma.pricingTier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PricingTierFindFirstArgs>(args?: SelectSubset<T, PricingTierFindFirstArgs<ExtArgs>>): Prisma__PricingTierClient<$Result.GetResult<Prisma.$PricingTierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PricingTier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingTierFindFirstOrThrowArgs} args - Arguments to find a PricingTier
     * @example
     * // Get one PricingTier
     * const pricingTier = await prisma.pricingTier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PricingTierFindFirstOrThrowArgs>(args?: SelectSubset<T, PricingTierFindFirstOrThrowArgs<ExtArgs>>): Prisma__PricingTierClient<$Result.GetResult<Prisma.$PricingTierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PricingTiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingTierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PricingTiers
     * const pricingTiers = await prisma.pricingTier.findMany()
     * 
     * // Get first 10 PricingTiers
     * const pricingTiers = await prisma.pricingTier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pricingTierWithIdOnly = await prisma.pricingTier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PricingTierFindManyArgs>(args?: SelectSubset<T, PricingTierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingTierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PricingTier.
     * @param {PricingTierCreateArgs} args - Arguments to create a PricingTier.
     * @example
     * // Create one PricingTier
     * const PricingTier = await prisma.pricingTier.create({
     *   data: {
     *     // ... data to create a PricingTier
     *   }
     * })
     * 
     */
    create<T extends PricingTierCreateArgs>(args: SelectSubset<T, PricingTierCreateArgs<ExtArgs>>): Prisma__PricingTierClient<$Result.GetResult<Prisma.$PricingTierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PricingTiers.
     * @param {PricingTierCreateManyArgs} args - Arguments to create many PricingTiers.
     * @example
     * // Create many PricingTiers
     * const pricingTier = await prisma.pricingTier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PricingTierCreateManyArgs>(args?: SelectSubset<T, PricingTierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PricingTiers and returns the data saved in the database.
     * @param {PricingTierCreateManyAndReturnArgs} args - Arguments to create many PricingTiers.
     * @example
     * // Create many PricingTiers
     * const pricingTier = await prisma.pricingTier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PricingTiers and only return the `id`
     * const pricingTierWithIdOnly = await prisma.pricingTier.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PricingTierCreateManyAndReturnArgs>(args?: SelectSubset<T, PricingTierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingTierPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PricingTier.
     * @param {PricingTierDeleteArgs} args - Arguments to delete one PricingTier.
     * @example
     * // Delete one PricingTier
     * const PricingTier = await prisma.pricingTier.delete({
     *   where: {
     *     // ... filter to delete one PricingTier
     *   }
     * })
     * 
     */
    delete<T extends PricingTierDeleteArgs>(args: SelectSubset<T, PricingTierDeleteArgs<ExtArgs>>): Prisma__PricingTierClient<$Result.GetResult<Prisma.$PricingTierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PricingTier.
     * @param {PricingTierUpdateArgs} args - Arguments to update one PricingTier.
     * @example
     * // Update one PricingTier
     * const pricingTier = await prisma.pricingTier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PricingTierUpdateArgs>(args: SelectSubset<T, PricingTierUpdateArgs<ExtArgs>>): Prisma__PricingTierClient<$Result.GetResult<Prisma.$PricingTierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PricingTiers.
     * @param {PricingTierDeleteManyArgs} args - Arguments to filter PricingTiers to delete.
     * @example
     * // Delete a few PricingTiers
     * const { count } = await prisma.pricingTier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PricingTierDeleteManyArgs>(args?: SelectSubset<T, PricingTierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PricingTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingTierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PricingTiers
     * const pricingTier = await prisma.pricingTier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PricingTierUpdateManyArgs>(args: SelectSubset<T, PricingTierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PricingTier.
     * @param {PricingTierUpsertArgs} args - Arguments to update or create a PricingTier.
     * @example
     * // Update or create a PricingTier
     * const pricingTier = await prisma.pricingTier.upsert({
     *   create: {
     *     // ... data to create a PricingTier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PricingTier we want to update
     *   }
     * })
     */
    upsert<T extends PricingTierUpsertArgs>(args: SelectSubset<T, PricingTierUpsertArgs<ExtArgs>>): Prisma__PricingTierClient<$Result.GetResult<Prisma.$PricingTierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PricingTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingTierCountArgs} args - Arguments to filter PricingTiers to count.
     * @example
     * // Count the number of PricingTiers
     * const count = await prisma.pricingTier.count({
     *   where: {
     *     // ... the filter for the PricingTiers we want to count
     *   }
     * })
    **/
    count<T extends PricingTierCountArgs>(
      args?: Subset<T, PricingTierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricingTierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PricingTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingTierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricingTierAggregateArgs>(args: Subset<T, PricingTierAggregateArgs>): Prisma.PrismaPromise<GetPricingTierAggregateType<T>>

    /**
     * Group by PricingTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingTierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PricingTierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PricingTierGroupByArgs['orderBy'] }
        : { orderBy?: PricingTierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PricingTierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricingTierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PricingTier model
   */
  readonly fields: PricingTierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PricingTier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PricingTierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends PricingTier$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, PricingTier$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PricingTier model
   */ 
  interface PricingTierFieldRefs {
    readonly id: FieldRef<"PricingTier", 'String'>
    readonly name: FieldRef<"PricingTier", 'String'>
    readonly description: FieldRef<"PricingTier", 'String'>
    readonly priceMonthly: FieldRef<"PricingTier", 'Decimal'>
    readonly priceYearly: FieldRef<"PricingTier", 'Decimal'>
    readonly workflowLimit: FieldRef<"PricingTier", 'Int'>
    readonly executionLimit: FieldRef<"PricingTier", 'Int'>
    readonly features: FieldRef<"PricingTier", 'Json'>
    readonly createdAt: FieldRef<"PricingTier", 'DateTime'>
    readonly updatedAt: FieldRef<"PricingTier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PricingTier findUnique
   */
  export type PricingTierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingTier
     */
    select?: PricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingTierInclude<ExtArgs> | null
    /**
     * Filter, which PricingTier to fetch.
     */
    where: PricingTierWhereUniqueInput
  }

  /**
   * PricingTier findUniqueOrThrow
   */
  export type PricingTierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingTier
     */
    select?: PricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingTierInclude<ExtArgs> | null
    /**
     * Filter, which PricingTier to fetch.
     */
    where: PricingTierWhereUniqueInput
  }

  /**
   * PricingTier findFirst
   */
  export type PricingTierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingTier
     */
    select?: PricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingTierInclude<ExtArgs> | null
    /**
     * Filter, which PricingTier to fetch.
     */
    where?: PricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingTiers to fetch.
     */
    orderBy?: PricingTierOrderByWithRelationInput | PricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PricingTiers.
     */
    cursor?: PricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PricingTiers.
     */
    distinct?: PricingTierScalarFieldEnum | PricingTierScalarFieldEnum[]
  }

  /**
   * PricingTier findFirstOrThrow
   */
  export type PricingTierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingTier
     */
    select?: PricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingTierInclude<ExtArgs> | null
    /**
     * Filter, which PricingTier to fetch.
     */
    where?: PricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingTiers to fetch.
     */
    orderBy?: PricingTierOrderByWithRelationInput | PricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PricingTiers.
     */
    cursor?: PricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PricingTiers.
     */
    distinct?: PricingTierScalarFieldEnum | PricingTierScalarFieldEnum[]
  }

  /**
   * PricingTier findMany
   */
  export type PricingTierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingTier
     */
    select?: PricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingTierInclude<ExtArgs> | null
    /**
     * Filter, which PricingTiers to fetch.
     */
    where?: PricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingTiers to fetch.
     */
    orderBy?: PricingTierOrderByWithRelationInput | PricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PricingTiers.
     */
    cursor?: PricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingTiers.
     */
    skip?: number
    distinct?: PricingTierScalarFieldEnum | PricingTierScalarFieldEnum[]
  }

  /**
   * PricingTier create
   */
  export type PricingTierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingTier
     */
    select?: PricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingTierInclude<ExtArgs> | null
    /**
     * The data needed to create a PricingTier.
     */
    data: XOR<PricingTierCreateInput, PricingTierUncheckedCreateInput>
  }

  /**
   * PricingTier createMany
   */
  export type PricingTierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PricingTiers.
     */
    data: PricingTierCreateManyInput | PricingTierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PricingTier createManyAndReturn
   */
  export type PricingTierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingTier
     */
    select?: PricingTierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PricingTiers.
     */
    data: PricingTierCreateManyInput | PricingTierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PricingTier update
   */
  export type PricingTierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingTier
     */
    select?: PricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingTierInclude<ExtArgs> | null
    /**
     * The data needed to update a PricingTier.
     */
    data: XOR<PricingTierUpdateInput, PricingTierUncheckedUpdateInput>
    /**
     * Choose, which PricingTier to update.
     */
    where: PricingTierWhereUniqueInput
  }

  /**
   * PricingTier updateMany
   */
  export type PricingTierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PricingTiers.
     */
    data: XOR<PricingTierUpdateManyMutationInput, PricingTierUncheckedUpdateManyInput>
    /**
     * Filter which PricingTiers to update
     */
    where?: PricingTierWhereInput
  }

  /**
   * PricingTier upsert
   */
  export type PricingTierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingTier
     */
    select?: PricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingTierInclude<ExtArgs> | null
    /**
     * The filter to search for the PricingTier to update in case it exists.
     */
    where: PricingTierWhereUniqueInput
    /**
     * In case the PricingTier found by the `where` argument doesn't exist, create a new PricingTier with this data.
     */
    create: XOR<PricingTierCreateInput, PricingTierUncheckedCreateInput>
    /**
     * In case the PricingTier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PricingTierUpdateInput, PricingTierUncheckedUpdateInput>
  }

  /**
   * PricingTier delete
   */
  export type PricingTierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingTier
     */
    select?: PricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingTierInclude<ExtArgs> | null
    /**
     * Filter which PricingTier to delete.
     */
    where: PricingTierWhereUniqueInput
  }

  /**
   * PricingTier deleteMany
   */
  export type PricingTierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PricingTiers to delete
     */
    where?: PricingTierWhereInput
  }

  /**
   * PricingTier.subscriptions
   */
  export type PricingTier$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * PricingTier without action
   */
  export type PricingTierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingTier
     */
    select?: PricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingTierInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tierId: string | null
    status: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    stripeSubscriptionId: string | null
    stripePriceId: string | null
    stripeCustomerId: string | null
    canceledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tierId: string | null
    status: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    stripeSubscriptionId: string | null
    stripePriceId: string | null
    stripeCustomerId: string | null
    canceledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    tierId: number
    status: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    stripeSubscriptionId: number
    stripePriceId: number
    stripeCustomerId: number
    canceledAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    tierId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    stripeCustomerId?: true
    canceledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    tierId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    stripeCustomerId?: true
    canceledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    tierId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    stripeCustomerId?: true
    canceledAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    tierId: string
    status: string
    currentPeriodStart: Date
    currentPeriodEnd: Date
    cancelAtPeriodEnd: boolean
    stripeSubscriptionId: string | null
    stripePriceId: string | null
    stripeCustomerId: string | null
    canceledAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tierId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    stripeCustomerId?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tier?: boolean | PricingTierDefaultArgs<ExtArgs>
    invoices?: boolean | Subscription$invoicesArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tierId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    stripeCustomerId?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tier?: boolean | PricingTierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    tierId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    stripeCustomerId?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tier?: boolean | PricingTierDefaultArgs<ExtArgs>
    invoices?: boolean | Subscription$invoicesArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tier?: boolean | PricingTierDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tier: Prisma.$PricingTierPayload<ExtArgs>
      invoices: Prisma.$SubscriptionInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tierId: string
      status: string
      currentPeriodStart: Date
      currentPeriodEnd: Date
      cancelAtPeriodEnd: boolean
      stripeSubscriptionId: string | null
      stripePriceId: string | null
      stripeCustomerId: string | null
      canceledAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tier<T extends PricingTierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PricingTierDefaultArgs<ExtArgs>>): Prisma__PricingTierClient<$Result.GetResult<Prisma.$PricingTierPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoices<T extends Subscription$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionInvoicePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly tierId: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly stripePriceId: FieldRef<"Subscription", 'String'>
    readonly stripeCustomerId: FieldRef<"Subscription", 'String'>
    readonly canceledAt: FieldRef<"Subscription", 'DateTime'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription.invoices
   */
  export type Subscription$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionInvoice
     */
    select?: SubscriptionInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInvoiceInclude<ExtArgs> | null
    where?: SubscriptionInvoiceWhereInput
    orderBy?: SubscriptionInvoiceOrderByWithRelationInput | SubscriptionInvoiceOrderByWithRelationInput[]
    cursor?: SubscriptionInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionInvoiceScalarFieldEnum | SubscriptionInvoiceScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionInvoice
   */

  export type AggregateSubscriptionInvoice = {
    _count: SubscriptionInvoiceCountAggregateOutputType | null
    _avg: SubscriptionInvoiceAvgAggregateOutputType | null
    _sum: SubscriptionInvoiceSumAggregateOutputType | null
    _min: SubscriptionInvoiceMinAggregateOutputType | null
    _max: SubscriptionInvoiceMaxAggregateOutputType | null
  }

  export type SubscriptionInvoiceAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type SubscriptionInvoiceSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type SubscriptionInvoiceMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    stripeInvoiceId: string | null
    amount: Decimal | null
    status: string | null
    paidAt: Date | null
    invoiceUrl: string | null
    createdAt: Date | null
  }

  export type SubscriptionInvoiceMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    stripeInvoiceId: string | null
    amount: Decimal | null
    status: string | null
    paidAt: Date | null
    invoiceUrl: string | null
    createdAt: Date | null
  }

  export type SubscriptionInvoiceCountAggregateOutputType = {
    id: number
    subscriptionId: number
    stripeInvoiceId: number
    amount: number
    status: number
    paidAt: number
    invoiceUrl: number
    createdAt: number
    _all: number
  }


  export type SubscriptionInvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type SubscriptionInvoiceSumAggregateInputType = {
    amount?: true
  }

  export type SubscriptionInvoiceMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    stripeInvoiceId?: true
    amount?: true
    status?: true
    paidAt?: true
    invoiceUrl?: true
    createdAt?: true
  }

  export type SubscriptionInvoiceMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    stripeInvoiceId?: true
    amount?: true
    status?: true
    paidAt?: true
    invoiceUrl?: true
    createdAt?: true
  }

  export type SubscriptionInvoiceCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    stripeInvoiceId?: true
    amount?: true
    status?: true
    paidAt?: true
    invoiceUrl?: true
    createdAt?: true
    _all?: true
  }

  export type SubscriptionInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionInvoice to aggregate.
     */
    where?: SubscriptionInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionInvoices to fetch.
     */
    orderBy?: SubscriptionInvoiceOrderByWithRelationInput | SubscriptionInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionInvoices
    **/
    _count?: true | SubscriptionInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionInvoiceMaxAggregateInputType
  }

  export type GetSubscriptionInvoiceAggregateType<T extends SubscriptionInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionInvoice[P]>
      : GetScalarType<T[P], AggregateSubscriptionInvoice[P]>
  }




  export type SubscriptionInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionInvoiceWhereInput
    orderBy?: SubscriptionInvoiceOrderByWithAggregationInput | SubscriptionInvoiceOrderByWithAggregationInput[]
    by: SubscriptionInvoiceScalarFieldEnum[] | SubscriptionInvoiceScalarFieldEnum
    having?: SubscriptionInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionInvoiceCountAggregateInputType | true
    _avg?: SubscriptionInvoiceAvgAggregateInputType
    _sum?: SubscriptionInvoiceSumAggregateInputType
    _min?: SubscriptionInvoiceMinAggregateInputType
    _max?: SubscriptionInvoiceMaxAggregateInputType
  }

  export type SubscriptionInvoiceGroupByOutputType = {
    id: string
    subscriptionId: string
    stripeInvoiceId: string | null
    amount: Decimal
    status: string
    paidAt: Date | null
    invoiceUrl: string | null
    createdAt: Date
    _count: SubscriptionInvoiceCountAggregateOutputType | null
    _avg: SubscriptionInvoiceAvgAggregateOutputType | null
    _sum: SubscriptionInvoiceSumAggregateOutputType | null
    _min: SubscriptionInvoiceMinAggregateOutputType | null
    _max: SubscriptionInvoiceMaxAggregateOutputType | null
  }

  type GetSubscriptionInvoiceGroupByPayload<T extends SubscriptionInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    stripeInvoiceId?: boolean
    amount?: boolean
    status?: boolean
    paidAt?: boolean
    invoiceUrl?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionInvoice"]>

  export type SubscriptionInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    stripeInvoiceId?: boolean
    amount?: boolean
    status?: boolean
    paidAt?: boolean
    invoiceUrl?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionInvoice"]>

  export type SubscriptionInvoiceSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    stripeInvoiceId?: boolean
    amount?: boolean
    status?: boolean
    paidAt?: boolean
    invoiceUrl?: boolean
    createdAt?: boolean
  }

  export type SubscriptionInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type SubscriptionInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $SubscriptionInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionInvoice"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      stripeInvoiceId: string | null
      amount: Prisma.Decimal
      status: string
      paidAt: Date | null
      invoiceUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["subscriptionInvoice"]>
    composites: {}
  }

  type SubscriptionInvoiceGetPayload<S extends boolean | null | undefined | SubscriptionInvoiceDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionInvoicePayload, S>

  type SubscriptionInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionInvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionInvoiceCountAggregateInputType | true
    }

  export interface SubscriptionInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionInvoice'], meta: { name: 'SubscriptionInvoice' } }
    /**
     * Find zero or one SubscriptionInvoice that matches the filter.
     * @param {SubscriptionInvoiceFindUniqueArgs} args - Arguments to find a SubscriptionInvoice
     * @example
     * // Get one SubscriptionInvoice
     * const subscriptionInvoice = await prisma.subscriptionInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionInvoiceFindUniqueArgs>(args: SelectSubset<T, SubscriptionInvoiceFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionInvoiceClient<$Result.GetResult<Prisma.$SubscriptionInvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubscriptionInvoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionInvoiceFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionInvoice
     * @example
     * // Get one SubscriptionInvoice
     * const subscriptionInvoice = await prisma.subscriptionInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionInvoiceClient<$Result.GetResult<Prisma.$SubscriptionInvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubscriptionInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionInvoiceFindFirstArgs} args - Arguments to find a SubscriptionInvoice
     * @example
     * // Get one SubscriptionInvoice
     * const subscriptionInvoice = await prisma.subscriptionInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionInvoiceFindFirstArgs>(args?: SelectSubset<T, SubscriptionInvoiceFindFirstArgs<ExtArgs>>): Prisma__SubscriptionInvoiceClient<$Result.GetResult<Prisma.$SubscriptionInvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubscriptionInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionInvoiceFindFirstOrThrowArgs} args - Arguments to find a SubscriptionInvoice
     * @example
     * // Get one SubscriptionInvoice
     * const subscriptionInvoice = await prisma.subscriptionInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionInvoiceClient<$Result.GetResult<Prisma.$SubscriptionInvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubscriptionInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionInvoices
     * const subscriptionInvoices = await prisma.subscriptionInvoice.findMany()
     * 
     * // Get first 10 SubscriptionInvoices
     * const subscriptionInvoices = await prisma.subscriptionInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionInvoiceWithIdOnly = await prisma.subscriptionInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionInvoiceFindManyArgs>(args?: SelectSubset<T, SubscriptionInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionInvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubscriptionInvoice.
     * @param {SubscriptionInvoiceCreateArgs} args - Arguments to create a SubscriptionInvoice.
     * @example
     * // Create one SubscriptionInvoice
     * const SubscriptionInvoice = await prisma.subscriptionInvoice.create({
     *   data: {
     *     // ... data to create a SubscriptionInvoice
     *   }
     * })
     * 
     */
    create<T extends SubscriptionInvoiceCreateArgs>(args: SelectSubset<T, SubscriptionInvoiceCreateArgs<ExtArgs>>): Prisma__SubscriptionInvoiceClient<$Result.GetResult<Prisma.$SubscriptionInvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubscriptionInvoices.
     * @param {SubscriptionInvoiceCreateManyArgs} args - Arguments to create many SubscriptionInvoices.
     * @example
     * // Create many SubscriptionInvoices
     * const subscriptionInvoice = await prisma.subscriptionInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionInvoiceCreateManyArgs>(args?: SelectSubset<T, SubscriptionInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionInvoices and returns the data saved in the database.
     * @param {SubscriptionInvoiceCreateManyAndReturnArgs} args - Arguments to create many SubscriptionInvoices.
     * @example
     * // Create many SubscriptionInvoices
     * const subscriptionInvoice = await prisma.subscriptionInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionInvoices and only return the `id`
     * const subscriptionInvoiceWithIdOnly = await prisma.subscriptionInvoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionInvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubscriptionInvoice.
     * @param {SubscriptionInvoiceDeleteArgs} args - Arguments to delete one SubscriptionInvoice.
     * @example
     * // Delete one SubscriptionInvoice
     * const SubscriptionInvoice = await prisma.subscriptionInvoice.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionInvoice
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionInvoiceDeleteArgs>(args: SelectSubset<T, SubscriptionInvoiceDeleteArgs<ExtArgs>>): Prisma__SubscriptionInvoiceClient<$Result.GetResult<Prisma.$SubscriptionInvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubscriptionInvoice.
     * @param {SubscriptionInvoiceUpdateArgs} args - Arguments to update one SubscriptionInvoice.
     * @example
     * // Update one SubscriptionInvoice
     * const subscriptionInvoice = await prisma.subscriptionInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionInvoiceUpdateArgs>(args: SelectSubset<T, SubscriptionInvoiceUpdateArgs<ExtArgs>>): Prisma__SubscriptionInvoiceClient<$Result.GetResult<Prisma.$SubscriptionInvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubscriptionInvoices.
     * @param {SubscriptionInvoiceDeleteManyArgs} args - Arguments to filter SubscriptionInvoices to delete.
     * @example
     * // Delete a few SubscriptionInvoices
     * const { count } = await prisma.subscriptionInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionInvoiceDeleteManyArgs>(args?: SelectSubset<T, SubscriptionInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionInvoices
     * const subscriptionInvoice = await prisma.subscriptionInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionInvoiceUpdateManyArgs>(args: SelectSubset<T, SubscriptionInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubscriptionInvoice.
     * @param {SubscriptionInvoiceUpsertArgs} args - Arguments to update or create a SubscriptionInvoice.
     * @example
     * // Update or create a SubscriptionInvoice
     * const subscriptionInvoice = await prisma.subscriptionInvoice.upsert({
     *   create: {
     *     // ... data to create a SubscriptionInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionInvoice we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionInvoiceUpsertArgs>(args: SelectSubset<T, SubscriptionInvoiceUpsertArgs<ExtArgs>>): Prisma__SubscriptionInvoiceClient<$Result.GetResult<Prisma.$SubscriptionInvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubscriptionInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionInvoiceCountArgs} args - Arguments to filter SubscriptionInvoices to count.
     * @example
     * // Count the number of SubscriptionInvoices
     * const count = await prisma.subscriptionInvoice.count({
     *   where: {
     *     // ... the filter for the SubscriptionInvoices we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionInvoiceCountArgs>(
      args?: Subset<T, SubscriptionInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionInvoiceAggregateArgs>(args: Subset<T, SubscriptionInvoiceAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionInvoiceAggregateType<T>>

    /**
     * Group by SubscriptionInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionInvoice model
   */
  readonly fields: SubscriptionInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionInvoice model
   */ 
  interface SubscriptionInvoiceFieldRefs {
    readonly id: FieldRef<"SubscriptionInvoice", 'String'>
    readonly subscriptionId: FieldRef<"SubscriptionInvoice", 'String'>
    readonly stripeInvoiceId: FieldRef<"SubscriptionInvoice", 'String'>
    readonly amount: FieldRef<"SubscriptionInvoice", 'Decimal'>
    readonly status: FieldRef<"SubscriptionInvoice", 'String'>
    readonly paidAt: FieldRef<"SubscriptionInvoice", 'DateTime'>
    readonly invoiceUrl: FieldRef<"SubscriptionInvoice", 'String'>
    readonly createdAt: FieldRef<"SubscriptionInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionInvoice findUnique
   */
  export type SubscriptionInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionInvoice
     */
    select?: SubscriptionInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionInvoice to fetch.
     */
    where: SubscriptionInvoiceWhereUniqueInput
  }

  /**
   * SubscriptionInvoice findUniqueOrThrow
   */
  export type SubscriptionInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionInvoice
     */
    select?: SubscriptionInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionInvoice to fetch.
     */
    where: SubscriptionInvoiceWhereUniqueInput
  }

  /**
   * SubscriptionInvoice findFirst
   */
  export type SubscriptionInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionInvoice
     */
    select?: SubscriptionInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionInvoice to fetch.
     */
    where?: SubscriptionInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionInvoices to fetch.
     */
    orderBy?: SubscriptionInvoiceOrderByWithRelationInput | SubscriptionInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionInvoices.
     */
    cursor?: SubscriptionInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionInvoices.
     */
    distinct?: SubscriptionInvoiceScalarFieldEnum | SubscriptionInvoiceScalarFieldEnum[]
  }

  /**
   * SubscriptionInvoice findFirstOrThrow
   */
  export type SubscriptionInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionInvoice
     */
    select?: SubscriptionInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionInvoice to fetch.
     */
    where?: SubscriptionInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionInvoices to fetch.
     */
    orderBy?: SubscriptionInvoiceOrderByWithRelationInput | SubscriptionInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionInvoices.
     */
    cursor?: SubscriptionInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionInvoices.
     */
    distinct?: SubscriptionInvoiceScalarFieldEnum | SubscriptionInvoiceScalarFieldEnum[]
  }

  /**
   * SubscriptionInvoice findMany
   */
  export type SubscriptionInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionInvoice
     */
    select?: SubscriptionInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionInvoices to fetch.
     */
    where?: SubscriptionInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionInvoices to fetch.
     */
    orderBy?: SubscriptionInvoiceOrderByWithRelationInput | SubscriptionInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionInvoices.
     */
    cursor?: SubscriptionInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionInvoices.
     */
    skip?: number
    distinct?: SubscriptionInvoiceScalarFieldEnum | SubscriptionInvoiceScalarFieldEnum[]
  }

  /**
   * SubscriptionInvoice create
   */
  export type SubscriptionInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionInvoice
     */
    select?: SubscriptionInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionInvoice.
     */
    data: XOR<SubscriptionInvoiceCreateInput, SubscriptionInvoiceUncheckedCreateInput>
  }

  /**
   * SubscriptionInvoice createMany
   */
  export type SubscriptionInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionInvoices.
     */
    data: SubscriptionInvoiceCreateManyInput | SubscriptionInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionInvoice createManyAndReturn
   */
  export type SubscriptionInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionInvoice
     */
    select?: SubscriptionInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubscriptionInvoices.
     */
    data: SubscriptionInvoiceCreateManyInput | SubscriptionInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionInvoice update
   */
  export type SubscriptionInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionInvoice
     */
    select?: SubscriptionInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionInvoice.
     */
    data: XOR<SubscriptionInvoiceUpdateInput, SubscriptionInvoiceUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionInvoice to update.
     */
    where: SubscriptionInvoiceWhereUniqueInput
  }

  /**
   * SubscriptionInvoice updateMany
   */
  export type SubscriptionInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionInvoices.
     */
    data: XOR<SubscriptionInvoiceUpdateManyMutationInput, SubscriptionInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionInvoices to update
     */
    where?: SubscriptionInvoiceWhereInput
  }

  /**
   * SubscriptionInvoice upsert
   */
  export type SubscriptionInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionInvoice
     */
    select?: SubscriptionInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionInvoice to update in case it exists.
     */
    where: SubscriptionInvoiceWhereUniqueInput
    /**
     * In case the SubscriptionInvoice found by the `where` argument doesn't exist, create a new SubscriptionInvoice with this data.
     */
    create: XOR<SubscriptionInvoiceCreateInput, SubscriptionInvoiceUncheckedCreateInput>
    /**
     * In case the SubscriptionInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionInvoiceUpdateInput, SubscriptionInvoiceUncheckedUpdateInput>
  }

  /**
   * SubscriptionInvoice delete
   */
  export type SubscriptionInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionInvoice
     */
    select?: SubscriptionInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInvoiceInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionInvoice to delete.
     */
    where: SubscriptionInvoiceWhereUniqueInput
  }

  /**
   * SubscriptionInvoice deleteMany
   */
  export type SubscriptionInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionInvoices to delete
     */
    where?: SubscriptionInvoiceWhereInput
  }

  /**
   * SubscriptionInvoice without action
   */
  export type SubscriptionInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionInvoice
     */
    select?: SubscriptionInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdBy: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$TeamMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdBy: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */ 
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly createdBy: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberMinAggregateOutputType = {
    teamId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    teamId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    teamId: number
    userId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type TeamMemberMinAggregateInputType = {
    teamId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    teamId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    teamId?: true
    userId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    teamId: string
    userId: string
    role: string
    joinedAt: Date | null
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teamId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teamId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectScalar = {
    teamId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type TeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      teamId: string
      userId: string
      role: string
      joinedAt: Date | null
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `teamId`
     * const teamMemberWithTeamIdOnly = await prisma.teamMember.findMany({ select: { teamId: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamMembers and returns the data saved in the database.
     * @param {TeamMemberCreateManyAndReturnArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamMembers and only return the `teamId`
     * const teamMemberWithTeamIdOnly = await prisma.teamMember.createManyAndReturn({ 
     *   select: { teamId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */ 
  interface TeamMemberFieldRefs {
    readonly teamId: FieldRef<"TeamMember", 'String'>
    readonly userId: FieldRef<"TeamMember", 'String'>
    readonly role: FieldRef<"TeamMember", 'String'>
    readonly joinedAt: FieldRef<"TeamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember createManyAndReturn
   */
  export type TeamMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    resourceId: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    resource: string | null
    resourceId: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      resource: string | null
      resourceId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
  }


  /**
   * Model UsageLog
   */

  export type AggregateUsageLog = {
    _count: UsageLogCountAggregateOutputType | null
    _avg: UsageLogAvgAggregateOutputType | null
    _sum: UsageLogSumAggregateOutputType | null
    _min: UsageLogMinAggregateOutputType | null
    _max: UsageLogMaxAggregateOutputType | null
  }

  export type UsageLogAvgAggregateOutputType = {
    quantity: number | null
  }

  export type UsageLogSumAggregateOutputType = {
    quantity: number | null
  }

  export type UsageLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resourceType: string | null
    action: string | null
    quantity: number | null
    createdAt: Date | null
  }

  export type UsageLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resourceType: string | null
    action: string | null
    quantity: number | null
    createdAt: Date | null
  }

  export type UsageLogCountAggregateOutputType = {
    id: number
    userId: number
    resourceType: number
    action: number
    quantity: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type UsageLogAvgAggregateInputType = {
    quantity?: true
  }

  export type UsageLogSumAggregateInputType = {
    quantity?: true
  }

  export type UsageLogMinAggregateInputType = {
    id?: true
    userId?: true
    resourceType?: true
    action?: true
    quantity?: true
    createdAt?: true
  }

  export type UsageLogMaxAggregateInputType = {
    id?: true
    userId?: true
    resourceType?: true
    action?: true
    quantity?: true
    createdAt?: true
  }

  export type UsageLogCountAggregateInputType = {
    id?: true
    userId?: true
    resourceType?: true
    action?: true
    quantity?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type UsageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageLog to aggregate.
     */
    where?: UsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLogs to fetch.
     */
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageLogs
    **/
    _count?: true | UsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageLogMaxAggregateInputType
  }

  export type GetUsageLogAggregateType<T extends UsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageLog[P]>
      : GetScalarType<T[P], AggregateUsageLog[P]>
  }




  export type UsageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageLogWhereInput
    orderBy?: UsageLogOrderByWithAggregationInput | UsageLogOrderByWithAggregationInput[]
    by: UsageLogScalarFieldEnum[] | UsageLogScalarFieldEnum
    having?: UsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageLogCountAggregateInputType | true
    _avg?: UsageLogAvgAggregateInputType
    _sum?: UsageLogSumAggregateInputType
    _min?: UsageLogMinAggregateInputType
    _max?: UsageLogMaxAggregateInputType
  }

  export type UsageLogGroupByOutputType = {
    id: string
    userId: string
    resourceType: string
    action: string
    quantity: number
    metadata: JsonValue | null
    createdAt: Date
    _count: UsageLogCountAggregateOutputType | null
    _avg: UsageLogAvgAggregateOutputType | null
    _sum: UsageLogSumAggregateOutputType | null
    _min: UsageLogMinAggregateOutputType | null
    _max: UsageLogMaxAggregateOutputType | null
  }

  type GetUsageLogGroupByPayload<T extends UsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], UsageLogGroupByOutputType[P]>
        }
      >
    >


  export type UsageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resourceType?: boolean
    action?: boolean
    quantity?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["usageLog"]>

  export type UsageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resourceType?: boolean
    action?: boolean
    quantity?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["usageLog"]>

  export type UsageLogSelectScalar = {
    id?: boolean
    userId?: boolean
    resourceType?: boolean
    action?: boolean
    quantity?: boolean
    metadata?: boolean
    createdAt?: boolean
  }


  export type $UsageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      resourceType: string
      action: string
      quantity: number
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["usageLog"]>
    composites: {}
  }

  type UsageLogGetPayload<S extends boolean | null | undefined | UsageLogDefaultArgs> = $Result.GetResult<Prisma.$UsageLogPayload, S>

  type UsageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsageLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsageLogCountAggregateInputType | true
    }

  export interface UsageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageLog'], meta: { name: 'UsageLog' } }
    /**
     * Find zero or one UsageLog that matches the filter.
     * @param {UsageLogFindUniqueArgs} args - Arguments to find a UsageLog
     * @example
     * // Get one UsageLog
     * const usageLog = await prisma.usageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageLogFindUniqueArgs>(args: SelectSubset<T, UsageLogFindUniqueArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsageLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsageLogFindUniqueOrThrowArgs} args - Arguments to find a UsageLog
     * @example
     * // Get one UsageLog
     * const usageLog = await prisma.usageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogFindFirstArgs} args - Arguments to find a UsageLog
     * @example
     * // Get one UsageLog
     * const usageLog = await prisma.usageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageLogFindFirstArgs>(args?: SelectSubset<T, UsageLogFindFirstArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogFindFirstOrThrowArgs} args - Arguments to find a UsageLog
     * @example
     * // Get one UsageLog
     * const usageLog = await prisma.usageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageLogs
     * const usageLogs = await prisma.usageLog.findMany()
     * 
     * // Get first 10 UsageLogs
     * const usageLogs = await prisma.usageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageLogWithIdOnly = await prisma.usageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageLogFindManyArgs>(args?: SelectSubset<T, UsageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsageLog.
     * @param {UsageLogCreateArgs} args - Arguments to create a UsageLog.
     * @example
     * // Create one UsageLog
     * const UsageLog = await prisma.usageLog.create({
     *   data: {
     *     // ... data to create a UsageLog
     *   }
     * })
     * 
     */
    create<T extends UsageLogCreateArgs>(args: SelectSubset<T, UsageLogCreateArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsageLogs.
     * @param {UsageLogCreateManyArgs} args - Arguments to create many UsageLogs.
     * @example
     * // Create many UsageLogs
     * const usageLog = await prisma.usageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageLogCreateManyArgs>(args?: SelectSubset<T, UsageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageLogs and returns the data saved in the database.
     * @param {UsageLogCreateManyAndReturnArgs} args - Arguments to create many UsageLogs.
     * @example
     * // Create many UsageLogs
     * const usageLog = await prisma.usageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageLogs and only return the `id`
     * const usageLogWithIdOnly = await prisma.usageLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UsageLog.
     * @param {UsageLogDeleteArgs} args - Arguments to delete one UsageLog.
     * @example
     * // Delete one UsageLog
     * const UsageLog = await prisma.usageLog.delete({
     *   where: {
     *     // ... filter to delete one UsageLog
     *   }
     * })
     * 
     */
    delete<T extends UsageLogDeleteArgs>(args: SelectSubset<T, UsageLogDeleteArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsageLog.
     * @param {UsageLogUpdateArgs} args - Arguments to update one UsageLog.
     * @example
     * // Update one UsageLog
     * const usageLog = await prisma.usageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageLogUpdateArgs>(args: SelectSubset<T, UsageLogUpdateArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsageLogs.
     * @param {UsageLogDeleteManyArgs} args - Arguments to filter UsageLogs to delete.
     * @example
     * // Delete a few UsageLogs
     * const { count } = await prisma.usageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageLogDeleteManyArgs>(args?: SelectSubset<T, UsageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageLogs
     * const usageLog = await prisma.usageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageLogUpdateManyArgs>(args: SelectSubset<T, UsageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsageLog.
     * @param {UsageLogUpsertArgs} args - Arguments to update or create a UsageLog.
     * @example
     * // Update or create a UsageLog
     * const usageLog = await prisma.usageLog.upsert({
     *   create: {
     *     // ... data to create a UsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageLog we want to update
     *   }
     * })
     */
    upsert<T extends UsageLogUpsertArgs>(args: SelectSubset<T, UsageLogUpsertArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogCountArgs} args - Arguments to filter UsageLogs to count.
     * @example
     * // Count the number of UsageLogs
     * const count = await prisma.usageLog.count({
     *   where: {
     *     // ... the filter for the UsageLogs we want to count
     *   }
     * })
    **/
    count<T extends UsageLogCountArgs>(
      args?: Subset<T, UsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageLogAggregateArgs>(args: Subset<T, UsageLogAggregateArgs>): Prisma.PrismaPromise<GetUsageLogAggregateType<T>>

    /**
     * Group by UsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageLogGroupByArgs['orderBy'] }
        : { orderBy?: UsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageLog model
   */
  readonly fields: UsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageLog model
   */ 
  interface UsageLogFieldRefs {
    readonly id: FieldRef<"UsageLog", 'String'>
    readonly userId: FieldRef<"UsageLog", 'String'>
    readonly resourceType: FieldRef<"UsageLog", 'String'>
    readonly action: FieldRef<"UsageLog", 'String'>
    readonly quantity: FieldRef<"UsageLog", 'Int'>
    readonly metadata: FieldRef<"UsageLog", 'Json'>
    readonly createdAt: FieldRef<"UsageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageLog findUnique
   */
  export type UsageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Filter, which UsageLog to fetch.
     */
    where: UsageLogWhereUniqueInput
  }

  /**
   * UsageLog findUniqueOrThrow
   */
  export type UsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Filter, which UsageLog to fetch.
     */
    where: UsageLogWhereUniqueInput
  }

  /**
   * UsageLog findFirst
   */
  export type UsageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Filter, which UsageLog to fetch.
     */
    where?: UsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLogs to fetch.
     */
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageLogs.
     */
    cursor?: UsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageLogs.
     */
    distinct?: UsageLogScalarFieldEnum | UsageLogScalarFieldEnum[]
  }

  /**
   * UsageLog findFirstOrThrow
   */
  export type UsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Filter, which UsageLog to fetch.
     */
    where?: UsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLogs to fetch.
     */
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageLogs.
     */
    cursor?: UsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageLogs.
     */
    distinct?: UsageLogScalarFieldEnum | UsageLogScalarFieldEnum[]
  }

  /**
   * UsageLog findMany
   */
  export type UsageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Filter, which UsageLogs to fetch.
     */
    where?: UsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLogs to fetch.
     */
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageLogs.
     */
    cursor?: UsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLogs.
     */
    skip?: number
    distinct?: UsageLogScalarFieldEnum | UsageLogScalarFieldEnum[]
  }

  /**
   * UsageLog create
   */
  export type UsageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * The data needed to create a UsageLog.
     */
    data: XOR<UsageLogCreateInput, UsageLogUncheckedCreateInput>
  }

  /**
   * UsageLog createMany
   */
  export type UsageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageLogs.
     */
    data: UsageLogCreateManyInput | UsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageLog createManyAndReturn
   */
  export type UsageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UsageLogs.
     */
    data: UsageLogCreateManyInput | UsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageLog update
   */
  export type UsageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * The data needed to update a UsageLog.
     */
    data: XOR<UsageLogUpdateInput, UsageLogUncheckedUpdateInput>
    /**
     * Choose, which UsageLog to update.
     */
    where: UsageLogWhereUniqueInput
  }

  /**
   * UsageLog updateMany
   */
  export type UsageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageLogs.
     */
    data: XOR<UsageLogUpdateManyMutationInput, UsageLogUncheckedUpdateManyInput>
    /**
     * Filter which UsageLogs to update
     */
    where?: UsageLogWhereInput
  }

  /**
   * UsageLog upsert
   */
  export type UsageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * The filter to search for the UsageLog to update in case it exists.
     */
    where: UsageLogWhereUniqueInput
    /**
     * In case the UsageLog found by the `where` argument doesn't exist, create a new UsageLog with this data.
     */
    create: XOR<UsageLogCreateInput, UsageLogUncheckedCreateInput>
    /**
     * In case the UsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageLogUpdateInput, UsageLogUncheckedUpdateInput>
  }

  /**
   * UsageLog delete
   */
  export type UsageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Filter which UsageLog to delete.
     */
    where: UsageLogWhereUniqueInput
  }

  /**
   * UsageLog deleteMany
   */
  export type UsageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageLogs to delete
     */
    where?: UsageLogWhereInput
  }

  /**
   * UsageLog without action
   */
  export type UsageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
  }


  /**
   * Model WalletTransaction
   */

  export type AggregateWalletTransaction = {
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  export type WalletTransactionAvgAggregateOutputType = {
    chainId: number | null
    blockNumber: number | null
  }

  export type WalletTransactionSumAggregateOutputType = {
    chainId: number | null
    blockNumber: number | null
  }

  export type WalletTransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    walletAddress: string | null
    txHash: string | null
    chainId: number | null
    value: string | null
    status: string | null
    blockNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletTransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    walletAddress: string | null
    txHash: string | null
    chainId: number | null
    value: string | null
    status: string | null
    blockNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletTransactionCountAggregateOutputType = {
    id: number
    userId: number
    walletAddress: number
    txHash: number
    chainId: number
    value: number
    status: number
    blockNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WalletTransactionAvgAggregateInputType = {
    chainId?: true
    blockNumber?: true
  }

  export type WalletTransactionSumAggregateInputType = {
    chainId?: true
    blockNumber?: true
  }

  export type WalletTransactionMinAggregateInputType = {
    id?: true
    userId?: true
    walletAddress?: true
    txHash?: true
    chainId?: true
    value?: true
    status?: true
    blockNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletTransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    walletAddress?: true
    txHash?: true
    chainId?: true
    value?: true
    status?: true
    blockNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletTransactionCountAggregateInputType = {
    id?: true
    userId?: true
    walletAddress?: true
    txHash?: true
    chainId?: true
    value?: true
    status?: true
    blockNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransaction to aggregate.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WalletTransactions
    **/
    _count?: true | WalletTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type GetWalletTransactionAggregateType<T extends WalletTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateWalletTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWalletTransaction[P]>
      : GetScalarType<T[P], AggregateWalletTransaction[P]>
  }




  export type WalletTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithAggregationInput | WalletTransactionOrderByWithAggregationInput[]
    by: WalletTransactionScalarFieldEnum[] | WalletTransactionScalarFieldEnum
    having?: WalletTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletTransactionCountAggregateInputType | true
    _avg?: WalletTransactionAvgAggregateInputType
    _sum?: WalletTransactionSumAggregateInputType
    _min?: WalletTransactionMinAggregateInputType
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type WalletTransactionGroupByOutputType = {
    id: string
    userId: string
    walletAddress: string
    txHash: string
    chainId: number
    value: string
    status: string
    blockNumber: number | null
    createdAt: Date
    updatedAt: Date
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  type GetWalletTransactionGroupByPayload<T extends WalletTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
        }
      >
    >


  export type WalletTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    walletAddress?: boolean
    txHash?: boolean
    chainId?: boolean
    value?: boolean
    status?: boolean
    blockNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    walletAddress?: boolean
    txHash?: boolean
    chainId?: boolean
    value?: boolean
    status?: boolean
    blockNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    walletAddress?: boolean
    txHash?: boolean
    chainId?: boolean
    value?: boolean
    status?: boolean
    blockNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $WalletTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WalletTransaction"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      walletAddress: string
      txHash: string
      chainId: number
      value: string
      status: string
      blockNumber: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["walletTransaction"]>
    composites: {}
  }

  type WalletTransactionGetPayload<S extends boolean | null | undefined | WalletTransactionDefaultArgs> = $Result.GetResult<Prisma.$WalletTransactionPayload, S>

  type WalletTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WalletTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WalletTransactionCountAggregateInputType | true
    }

  export interface WalletTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WalletTransaction'], meta: { name: 'WalletTransaction' } }
    /**
     * Find zero or one WalletTransaction that matches the filter.
     * @param {WalletTransactionFindUniqueArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletTransactionFindUniqueArgs>(args: SelectSubset<T, WalletTransactionFindUniqueArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WalletTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WalletTransactionFindUniqueOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WalletTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletTransactionFindFirstArgs>(args?: SelectSubset<T, WalletTransactionFindFirstArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WalletTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WalletTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany()
     * 
     * // Get first 10 WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletTransactionFindManyArgs>(args?: SelectSubset<T, WalletTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WalletTransaction.
     * @param {WalletTransactionCreateArgs} args - Arguments to create a WalletTransaction.
     * @example
     * // Create one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.create({
     *   data: {
     *     // ... data to create a WalletTransaction
     *   }
     * })
     * 
     */
    create<T extends WalletTransactionCreateArgs>(args: SelectSubset<T, WalletTransactionCreateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WalletTransactions.
     * @param {WalletTransactionCreateManyArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletTransactionCreateManyArgs>(args?: SelectSubset<T, WalletTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WalletTransactions and returns the data saved in the database.
     * @param {WalletTransactionCreateManyAndReturnArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WalletTransactions and only return the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WalletTransaction.
     * @param {WalletTransactionDeleteArgs} args - Arguments to delete one WalletTransaction.
     * @example
     * // Delete one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.delete({
     *   where: {
     *     // ... filter to delete one WalletTransaction
     *   }
     * })
     * 
     */
    delete<T extends WalletTransactionDeleteArgs>(args: SelectSubset<T, WalletTransactionDeleteArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WalletTransaction.
     * @param {WalletTransactionUpdateArgs} args - Arguments to update one WalletTransaction.
     * @example
     * // Update one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletTransactionUpdateArgs>(args: SelectSubset<T, WalletTransactionUpdateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WalletTransactions.
     * @param {WalletTransactionDeleteManyArgs} args - Arguments to filter WalletTransactions to delete.
     * @example
     * // Delete a few WalletTransactions
     * const { count } = await prisma.walletTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletTransactionDeleteManyArgs>(args?: SelectSubset<T, WalletTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletTransactionUpdateManyArgs>(args: SelectSubset<T, WalletTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WalletTransaction.
     * @param {WalletTransactionUpsertArgs} args - Arguments to update or create a WalletTransaction.
     * @example
     * // Update or create a WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.upsert({
     *   create: {
     *     // ... data to create a WalletTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WalletTransaction we want to update
     *   }
     * })
     */
    upsert<T extends WalletTransactionUpsertArgs>(args: SelectSubset<T, WalletTransactionUpsertArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionCountArgs} args - Arguments to filter WalletTransactions to count.
     * @example
     * // Count the number of WalletTransactions
     * const count = await prisma.walletTransaction.count({
     *   where: {
     *     // ... the filter for the WalletTransactions we want to count
     *   }
     * })
    **/
    count<T extends WalletTransactionCountArgs>(
      args?: Subset<T, WalletTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletTransactionAggregateArgs>(args: Subset<T, WalletTransactionAggregateArgs>): Prisma.PrismaPromise<GetWalletTransactionAggregateType<T>>

    /**
     * Group by WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletTransactionGroupByArgs['orderBy'] }
        : { orderBy?: WalletTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WalletTransaction model
   */
  readonly fields: WalletTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WalletTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WalletTransaction model
   */ 
  interface WalletTransactionFieldRefs {
    readonly id: FieldRef<"WalletTransaction", 'String'>
    readonly userId: FieldRef<"WalletTransaction", 'String'>
    readonly walletAddress: FieldRef<"WalletTransaction", 'String'>
    readonly txHash: FieldRef<"WalletTransaction", 'String'>
    readonly chainId: FieldRef<"WalletTransaction", 'Int'>
    readonly value: FieldRef<"WalletTransaction", 'String'>
    readonly status: FieldRef<"WalletTransaction", 'String'>
    readonly blockNumber: FieldRef<"WalletTransaction", 'Int'>
    readonly createdAt: FieldRef<"WalletTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"WalletTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WalletTransaction findUnique
   */
  export type WalletTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findUniqueOrThrow
   */
  export type WalletTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findFirst
   */
  export type WalletTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findFirstOrThrow
   */
  export type WalletTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findMany
   */
  export type WalletTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Filter, which WalletTransactions to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction create
   */
  export type WalletTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * The data needed to create a WalletTransaction.
     */
    data: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
  }

  /**
   * WalletTransaction createMany
   */
  export type WalletTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WalletTransaction createManyAndReturn
   */
  export type WalletTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WalletTransaction update
   */
  export type WalletTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * The data needed to update a WalletTransaction.
     */
    data: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
    /**
     * Choose, which WalletTransaction to update.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction updateMany
   */
  export type WalletTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WalletTransactions.
     */
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyInput>
    /**
     * Filter which WalletTransactions to update
     */
    where?: WalletTransactionWhereInput
  }

  /**
   * WalletTransaction upsert
   */
  export type WalletTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * The filter to search for the WalletTransaction to update in case it exists.
     */
    where: WalletTransactionWhereUniqueInput
    /**
     * In case the WalletTransaction found by the `where` argument doesn't exist, create a new WalletTransaction with this data.
     */
    create: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
    /**
     * In case the WalletTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
  }

  /**
   * WalletTransaction delete
   */
  export type WalletTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Filter which WalletTransaction to delete.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction deleteMany
   */
  export type WalletTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransactions to delete
     */
    where?: WalletTransactionWhereInput
  }

  /**
   * WalletTransaction without action
   */
  export type WalletTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    email: 'email',
    fullName: 'fullName',
    avatarUrl: 'avatarUrl',
    subscriptionTier: 'subscriptionTier',
    subscriptionStatus: 'subscriptionStatus',
    subscriptionExpiresAt: 'subscriptionExpiresAt',
    monthlyExecutionQuota: 'monthlyExecutionQuota',
    monthlyExecutionCount: 'monthlyExecutionCount',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastSeenAt: 'lastSeenAt',
    monthlyExecutionsUsed: 'monthlyExecutionsUsed',
    telegramChatId: 'telegramChatId',
    discordWebhookUrl: 'discordWebhookUrl'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const UserWalletScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    chainId: 'chainId',
    walletAddress: 'walletAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    walletType: 'walletType',
    chainType: 'chainType',
    metadata: 'metadata'
  };

  export type UserWalletScalarFieldEnum = (typeof UserWalletScalarFieldEnum)[keyof typeof UserWalletScalarFieldEnum]


  export const WorkflowTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    nodes: 'nodes',
    edges: 'edges',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkflowTemplateScalarFieldEnum = (typeof WorkflowTemplateScalarFieldEnum)[keyof typeof WorkflowTemplateScalarFieldEnum]


  export const WorkflowScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    nodes: 'nodes',
    edges: 'edges',
    isPublic: 'isPublic',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    definition: 'definition',
    version: 'version',
    createdBy: 'createdBy'
  };

  export type WorkflowScalarFieldEnum = (typeof WorkflowScalarFieldEnum)[keyof typeof WorkflowScalarFieldEnum]


  export const WorkflowExecutionScalarFieldEnum: {
    id: 'id',
    workflowId: 'workflowId',
    userId: 'userId',
    status: 'status',
    input: 'input',
    output: 'output',
    startedAt: 'startedAt',
    finishedAt: 'finishedAt',
    error: 'error',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    triggerType: 'triggerType',
    triggerData: 'triggerData',
    lockedBy: 'lockedBy',
    logs: 'logs'
  };

  export type WorkflowExecutionScalarFieldEnum = (typeof WorkflowExecutionScalarFieldEnum)[keyof typeof WorkflowExecutionScalarFieldEnum]


  export const NodeExecutionScalarFieldEnum: {
    id: 'id',
    executionId: 'executionId',
    nodeId: 'nodeId',
    status: 'status',
    outputData: 'outputData',
    error: 'error',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    durationMs: 'durationMs',
    updatedAt: 'updatedAt',
    retryCount: 'retryCount',
    finishedAt: 'finishedAt',
    output: 'output'
  };

  export type NodeExecutionScalarFieldEnum = (typeof NodeExecutionScalarFieldEnum)[keyof typeof NodeExecutionScalarFieldEnum]


  export const NodeLogScalarFieldEnum: {
    id: 'id',
    nodeExecutionId: 'nodeExecutionId',
    level: 'level',
    message: 'message',
    createdAt: 'createdAt',
    metadata: 'metadata'
  };

  export type NodeLogScalarFieldEnum = (typeof NodeLogScalarFieldEnum)[keyof typeof NodeLogScalarFieldEnum]


  export const NodeInputScalarFieldEnum: {
    id: 'id',
    executionId: 'executionId',
    nodeId: 'nodeId',
    inputData: 'inputData',
    createdAt: 'createdAt'
  };

  export type NodeInputScalarFieldEnum = (typeof NodeInputScalarFieldEnum)[keyof typeof NodeInputScalarFieldEnum]


  export const NodeOutputScalarFieldEnum: {
    id: 'id',
    executionId: 'executionId',
    nodeId: 'nodeId',
    outputData: 'outputData',
    createdAt: 'createdAt'
  };

  export type NodeOutputScalarFieldEnum = (typeof NodeOutputScalarFieldEnum)[keyof typeof NodeOutputScalarFieldEnum]


  export const ExecutionLogScalarFieldEnum: {
    id: 'id',
    executionId: 'executionId',
    level: 'level',
    message: 'message',
    timestamp: 'timestamp',
    metadata: 'metadata'
  };

  export type ExecutionLogScalarFieldEnum = (typeof ExecutionLogScalarFieldEnum)[keyof typeof ExecutionLogScalarFieldEnum]


  export const WorkflowPauseScalarFieldEnum: {
    id: 'id',
    workflowId: 'workflowId',
    executionId: 'executionId',
    nodeId: 'nodeId',
    reason: 'reason',
    resumeData: 'resumeData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkflowPauseScalarFieldEnum = (typeof WorkflowPauseScalarFieldEnum)[keyof typeof WorkflowPauseScalarFieldEnum]


  export const BlockchainTransactionScalarFieldEnum: {
    id: 'id',
    nodeId: 'nodeId',
    executionId: 'executionId',
    toAddress: 'toAddress',
    value: 'value',
    data: 'data',
    chainId: 'chainId',
    gasLimit: 'gasLimit',
    gasUsed: 'gasUsed',
    maxFeePerGas: 'maxFeePerGas',
    maxPriorityFeePerGas: 'maxPriorityFeePerGas',
    nonce: 'nonce',
    status: 'status',
    hash: 'hash',
    txHash: 'txHash',
    blockNumber: 'blockNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    walletAddress: 'walletAddress',
    effectiveGasPrice: 'effectiveGasPrice',
    error: 'error',
    fromAddress: 'fromAddress'
  };

  export type BlockchainTransactionScalarFieldEnum = (typeof BlockchainTransactionScalarFieldEnum)[keyof typeof BlockchainTransactionScalarFieldEnum]


  export const TransactionAttemptScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    txHash: 'txHash',
    status: 'status',
    error: 'error',
    blockNumber: 'blockNumber',
    gasUsed: 'gasUsed',
    effectiveGasPrice: 'effectiveGasPrice',
    createdAt: 'createdAt'
  };

  export type TransactionAttemptScalarFieldEnum = (typeof TransactionAttemptScalarFieldEnum)[keyof typeof TransactionAttemptScalarFieldEnum]


  export const AiBlockchainOperationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    executionId: 'executionId',
    nodeId: 'nodeId',
    operationType: 'operationType',
    blockchain: 'blockchain',
    prompt: 'prompt',
    result: 'result',
    status: 'status',
    error: 'error',
    createdAt: 'createdAt'
  };

  export type AiBlockchainOperationScalarFieldEnum = (typeof AiBlockchainOperationScalarFieldEnum)[keyof typeof AiBlockchainOperationScalarFieldEnum]


  export const BlockExecutionScalarFieldEnum: {
    id: 'id',
    executionId: 'executionId',
    nodeId: 'nodeId',
    blockType: 'blockType',
    status: 'status',
    input: 'input',
    output: 'output',
    error: 'error',
    startTime: 'startTime',
    endTime: 'endTime'
  };

  export type BlockExecutionScalarFieldEnum = (typeof BlockExecutionScalarFieldEnum)[keyof typeof BlockExecutionScalarFieldEnum]


  export const BlockExecutionLogScalarFieldEnum: {
    id: 'id',
    blockExecutionId: 'blockExecutionId',
    level: 'level',
    message: 'message',
    timestamp: 'timestamp'
  };

  export type BlockExecutionLogScalarFieldEnum = (typeof BlockExecutionLogScalarFieldEnum)[keyof typeof BlockExecutionLogScalarFieldEnum]


  export const BlockLibraryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    blockType: 'blockType',
    category: 'category',
    configuration: 'configuration',
    blockData: 'blockData',
    executionCode: 'executionCode',
    userId: 'userId',
    isPublic: 'isPublic',
    isVerified: 'isVerified',
    rating: 'rating',
    usageCount: 'usageCount',
    tags: 'tags',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlockLibraryScalarFieldEnum = (typeof BlockLibraryScalarFieldEnum)[keyof typeof BlockLibraryScalarFieldEnum]


  export const BlockLibraryRatingScalarFieldEnum: {
    id: 'id',
    blockId: 'blockId',
    userId: 'userId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type BlockLibraryRatingScalarFieldEnum = (typeof BlockLibraryRatingScalarFieldEnum)[keyof typeof BlockLibraryRatingScalarFieldEnum]


  export const CustomBlockScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    blockType: 'blockType',
    category: 'category',
    code: 'code',
    logic: 'logic',
    logicType: 'logicType',
    blockData: 'blockData',
    tags: 'tags',
    createdBy: 'createdBy',
    icon: 'icon',
    isPublic: 'isPublic',
    isVerified: 'isVerified',
    rating: 'rating',
    usageCount: 'usageCount',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type CustomBlockScalarFieldEnum = (typeof CustomBlockScalarFieldEnum)[keyof typeof CustomBlockScalarFieldEnum]


  export const ExecutionQueueScalarFieldEnum: {
    id: 'id',
    workflowId: 'workflowId',
    executionId: 'executionId',
    userId: 'userId',
    priority: 'priority',
    status: 'status',
    payload: 'payload',
    error: 'error',
    retryCount: 'retryCount',
    maxRetries: 'maxRetries',
    lockedBy: 'lockedBy',
    lockedUntil: 'lockedUntil',
    scheduledFor: 'scheduledFor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExecutionQueueScalarFieldEnum = (typeof ExecutionQueueScalarFieldEnum)[keyof typeof ExecutionQueueScalarFieldEnum]


  export const ExecutionNodeStatusScalarFieldEnum: {
    id: 'id',
    nodeId: 'nodeId',
    status: 'status',
    lastHeartbeat: 'lastHeartbeat',
    metadata: 'metadata'
  };

  export type ExecutionNodeStatusScalarFieldEnum = (typeof ExecutionNodeStatusScalarFieldEnum)[keyof typeof ExecutionNodeStatusScalarFieldEnum]


  export const CircuitBreakerStateScalarFieldEnum: {
    id: 'id',
    circuitId: 'circuitId',
    state: 'state',
    failureCount: 'failureCount',
    successCount: 'successCount',
    lastFailureTime: 'lastFailureTime',
    lastSuccessTime: 'lastSuccessTime',
    lastHalfOpenTime: 'lastHalfOpenTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CircuitBreakerStateScalarFieldEnum = (typeof CircuitBreakerStateScalarFieldEnum)[keyof typeof CircuitBreakerStateScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    read: 'read',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    emailEnabled: 'emailEnabled',
    pushEnabled: 'pushEnabled',
    webhookEnabled: 'webhookEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    telegramChatId: 'telegramChatId',
    discordWebhookUrl: 'discordWebhookUrl'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const NotificationTemplateScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationTemplateScalarFieldEnum = (typeof NotificationTemplateScalarFieldEnum)[keyof typeof NotificationTemplateScalarFieldEnum]


  export const NotificationLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    channel: 'channel',
    status: 'status',
    error: 'error',
    notificationId: 'notificationId',
    createdAt: 'createdAt'
  };

  export type NotificationLogScalarFieldEnum = (typeof NotificationLogScalarFieldEnum)[keyof typeof NotificationLogScalarFieldEnum]


  export const PricingTierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    priceMonthly: 'priceMonthly',
    priceYearly: 'priceYearly',
    workflowLimit: 'workflowLimit',
    executionLimit: 'executionLimit',
    features: 'features',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PricingTierScalarFieldEnum = (typeof PricingTierScalarFieldEnum)[keyof typeof PricingTierScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tierId: 'tierId',
    status: 'status',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    stripeSubscriptionId: 'stripeSubscriptionId',
    stripePriceId: 'stripePriceId',
    stripeCustomerId: 'stripeCustomerId',
    canceledAt: 'canceledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const SubscriptionInvoiceScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    stripeInvoiceId: 'stripeInvoiceId',
    amount: 'amount',
    status: 'status',
    paidAt: 'paidAt',
    invoiceUrl: 'invoiceUrl',
    createdAt: 'createdAt'
  };

  export type SubscriptionInvoiceScalarFieldEnum = (typeof SubscriptionInvoiceScalarFieldEnum)[keyof typeof SubscriptionInvoiceScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    teamId: 'teamId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const UsageLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resourceType: 'resourceType',
    action: 'action',
    quantity: 'quantity',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type UsageLogScalarFieldEnum = (typeof UsageLogScalarFieldEnum)[keyof typeof UsageLogScalarFieldEnum]


  export const WalletTransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    walletAddress: 'walletAddress',
    txHash: 'txHash',
    chainId: 'chainId',
    value: 'value',
    status: 'status',
    blockNumber: 'blockNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WalletTransactionScalarFieldEnum = (typeof WalletTransactionScalarFieldEnum)[keyof typeof WalletTransactionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'WorkflowStatus'
   */
  export type EnumWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStatus'>
    


  /**
   * Reference to a field of type 'WorkflowStatus[]'
   */
  export type ListEnumWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStatus[]'>
    


  /**
   * Reference to a field of type 'LogLevel'
   */
  export type EnumLogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogLevel'>
    


  /**
   * Reference to a field of type 'LogLevel[]'
   */
  export type ListEnumLogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogLevel[]'>
    


  /**
   * Reference to a field of type 'BlockStatus'
   */
  export type EnumBlockStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BlockStatus'>
    


  /**
   * Reference to a field of type 'BlockStatus[]'
   */
  export type ListEnumBlockStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BlockStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    userWallets?: UserWalletListRelationFilter
    workflows?: WorkflowListRelationFilter
    workflowExecutions?: WorkflowExecutionListRelationFilter
    notifications?: NotificationListRelationFilter
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    teamMemberships?: TeamMemberListRelationFilter
    ownedTeams?: TeamListRelationFilter
    notificationPreferences?: XOR<NotificationPreferenceNullableRelationFilter, NotificationPreferenceWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    userWallets?: UserWalletOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
    workflowExecutions?: WorkflowExecutionOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
    teamMemberships?: TeamMemberOrderByRelationAggregateInput
    ownedTeams?: TeamOrderByRelationAggregateInput
    notificationPreferences?: NotificationPreferenceOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    userWallets?: UserWalletListRelationFilter
    workflows?: WorkflowListRelationFilter
    workflowExecutions?: WorkflowExecutionListRelationFilter
    notifications?: NotificationListRelationFilter
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    teamMemberships?: TeamMemberListRelationFilter
    ownedTeams?: TeamListRelationFilter
    notificationPreferences?: XOR<NotificationPreferenceNullableRelationFilter, NotificationPreferenceWhereInput> | null
  }, "id" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    email?: StringNullableFilter<"Profile"> | string | null
    fullName?: StringNullableFilter<"Profile"> | string | null
    avatarUrl?: StringNullableFilter<"Profile"> | string | null
    subscriptionTier?: StringNullableFilter<"Profile"> | string | null
    subscriptionStatus?: StringNullableFilter<"Profile"> | string | null
    subscriptionExpiresAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    monthlyExecutionQuota?: IntNullableFilter<"Profile"> | number | null
    monthlyExecutionCount?: IntNullableFilter<"Profile"> | number | null
    stripeCustomerId?: StringNullableFilter<"Profile"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Profile"> | string | null
    createdAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    lastSeenAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    monthlyExecutionsUsed?: IntFilter<"Profile"> | number
    telegramChatId?: StringNullableFilter<"Profile"> | string | null
    discordWebhookUrl?: StringNullableFilter<"Profile"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    subscriptionExpiresAt?: SortOrderInput | SortOrder
    monthlyExecutionQuota?: SortOrderInput | SortOrder
    monthlyExecutionCount?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    lastSeenAt?: SortOrderInput | SortOrder
    monthlyExecutionsUsed?: SortOrder
    telegramChatId?: SortOrderInput | SortOrder
    discordWebhookUrl?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    email?: StringNullableFilter<"Profile"> | string | null
    fullName?: StringNullableFilter<"Profile"> | string | null
    avatarUrl?: StringNullableFilter<"Profile"> | string | null
    subscriptionTier?: StringNullableFilter<"Profile"> | string | null
    subscriptionStatus?: StringNullableFilter<"Profile"> | string | null
    subscriptionExpiresAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    monthlyExecutionQuota?: IntNullableFilter<"Profile"> | number | null
    monthlyExecutionCount?: IntNullableFilter<"Profile"> | number | null
    stripeCustomerId?: StringNullableFilter<"Profile"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Profile"> | string | null
    createdAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    lastSeenAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    monthlyExecutionsUsed?: IntFilter<"Profile"> | number
    telegramChatId?: StringNullableFilter<"Profile"> | string | null
    discordWebhookUrl?: StringNullableFilter<"Profile"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    subscriptionExpiresAt?: SortOrderInput | SortOrder
    monthlyExecutionQuota?: SortOrderInput | SortOrder
    monthlyExecutionCount?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    lastSeenAt?: SortOrderInput | SortOrder
    monthlyExecutionsUsed?: SortOrder
    telegramChatId?: SortOrderInput | SortOrder
    discordWebhookUrl?: SortOrderInput | SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    email?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    fullName?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    subscriptionTier?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    subscriptionStatus?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    subscriptionExpiresAt?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    monthlyExecutionQuota?: IntNullableWithAggregatesFilter<"Profile"> | number | null
    monthlyExecutionCount?: IntNullableWithAggregatesFilter<"Profile"> | number | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    lastSeenAt?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    monthlyExecutionsUsed?: IntWithAggregatesFilter<"Profile"> | number
    telegramChatId?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    discordWebhookUrl?: StringNullableWithAggregatesFilter<"Profile"> | string | null
  }

  export type UserWalletWhereInput = {
    AND?: UserWalletWhereInput | UserWalletWhereInput[]
    OR?: UserWalletWhereInput[]
    NOT?: UserWalletWhereInput | UserWalletWhereInput[]
    id?: StringFilter<"UserWallet"> | string
    userId?: StringFilter<"UserWallet"> | string
    chainId?: StringFilter<"UserWallet"> | string
    walletAddress?: StringFilter<"UserWallet"> | string
    createdAt?: DateTimeFilter<"UserWallet"> | Date | string
    updatedAt?: DateTimeFilter<"UserWallet"> | Date | string
    walletType?: StringNullableFilter<"UserWallet"> | string | null
    chainType?: StringNullableFilter<"UserWallet"> | string | null
    metadata?: JsonNullableFilter<"UserWallet">
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserWalletOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    chainId?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    walletType?: SortOrderInput | SortOrder
    chainType?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserWalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserWalletWhereInput | UserWalletWhereInput[]
    OR?: UserWalletWhereInput[]
    NOT?: UserWalletWhereInput | UserWalletWhereInput[]
    userId?: StringFilter<"UserWallet"> | string
    chainId?: StringFilter<"UserWallet"> | string
    walletAddress?: StringFilter<"UserWallet"> | string
    createdAt?: DateTimeFilter<"UserWallet"> | Date | string
    updatedAt?: DateTimeFilter<"UserWallet"> | Date | string
    walletType?: StringNullableFilter<"UserWallet"> | string | null
    chainType?: StringNullableFilter<"UserWallet"> | string | null
    metadata?: JsonNullableFilter<"UserWallet">
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UserWalletOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    chainId?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    walletType?: SortOrderInput | SortOrder
    chainType?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: UserWalletCountOrderByAggregateInput
    _max?: UserWalletMaxOrderByAggregateInput
    _min?: UserWalletMinOrderByAggregateInput
  }

  export type UserWalletScalarWhereWithAggregatesInput = {
    AND?: UserWalletScalarWhereWithAggregatesInput | UserWalletScalarWhereWithAggregatesInput[]
    OR?: UserWalletScalarWhereWithAggregatesInput[]
    NOT?: UserWalletScalarWhereWithAggregatesInput | UserWalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserWallet"> | string
    userId?: StringWithAggregatesFilter<"UserWallet"> | string
    chainId?: StringWithAggregatesFilter<"UserWallet"> | string
    walletAddress?: StringWithAggregatesFilter<"UserWallet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserWallet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserWallet"> | Date | string
    walletType?: StringNullableWithAggregatesFilter<"UserWallet"> | string | null
    chainType?: StringNullableWithAggregatesFilter<"UserWallet"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"UserWallet">
  }

  export type WorkflowTemplateWhereInput = {
    AND?: WorkflowTemplateWhereInput | WorkflowTemplateWhereInput[]
    OR?: WorkflowTemplateWhereInput[]
    NOT?: WorkflowTemplateWhereInput | WorkflowTemplateWhereInput[]
    id?: StringFilter<"WorkflowTemplate"> | string
    name?: StringFilter<"WorkflowTemplate"> | string
    description?: StringNullableFilter<"WorkflowTemplate"> | string | null
    category?: StringNullableFilter<"WorkflowTemplate"> | string | null
    nodes?: JsonNullableFilter<"WorkflowTemplate">
    edges?: JsonNullableFilter<"WorkflowTemplate">
    createdAt?: DateTimeNullableFilter<"WorkflowTemplate"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"WorkflowTemplate"> | Date | string | null
  }

  export type WorkflowTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    nodes?: SortOrderInput | SortOrder
    edges?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type WorkflowTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowTemplateWhereInput | WorkflowTemplateWhereInput[]
    OR?: WorkflowTemplateWhereInput[]
    NOT?: WorkflowTemplateWhereInput | WorkflowTemplateWhereInput[]
    name?: StringFilter<"WorkflowTemplate"> | string
    description?: StringNullableFilter<"WorkflowTemplate"> | string | null
    category?: StringNullableFilter<"WorkflowTemplate"> | string | null
    nodes?: JsonNullableFilter<"WorkflowTemplate">
    edges?: JsonNullableFilter<"WorkflowTemplate">
    createdAt?: DateTimeNullableFilter<"WorkflowTemplate"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"WorkflowTemplate"> | Date | string | null
  }, "id">

  export type WorkflowTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    nodes?: SortOrderInput | SortOrder
    edges?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: WorkflowTemplateCountOrderByAggregateInput
    _max?: WorkflowTemplateMaxOrderByAggregateInput
    _min?: WorkflowTemplateMinOrderByAggregateInput
  }

  export type WorkflowTemplateScalarWhereWithAggregatesInput = {
    AND?: WorkflowTemplateScalarWhereWithAggregatesInput | WorkflowTemplateScalarWhereWithAggregatesInput[]
    OR?: WorkflowTemplateScalarWhereWithAggregatesInput[]
    NOT?: WorkflowTemplateScalarWhereWithAggregatesInput | WorkflowTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowTemplate"> | string
    name?: StringWithAggregatesFilter<"WorkflowTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"WorkflowTemplate"> | string | null
    category?: StringNullableWithAggregatesFilter<"WorkflowTemplate"> | string | null
    nodes?: JsonNullableWithAggregatesFilter<"WorkflowTemplate">
    edges?: JsonNullableWithAggregatesFilter<"WorkflowTemplate">
    createdAt?: DateTimeNullableWithAggregatesFilter<"WorkflowTemplate"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"WorkflowTemplate"> | Date | string | null
  }

  export type WorkflowWhereInput = {
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    id?: StringFilter<"Workflow"> | string
    userId?: StringFilter<"Workflow"> | string
    name?: StringFilter<"Workflow"> | string
    description?: StringNullableFilter<"Workflow"> | string | null
    nodes?: JsonNullableFilter<"Workflow">
    edges?: JsonNullableFilter<"Workflow">
    isPublic?: BoolNullableFilter<"Workflow"> | boolean | null
    tags?: StringNullableListFilter<"Workflow">
    createdAt?: DateTimeNullableFilter<"Workflow"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Workflow"> | Date | string | null
    definition?: JsonFilter<"Workflow">
    version?: IntFilter<"Workflow"> | number
    createdBy?: StringNullableFilter<"Workflow"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    executions?: WorkflowExecutionListRelationFilter
    pauses?: WorkflowPauseListRelationFilter
  }

  export type WorkflowOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    nodes?: SortOrderInput | SortOrder
    edges?: SortOrderInput | SortOrder
    isPublic?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    definition?: SortOrder
    version?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    executions?: WorkflowExecutionOrderByRelationAggregateInput
    pauses?: WorkflowPauseOrderByRelationAggregateInput
  }

  export type WorkflowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    userId?: StringFilter<"Workflow"> | string
    name?: StringFilter<"Workflow"> | string
    description?: StringNullableFilter<"Workflow"> | string | null
    nodes?: JsonNullableFilter<"Workflow">
    edges?: JsonNullableFilter<"Workflow">
    isPublic?: BoolNullableFilter<"Workflow"> | boolean | null
    tags?: StringNullableListFilter<"Workflow">
    createdAt?: DateTimeNullableFilter<"Workflow"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Workflow"> | Date | string | null
    definition?: JsonFilter<"Workflow">
    version?: IntFilter<"Workflow"> | number
    createdBy?: StringNullableFilter<"Workflow"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    executions?: WorkflowExecutionListRelationFilter
    pauses?: WorkflowPauseListRelationFilter
  }, "id">

  export type WorkflowOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    nodes?: SortOrderInput | SortOrder
    edges?: SortOrderInput | SortOrder
    isPublic?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    definition?: SortOrder
    version?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: WorkflowCountOrderByAggregateInput
    _avg?: WorkflowAvgOrderByAggregateInput
    _max?: WorkflowMaxOrderByAggregateInput
    _min?: WorkflowMinOrderByAggregateInput
    _sum?: WorkflowSumOrderByAggregateInput
  }

  export type WorkflowScalarWhereWithAggregatesInput = {
    AND?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    OR?: WorkflowScalarWhereWithAggregatesInput[]
    NOT?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workflow"> | string
    userId?: StringWithAggregatesFilter<"Workflow"> | string
    name?: StringWithAggregatesFilter<"Workflow"> | string
    description?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    nodes?: JsonNullableWithAggregatesFilter<"Workflow">
    edges?: JsonNullableWithAggregatesFilter<"Workflow">
    isPublic?: BoolNullableWithAggregatesFilter<"Workflow"> | boolean | null
    tags?: StringNullableListFilter<"Workflow">
    createdAt?: DateTimeNullableWithAggregatesFilter<"Workflow"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Workflow"> | Date | string | null
    definition?: JsonWithAggregatesFilter<"Workflow">
    version?: IntWithAggregatesFilter<"Workflow"> | number
    createdBy?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
  }

  export type WorkflowExecutionWhereInput = {
    AND?: WorkflowExecutionWhereInput | WorkflowExecutionWhereInput[]
    OR?: WorkflowExecutionWhereInput[]
    NOT?: WorkflowExecutionWhereInput | WorkflowExecutionWhereInput[]
    id?: StringFilter<"WorkflowExecution"> | string
    workflowId?: StringFilter<"WorkflowExecution"> | string
    userId?: StringFilter<"WorkflowExecution"> | string
    status?: EnumWorkflowStatusFilter<"WorkflowExecution"> | $Enums.WorkflowStatus
    input?: JsonNullableFilter<"WorkflowExecution">
    output?: JsonNullableFilter<"WorkflowExecution">
    startedAt?: DateTimeFilter<"WorkflowExecution"> | Date | string
    finishedAt?: DateTimeNullableFilter<"WorkflowExecution"> | Date | string | null
    error?: StringNullableFilter<"WorkflowExecution"> | string | null
    metadata?: JsonNullableFilter<"WorkflowExecution">
    createdAt?: DateTimeFilter<"WorkflowExecution"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowExecution"> | Date | string
    triggerType?: StringNullableFilter<"WorkflowExecution"> | string | null
    triggerData?: JsonNullableFilter<"WorkflowExecution">
    lockedBy?: StringNullableFilter<"WorkflowExecution"> | string | null
    logs?: JsonNullableFilter<"WorkflowExecution">
    workflow?: XOR<WorkflowRelationFilter, WorkflowWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    nodeExecutions?: NodeExecutionListRelationFilter
    executionLogs?: ExecutionLogListRelationFilter
    blockExecutions?: BlockExecutionListRelationFilter
    blockchainTransactions?: BlockchainTransactionListRelationFilter
    workflowPauses?: WorkflowPauseListRelationFilter
  }

  export type WorkflowExecutionOrderByWithRelationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggerType?: SortOrderInput | SortOrder
    triggerData?: SortOrderInput | SortOrder
    lockedBy?: SortOrderInput | SortOrder
    logs?: SortOrderInput | SortOrder
    workflow?: WorkflowOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    nodeExecutions?: NodeExecutionOrderByRelationAggregateInput
    executionLogs?: ExecutionLogOrderByRelationAggregateInput
    blockExecutions?: BlockExecutionOrderByRelationAggregateInput
    blockchainTransactions?: BlockchainTransactionOrderByRelationAggregateInput
    workflowPauses?: WorkflowPauseOrderByRelationAggregateInput
  }

  export type WorkflowExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowExecutionWhereInput | WorkflowExecutionWhereInput[]
    OR?: WorkflowExecutionWhereInput[]
    NOT?: WorkflowExecutionWhereInput | WorkflowExecutionWhereInput[]
    workflowId?: StringFilter<"WorkflowExecution"> | string
    userId?: StringFilter<"WorkflowExecution"> | string
    status?: EnumWorkflowStatusFilter<"WorkflowExecution"> | $Enums.WorkflowStatus
    input?: JsonNullableFilter<"WorkflowExecution">
    output?: JsonNullableFilter<"WorkflowExecution">
    startedAt?: DateTimeFilter<"WorkflowExecution"> | Date | string
    finishedAt?: DateTimeNullableFilter<"WorkflowExecution"> | Date | string | null
    error?: StringNullableFilter<"WorkflowExecution"> | string | null
    metadata?: JsonNullableFilter<"WorkflowExecution">
    createdAt?: DateTimeFilter<"WorkflowExecution"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowExecution"> | Date | string
    triggerType?: StringNullableFilter<"WorkflowExecution"> | string | null
    triggerData?: JsonNullableFilter<"WorkflowExecution">
    lockedBy?: StringNullableFilter<"WorkflowExecution"> | string | null
    logs?: JsonNullableFilter<"WorkflowExecution">
    workflow?: XOR<WorkflowRelationFilter, WorkflowWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    nodeExecutions?: NodeExecutionListRelationFilter
    executionLogs?: ExecutionLogListRelationFilter
    blockExecutions?: BlockExecutionListRelationFilter
    blockchainTransactions?: BlockchainTransactionListRelationFilter
    workflowPauses?: WorkflowPauseListRelationFilter
  }, "id">

  export type WorkflowExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggerType?: SortOrderInput | SortOrder
    triggerData?: SortOrderInput | SortOrder
    lockedBy?: SortOrderInput | SortOrder
    logs?: SortOrderInput | SortOrder
    _count?: WorkflowExecutionCountOrderByAggregateInput
    _max?: WorkflowExecutionMaxOrderByAggregateInput
    _min?: WorkflowExecutionMinOrderByAggregateInput
  }

  export type WorkflowExecutionScalarWhereWithAggregatesInput = {
    AND?: WorkflowExecutionScalarWhereWithAggregatesInput | WorkflowExecutionScalarWhereWithAggregatesInput[]
    OR?: WorkflowExecutionScalarWhereWithAggregatesInput[]
    NOT?: WorkflowExecutionScalarWhereWithAggregatesInput | WorkflowExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowExecution"> | string
    workflowId?: StringWithAggregatesFilter<"WorkflowExecution"> | string
    userId?: StringWithAggregatesFilter<"WorkflowExecution"> | string
    status?: EnumWorkflowStatusWithAggregatesFilter<"WorkflowExecution"> | $Enums.WorkflowStatus
    input?: JsonNullableWithAggregatesFilter<"WorkflowExecution">
    output?: JsonNullableWithAggregatesFilter<"WorkflowExecution">
    startedAt?: DateTimeWithAggregatesFilter<"WorkflowExecution"> | Date | string
    finishedAt?: DateTimeNullableWithAggregatesFilter<"WorkflowExecution"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"WorkflowExecution"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"WorkflowExecution">
    createdAt?: DateTimeWithAggregatesFilter<"WorkflowExecution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkflowExecution"> | Date | string
    triggerType?: StringNullableWithAggregatesFilter<"WorkflowExecution"> | string | null
    triggerData?: JsonNullableWithAggregatesFilter<"WorkflowExecution">
    lockedBy?: StringNullableWithAggregatesFilter<"WorkflowExecution"> | string | null
    logs?: JsonNullableWithAggregatesFilter<"WorkflowExecution">
  }

  export type NodeExecutionWhereInput = {
    AND?: NodeExecutionWhereInput | NodeExecutionWhereInput[]
    OR?: NodeExecutionWhereInput[]
    NOT?: NodeExecutionWhereInput | NodeExecutionWhereInput[]
    id?: StringFilter<"NodeExecution"> | string
    executionId?: StringFilter<"NodeExecution"> | string
    nodeId?: StringFilter<"NodeExecution"> | string
    status?: StringFilter<"NodeExecution"> | string
    outputData?: JsonNullableFilter<"NodeExecution">
    error?: StringNullableFilter<"NodeExecution"> | string | null
    startedAt?: DateTimeFilter<"NodeExecution"> | Date | string
    completedAt?: DateTimeFilter<"NodeExecution"> | Date | string
    durationMs?: IntNullableFilter<"NodeExecution"> | number | null
    updatedAt?: DateTimeNullableFilter<"NodeExecution"> | Date | string | null
    retryCount?: IntNullableFilter<"NodeExecution"> | number | null
    finishedAt?: DateTimeNullableFilter<"NodeExecution"> | Date | string | null
    output?: JsonNullableFilter<"NodeExecution">
    execution?: XOR<WorkflowExecutionRelationFilter, WorkflowExecutionWhereInput>
    logs?: NodeLogListRelationFilter
    nodeInputs?: NodeInputListRelationFilter
    nodeOutputs?: NodeOutputListRelationFilter
  }

  export type NodeExecutionOrderByWithRelationInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    status?: SortOrder
    outputData?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationMs?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    retryCount?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    execution?: WorkflowExecutionOrderByWithRelationInput
    logs?: NodeLogOrderByRelationAggregateInput
    nodeInputs?: NodeInputOrderByRelationAggregateInput
    nodeOutputs?: NodeOutputOrderByRelationAggregateInput
  }

  export type NodeExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    executionId_nodeId?: NodeExecutionExecutionIdNodeIdCompoundUniqueInput
    AND?: NodeExecutionWhereInput | NodeExecutionWhereInput[]
    OR?: NodeExecutionWhereInput[]
    NOT?: NodeExecutionWhereInput | NodeExecutionWhereInput[]
    executionId?: StringFilter<"NodeExecution"> | string
    nodeId?: StringFilter<"NodeExecution"> | string
    status?: StringFilter<"NodeExecution"> | string
    outputData?: JsonNullableFilter<"NodeExecution">
    error?: StringNullableFilter<"NodeExecution"> | string | null
    startedAt?: DateTimeFilter<"NodeExecution"> | Date | string
    completedAt?: DateTimeFilter<"NodeExecution"> | Date | string
    durationMs?: IntNullableFilter<"NodeExecution"> | number | null
    updatedAt?: DateTimeNullableFilter<"NodeExecution"> | Date | string | null
    retryCount?: IntNullableFilter<"NodeExecution"> | number | null
    finishedAt?: DateTimeNullableFilter<"NodeExecution"> | Date | string | null
    output?: JsonNullableFilter<"NodeExecution">
    execution?: XOR<WorkflowExecutionRelationFilter, WorkflowExecutionWhereInput>
    logs?: NodeLogListRelationFilter
    nodeInputs?: NodeInputListRelationFilter
    nodeOutputs?: NodeOutputListRelationFilter
  }, "id" | "executionId_nodeId">

  export type NodeExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    status?: SortOrder
    outputData?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationMs?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    retryCount?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    _count?: NodeExecutionCountOrderByAggregateInput
    _avg?: NodeExecutionAvgOrderByAggregateInput
    _max?: NodeExecutionMaxOrderByAggregateInput
    _min?: NodeExecutionMinOrderByAggregateInput
    _sum?: NodeExecutionSumOrderByAggregateInput
  }

  export type NodeExecutionScalarWhereWithAggregatesInput = {
    AND?: NodeExecutionScalarWhereWithAggregatesInput | NodeExecutionScalarWhereWithAggregatesInput[]
    OR?: NodeExecutionScalarWhereWithAggregatesInput[]
    NOT?: NodeExecutionScalarWhereWithAggregatesInput | NodeExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NodeExecution"> | string
    executionId?: StringWithAggregatesFilter<"NodeExecution"> | string
    nodeId?: StringWithAggregatesFilter<"NodeExecution"> | string
    status?: StringWithAggregatesFilter<"NodeExecution"> | string
    outputData?: JsonNullableWithAggregatesFilter<"NodeExecution">
    error?: StringNullableWithAggregatesFilter<"NodeExecution"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"NodeExecution"> | Date | string
    completedAt?: DateTimeWithAggregatesFilter<"NodeExecution"> | Date | string
    durationMs?: IntNullableWithAggregatesFilter<"NodeExecution"> | number | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"NodeExecution"> | Date | string | null
    retryCount?: IntNullableWithAggregatesFilter<"NodeExecution"> | number | null
    finishedAt?: DateTimeNullableWithAggregatesFilter<"NodeExecution"> | Date | string | null
    output?: JsonNullableWithAggregatesFilter<"NodeExecution">
  }

  export type NodeLogWhereInput = {
    AND?: NodeLogWhereInput | NodeLogWhereInput[]
    OR?: NodeLogWhereInput[]
    NOT?: NodeLogWhereInput | NodeLogWhereInput[]
    id?: StringFilter<"NodeLog"> | string
    nodeExecutionId?: StringFilter<"NodeLog"> | string
    level?: EnumLogLevelFilter<"NodeLog"> | $Enums.LogLevel
    message?: StringFilter<"NodeLog"> | string
    createdAt?: DateTimeFilter<"NodeLog"> | Date | string
    metadata?: JsonNullableFilter<"NodeLog">
    nodeExecution?: XOR<NodeExecutionRelationFilter, NodeExecutionWhereInput>
  }

  export type NodeLogOrderByWithRelationInput = {
    id?: SortOrder
    nodeExecutionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    nodeExecution?: NodeExecutionOrderByWithRelationInput
  }

  export type NodeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NodeLogWhereInput | NodeLogWhereInput[]
    OR?: NodeLogWhereInput[]
    NOT?: NodeLogWhereInput | NodeLogWhereInput[]
    nodeExecutionId?: StringFilter<"NodeLog"> | string
    level?: EnumLogLevelFilter<"NodeLog"> | $Enums.LogLevel
    message?: StringFilter<"NodeLog"> | string
    createdAt?: DateTimeFilter<"NodeLog"> | Date | string
    metadata?: JsonNullableFilter<"NodeLog">
    nodeExecution?: XOR<NodeExecutionRelationFilter, NodeExecutionWhereInput>
  }, "id">

  export type NodeLogOrderByWithAggregationInput = {
    id?: SortOrder
    nodeExecutionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: NodeLogCountOrderByAggregateInput
    _max?: NodeLogMaxOrderByAggregateInput
    _min?: NodeLogMinOrderByAggregateInput
  }

  export type NodeLogScalarWhereWithAggregatesInput = {
    AND?: NodeLogScalarWhereWithAggregatesInput | NodeLogScalarWhereWithAggregatesInput[]
    OR?: NodeLogScalarWhereWithAggregatesInput[]
    NOT?: NodeLogScalarWhereWithAggregatesInput | NodeLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NodeLog"> | string
    nodeExecutionId?: StringWithAggregatesFilter<"NodeLog"> | string
    level?: EnumLogLevelWithAggregatesFilter<"NodeLog"> | $Enums.LogLevel
    message?: StringWithAggregatesFilter<"NodeLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NodeLog"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"NodeLog">
  }

  export type NodeInputWhereInput = {
    AND?: NodeInputWhereInput | NodeInputWhereInput[]
    OR?: NodeInputWhereInput[]
    NOT?: NodeInputWhereInput | NodeInputWhereInput[]
    id?: StringFilter<"NodeInput"> | string
    executionId?: StringFilter<"NodeInput"> | string
    nodeId?: StringFilter<"NodeInput"> | string
    inputData?: JsonNullableFilter<"NodeInput">
    createdAt?: DateTimeNullableFilter<"NodeInput"> | Date | string | null
    nodeExecution?: XOR<NodeExecutionRelationFilter, NodeExecutionWhereInput>
  }

  export type NodeInputOrderByWithRelationInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    inputData?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    nodeExecution?: NodeExecutionOrderByWithRelationInput
  }

  export type NodeInputWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NodeInputWhereInput | NodeInputWhereInput[]
    OR?: NodeInputWhereInput[]
    NOT?: NodeInputWhereInput | NodeInputWhereInput[]
    executionId?: StringFilter<"NodeInput"> | string
    nodeId?: StringFilter<"NodeInput"> | string
    inputData?: JsonNullableFilter<"NodeInput">
    createdAt?: DateTimeNullableFilter<"NodeInput"> | Date | string | null
    nodeExecution?: XOR<NodeExecutionRelationFilter, NodeExecutionWhereInput>
  }, "id">

  export type NodeInputOrderByWithAggregationInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    inputData?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: NodeInputCountOrderByAggregateInput
    _max?: NodeInputMaxOrderByAggregateInput
    _min?: NodeInputMinOrderByAggregateInput
  }

  export type NodeInputScalarWhereWithAggregatesInput = {
    AND?: NodeInputScalarWhereWithAggregatesInput | NodeInputScalarWhereWithAggregatesInput[]
    OR?: NodeInputScalarWhereWithAggregatesInput[]
    NOT?: NodeInputScalarWhereWithAggregatesInput | NodeInputScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NodeInput"> | string
    executionId?: StringWithAggregatesFilter<"NodeInput"> | string
    nodeId?: StringWithAggregatesFilter<"NodeInput"> | string
    inputData?: JsonNullableWithAggregatesFilter<"NodeInput">
    createdAt?: DateTimeNullableWithAggregatesFilter<"NodeInput"> | Date | string | null
  }

  export type NodeOutputWhereInput = {
    AND?: NodeOutputWhereInput | NodeOutputWhereInput[]
    OR?: NodeOutputWhereInput[]
    NOT?: NodeOutputWhereInput | NodeOutputWhereInput[]
    id?: StringFilter<"NodeOutput"> | string
    executionId?: StringFilter<"NodeOutput"> | string
    nodeId?: StringFilter<"NodeOutput"> | string
    outputData?: JsonNullableFilter<"NodeOutput">
    createdAt?: DateTimeNullableFilter<"NodeOutput"> | Date | string | null
    nodeExecution?: XOR<NodeExecutionRelationFilter, NodeExecutionWhereInput>
  }

  export type NodeOutputOrderByWithRelationInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    outputData?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    nodeExecution?: NodeExecutionOrderByWithRelationInput
  }

  export type NodeOutputWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NodeOutputWhereInput | NodeOutputWhereInput[]
    OR?: NodeOutputWhereInput[]
    NOT?: NodeOutputWhereInput | NodeOutputWhereInput[]
    executionId?: StringFilter<"NodeOutput"> | string
    nodeId?: StringFilter<"NodeOutput"> | string
    outputData?: JsonNullableFilter<"NodeOutput">
    createdAt?: DateTimeNullableFilter<"NodeOutput"> | Date | string | null
    nodeExecution?: XOR<NodeExecutionRelationFilter, NodeExecutionWhereInput>
  }, "id">

  export type NodeOutputOrderByWithAggregationInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    outputData?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: NodeOutputCountOrderByAggregateInput
    _max?: NodeOutputMaxOrderByAggregateInput
    _min?: NodeOutputMinOrderByAggregateInput
  }

  export type NodeOutputScalarWhereWithAggregatesInput = {
    AND?: NodeOutputScalarWhereWithAggregatesInput | NodeOutputScalarWhereWithAggregatesInput[]
    OR?: NodeOutputScalarWhereWithAggregatesInput[]
    NOT?: NodeOutputScalarWhereWithAggregatesInput | NodeOutputScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NodeOutput"> | string
    executionId?: StringWithAggregatesFilter<"NodeOutput"> | string
    nodeId?: StringWithAggregatesFilter<"NodeOutput"> | string
    outputData?: JsonNullableWithAggregatesFilter<"NodeOutput">
    createdAt?: DateTimeNullableWithAggregatesFilter<"NodeOutput"> | Date | string | null
  }

  export type ExecutionLogWhereInput = {
    AND?: ExecutionLogWhereInput | ExecutionLogWhereInput[]
    OR?: ExecutionLogWhereInput[]
    NOT?: ExecutionLogWhereInput | ExecutionLogWhereInput[]
    id?: StringFilter<"ExecutionLog"> | string
    executionId?: StringFilter<"ExecutionLog"> | string
    level?: EnumLogLevelFilter<"ExecutionLog"> | $Enums.LogLevel
    message?: StringFilter<"ExecutionLog"> | string
    timestamp?: DateTimeFilter<"ExecutionLog"> | Date | string
    metadata?: JsonNullableFilter<"ExecutionLog">
    execution?: XOR<WorkflowExecutionRelationFilter, WorkflowExecutionWhereInput>
  }

  export type ExecutionLogOrderByWithRelationInput = {
    id?: SortOrder
    executionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    execution?: WorkflowExecutionOrderByWithRelationInput
  }

  export type ExecutionLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExecutionLogWhereInput | ExecutionLogWhereInput[]
    OR?: ExecutionLogWhereInput[]
    NOT?: ExecutionLogWhereInput | ExecutionLogWhereInput[]
    executionId?: StringFilter<"ExecutionLog"> | string
    level?: EnumLogLevelFilter<"ExecutionLog"> | $Enums.LogLevel
    message?: StringFilter<"ExecutionLog"> | string
    timestamp?: DateTimeFilter<"ExecutionLog"> | Date | string
    metadata?: JsonNullableFilter<"ExecutionLog">
    execution?: XOR<WorkflowExecutionRelationFilter, WorkflowExecutionWhereInput>
  }, "id">

  export type ExecutionLogOrderByWithAggregationInput = {
    id?: SortOrder
    executionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: ExecutionLogCountOrderByAggregateInput
    _max?: ExecutionLogMaxOrderByAggregateInput
    _min?: ExecutionLogMinOrderByAggregateInput
  }

  export type ExecutionLogScalarWhereWithAggregatesInput = {
    AND?: ExecutionLogScalarWhereWithAggregatesInput | ExecutionLogScalarWhereWithAggregatesInput[]
    OR?: ExecutionLogScalarWhereWithAggregatesInput[]
    NOT?: ExecutionLogScalarWhereWithAggregatesInput | ExecutionLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExecutionLog"> | string
    executionId?: StringWithAggregatesFilter<"ExecutionLog"> | string
    level?: EnumLogLevelWithAggregatesFilter<"ExecutionLog"> | $Enums.LogLevel
    message?: StringWithAggregatesFilter<"ExecutionLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"ExecutionLog"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"ExecutionLog">
  }

  export type WorkflowPauseWhereInput = {
    AND?: WorkflowPauseWhereInput | WorkflowPauseWhereInput[]
    OR?: WorkflowPauseWhereInput[]
    NOT?: WorkflowPauseWhereInput | WorkflowPauseWhereInput[]
    id?: StringFilter<"WorkflowPause"> | string
    workflowId?: StringFilter<"WorkflowPause"> | string
    executionId?: StringFilter<"WorkflowPause"> | string
    nodeId?: StringFilter<"WorkflowPause"> | string
    reason?: StringFilter<"WorkflowPause"> | string
    resumeData?: JsonNullableFilter<"WorkflowPause">
    createdAt?: DateTimeFilter<"WorkflowPause"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowPause"> | Date | string
    workflow?: XOR<WorkflowRelationFilter, WorkflowWhereInput>
    execution?: XOR<WorkflowExecutionRelationFilter, WorkflowExecutionWhereInput>
  }

  export type WorkflowPauseOrderByWithRelationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    reason?: SortOrder
    resumeData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflow?: WorkflowOrderByWithRelationInput
    execution?: WorkflowExecutionOrderByWithRelationInput
  }

  export type WorkflowPauseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowPauseWhereInput | WorkflowPauseWhereInput[]
    OR?: WorkflowPauseWhereInput[]
    NOT?: WorkflowPauseWhereInput | WorkflowPauseWhereInput[]
    workflowId?: StringFilter<"WorkflowPause"> | string
    executionId?: StringFilter<"WorkflowPause"> | string
    nodeId?: StringFilter<"WorkflowPause"> | string
    reason?: StringFilter<"WorkflowPause"> | string
    resumeData?: JsonNullableFilter<"WorkflowPause">
    createdAt?: DateTimeFilter<"WorkflowPause"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowPause"> | Date | string
    workflow?: XOR<WorkflowRelationFilter, WorkflowWhereInput>
    execution?: XOR<WorkflowExecutionRelationFilter, WorkflowExecutionWhereInput>
  }, "id">

  export type WorkflowPauseOrderByWithAggregationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    reason?: SortOrder
    resumeData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkflowPauseCountOrderByAggregateInput
    _max?: WorkflowPauseMaxOrderByAggregateInput
    _min?: WorkflowPauseMinOrderByAggregateInput
  }

  export type WorkflowPauseScalarWhereWithAggregatesInput = {
    AND?: WorkflowPauseScalarWhereWithAggregatesInput | WorkflowPauseScalarWhereWithAggregatesInput[]
    OR?: WorkflowPauseScalarWhereWithAggregatesInput[]
    NOT?: WorkflowPauseScalarWhereWithAggregatesInput | WorkflowPauseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowPause"> | string
    workflowId?: StringWithAggregatesFilter<"WorkflowPause"> | string
    executionId?: StringWithAggregatesFilter<"WorkflowPause"> | string
    nodeId?: StringWithAggregatesFilter<"WorkflowPause"> | string
    reason?: StringWithAggregatesFilter<"WorkflowPause"> | string
    resumeData?: JsonNullableWithAggregatesFilter<"WorkflowPause">
    createdAt?: DateTimeWithAggregatesFilter<"WorkflowPause"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkflowPause"> | Date | string
  }

  export type BlockchainTransactionWhereInput = {
    AND?: BlockchainTransactionWhereInput | BlockchainTransactionWhereInput[]
    OR?: BlockchainTransactionWhereInput[]
    NOT?: BlockchainTransactionWhereInput | BlockchainTransactionWhereInput[]
    id?: StringFilter<"BlockchainTransaction"> | string
    nodeId?: StringFilter<"BlockchainTransaction"> | string
    executionId?: StringFilter<"BlockchainTransaction"> | string
    toAddress?: StringFilter<"BlockchainTransaction"> | string
    value?: StringFilter<"BlockchainTransaction"> | string
    data?: JsonNullableFilter<"BlockchainTransaction">
    chainId?: IntFilter<"BlockchainTransaction"> | number
    gasLimit?: StringNullableFilter<"BlockchainTransaction"> | string | null
    gasUsed?: StringNullableFilter<"BlockchainTransaction"> | string | null
    maxFeePerGas?: StringNullableFilter<"BlockchainTransaction"> | string | null
    maxPriorityFeePerGas?: StringNullableFilter<"BlockchainTransaction"> | string | null
    nonce?: IntNullableFilter<"BlockchainTransaction"> | number | null
    status?: StringFilter<"BlockchainTransaction"> | string
    hash?: StringNullableFilter<"BlockchainTransaction"> | string | null
    txHash?: StringNullableFilter<"BlockchainTransaction"> | string | null
    blockNumber?: IntNullableFilter<"BlockchainTransaction"> | number | null
    createdAt?: DateTimeFilter<"BlockchainTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BlockchainTransaction"> | Date | string
    userId?: StringNullableFilter<"BlockchainTransaction"> | string | null
    walletAddress?: StringFilter<"BlockchainTransaction"> | string
    effectiveGasPrice?: StringNullableFilter<"BlockchainTransaction"> | string | null
    error?: StringNullableFilter<"BlockchainTransaction"> | string | null
    fromAddress?: StringNullableFilter<"BlockchainTransaction"> | string | null
    execution?: XOR<WorkflowExecutionRelationFilter, WorkflowExecutionWhereInput>
    transactionAttempts?: TransactionAttemptListRelationFilter
  }

  export type BlockchainTransactionOrderByWithRelationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    executionId?: SortOrder
    toAddress?: SortOrder
    value?: SortOrder
    data?: SortOrderInput | SortOrder
    chainId?: SortOrder
    gasLimit?: SortOrderInput | SortOrder
    gasUsed?: SortOrderInput | SortOrder
    maxFeePerGas?: SortOrderInput | SortOrder
    maxPriorityFeePerGas?: SortOrderInput | SortOrder
    nonce?: SortOrderInput | SortOrder
    status?: SortOrder
    hash?: SortOrderInput | SortOrder
    txHash?: SortOrderInput | SortOrder
    blockNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    walletAddress?: SortOrder
    effectiveGasPrice?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    fromAddress?: SortOrderInput | SortOrder
    execution?: WorkflowExecutionOrderByWithRelationInput
    transactionAttempts?: TransactionAttemptOrderByRelationAggregateInput
  }

  export type BlockchainTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlockchainTransactionWhereInput | BlockchainTransactionWhereInput[]
    OR?: BlockchainTransactionWhereInput[]
    NOT?: BlockchainTransactionWhereInput | BlockchainTransactionWhereInput[]
    nodeId?: StringFilter<"BlockchainTransaction"> | string
    executionId?: StringFilter<"BlockchainTransaction"> | string
    toAddress?: StringFilter<"BlockchainTransaction"> | string
    value?: StringFilter<"BlockchainTransaction"> | string
    data?: JsonNullableFilter<"BlockchainTransaction">
    chainId?: IntFilter<"BlockchainTransaction"> | number
    gasLimit?: StringNullableFilter<"BlockchainTransaction"> | string | null
    gasUsed?: StringNullableFilter<"BlockchainTransaction"> | string | null
    maxFeePerGas?: StringNullableFilter<"BlockchainTransaction"> | string | null
    maxPriorityFeePerGas?: StringNullableFilter<"BlockchainTransaction"> | string | null
    nonce?: IntNullableFilter<"BlockchainTransaction"> | number | null
    status?: StringFilter<"BlockchainTransaction"> | string
    hash?: StringNullableFilter<"BlockchainTransaction"> | string | null
    txHash?: StringNullableFilter<"BlockchainTransaction"> | string | null
    blockNumber?: IntNullableFilter<"BlockchainTransaction"> | number | null
    createdAt?: DateTimeFilter<"BlockchainTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BlockchainTransaction"> | Date | string
    userId?: StringNullableFilter<"BlockchainTransaction"> | string | null
    walletAddress?: StringFilter<"BlockchainTransaction"> | string
    effectiveGasPrice?: StringNullableFilter<"BlockchainTransaction"> | string | null
    error?: StringNullableFilter<"BlockchainTransaction"> | string | null
    fromAddress?: StringNullableFilter<"BlockchainTransaction"> | string | null
    execution?: XOR<WorkflowExecutionRelationFilter, WorkflowExecutionWhereInput>
    transactionAttempts?: TransactionAttemptListRelationFilter
  }, "id">

  export type BlockchainTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    executionId?: SortOrder
    toAddress?: SortOrder
    value?: SortOrder
    data?: SortOrderInput | SortOrder
    chainId?: SortOrder
    gasLimit?: SortOrderInput | SortOrder
    gasUsed?: SortOrderInput | SortOrder
    maxFeePerGas?: SortOrderInput | SortOrder
    maxPriorityFeePerGas?: SortOrderInput | SortOrder
    nonce?: SortOrderInput | SortOrder
    status?: SortOrder
    hash?: SortOrderInput | SortOrder
    txHash?: SortOrderInput | SortOrder
    blockNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    walletAddress?: SortOrder
    effectiveGasPrice?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    fromAddress?: SortOrderInput | SortOrder
    _count?: BlockchainTransactionCountOrderByAggregateInput
    _avg?: BlockchainTransactionAvgOrderByAggregateInput
    _max?: BlockchainTransactionMaxOrderByAggregateInput
    _min?: BlockchainTransactionMinOrderByAggregateInput
    _sum?: BlockchainTransactionSumOrderByAggregateInput
  }

  export type BlockchainTransactionScalarWhereWithAggregatesInput = {
    AND?: BlockchainTransactionScalarWhereWithAggregatesInput | BlockchainTransactionScalarWhereWithAggregatesInput[]
    OR?: BlockchainTransactionScalarWhereWithAggregatesInput[]
    NOT?: BlockchainTransactionScalarWhereWithAggregatesInput | BlockchainTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlockchainTransaction"> | string
    nodeId?: StringWithAggregatesFilter<"BlockchainTransaction"> | string
    executionId?: StringWithAggregatesFilter<"BlockchainTransaction"> | string
    toAddress?: StringWithAggregatesFilter<"BlockchainTransaction"> | string
    value?: StringWithAggregatesFilter<"BlockchainTransaction"> | string
    data?: JsonNullableWithAggregatesFilter<"BlockchainTransaction">
    chainId?: IntWithAggregatesFilter<"BlockchainTransaction"> | number
    gasLimit?: StringNullableWithAggregatesFilter<"BlockchainTransaction"> | string | null
    gasUsed?: StringNullableWithAggregatesFilter<"BlockchainTransaction"> | string | null
    maxFeePerGas?: StringNullableWithAggregatesFilter<"BlockchainTransaction"> | string | null
    maxPriorityFeePerGas?: StringNullableWithAggregatesFilter<"BlockchainTransaction"> | string | null
    nonce?: IntNullableWithAggregatesFilter<"BlockchainTransaction"> | number | null
    status?: StringWithAggregatesFilter<"BlockchainTransaction"> | string
    hash?: StringNullableWithAggregatesFilter<"BlockchainTransaction"> | string | null
    txHash?: StringNullableWithAggregatesFilter<"BlockchainTransaction"> | string | null
    blockNumber?: IntNullableWithAggregatesFilter<"BlockchainTransaction"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"BlockchainTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlockchainTransaction"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"BlockchainTransaction"> | string | null
    walletAddress?: StringWithAggregatesFilter<"BlockchainTransaction"> | string
    effectiveGasPrice?: StringNullableWithAggregatesFilter<"BlockchainTransaction"> | string | null
    error?: StringNullableWithAggregatesFilter<"BlockchainTransaction"> | string | null
    fromAddress?: StringNullableWithAggregatesFilter<"BlockchainTransaction"> | string | null
  }

  export type TransactionAttemptWhereInput = {
    AND?: TransactionAttemptWhereInput | TransactionAttemptWhereInput[]
    OR?: TransactionAttemptWhereInput[]
    NOT?: TransactionAttemptWhereInput | TransactionAttemptWhereInput[]
    id?: StringFilter<"TransactionAttempt"> | string
    transactionId?: StringFilter<"TransactionAttempt"> | string
    txHash?: StringNullableFilter<"TransactionAttempt"> | string | null
    status?: StringFilter<"TransactionAttempt"> | string
    error?: StringNullableFilter<"TransactionAttempt"> | string | null
    blockNumber?: IntNullableFilter<"TransactionAttempt"> | number | null
    gasUsed?: StringNullableFilter<"TransactionAttempt"> | string | null
    effectiveGasPrice?: StringNullableFilter<"TransactionAttempt"> | string | null
    createdAt?: DateTimeFilter<"TransactionAttempt"> | Date | string
    transaction?: XOR<BlockchainTransactionRelationFilter, BlockchainTransactionWhereInput>
  }

  export type TransactionAttemptOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    txHash?: SortOrderInput | SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    blockNumber?: SortOrderInput | SortOrder
    gasUsed?: SortOrderInput | SortOrder
    effectiveGasPrice?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    transaction?: BlockchainTransactionOrderByWithRelationInput
  }

  export type TransactionAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionAttemptWhereInput | TransactionAttemptWhereInput[]
    OR?: TransactionAttemptWhereInput[]
    NOT?: TransactionAttemptWhereInput | TransactionAttemptWhereInput[]
    transactionId?: StringFilter<"TransactionAttempt"> | string
    txHash?: StringNullableFilter<"TransactionAttempt"> | string | null
    status?: StringFilter<"TransactionAttempt"> | string
    error?: StringNullableFilter<"TransactionAttempt"> | string | null
    blockNumber?: IntNullableFilter<"TransactionAttempt"> | number | null
    gasUsed?: StringNullableFilter<"TransactionAttempt"> | string | null
    effectiveGasPrice?: StringNullableFilter<"TransactionAttempt"> | string | null
    createdAt?: DateTimeFilter<"TransactionAttempt"> | Date | string
    transaction?: XOR<BlockchainTransactionRelationFilter, BlockchainTransactionWhereInput>
  }, "id">

  export type TransactionAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    txHash?: SortOrderInput | SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    blockNumber?: SortOrderInput | SortOrder
    gasUsed?: SortOrderInput | SortOrder
    effectiveGasPrice?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TransactionAttemptCountOrderByAggregateInput
    _avg?: TransactionAttemptAvgOrderByAggregateInput
    _max?: TransactionAttemptMaxOrderByAggregateInput
    _min?: TransactionAttemptMinOrderByAggregateInput
    _sum?: TransactionAttemptSumOrderByAggregateInput
  }

  export type TransactionAttemptScalarWhereWithAggregatesInput = {
    AND?: TransactionAttemptScalarWhereWithAggregatesInput | TransactionAttemptScalarWhereWithAggregatesInput[]
    OR?: TransactionAttemptScalarWhereWithAggregatesInput[]
    NOT?: TransactionAttemptScalarWhereWithAggregatesInput | TransactionAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransactionAttempt"> | string
    transactionId?: StringWithAggregatesFilter<"TransactionAttempt"> | string
    txHash?: StringNullableWithAggregatesFilter<"TransactionAttempt"> | string | null
    status?: StringWithAggregatesFilter<"TransactionAttempt"> | string
    error?: StringNullableWithAggregatesFilter<"TransactionAttempt"> | string | null
    blockNumber?: IntNullableWithAggregatesFilter<"TransactionAttempt"> | number | null
    gasUsed?: StringNullableWithAggregatesFilter<"TransactionAttempt"> | string | null
    effectiveGasPrice?: StringNullableWithAggregatesFilter<"TransactionAttempt"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TransactionAttempt"> | Date | string
  }

  export type AiBlockchainOperationWhereInput = {
    AND?: AiBlockchainOperationWhereInput | AiBlockchainOperationWhereInput[]
    OR?: AiBlockchainOperationWhereInput[]
    NOT?: AiBlockchainOperationWhereInput | AiBlockchainOperationWhereInput[]
    id?: StringFilter<"AiBlockchainOperation"> | string
    userId?: StringFilter<"AiBlockchainOperation"> | string
    executionId?: StringFilter<"AiBlockchainOperation"> | string
    nodeId?: StringFilter<"AiBlockchainOperation"> | string
    operationType?: StringFilter<"AiBlockchainOperation"> | string
    blockchain?: StringNullableFilter<"AiBlockchainOperation"> | string | null
    prompt?: StringNullableFilter<"AiBlockchainOperation"> | string | null
    result?: JsonNullableFilter<"AiBlockchainOperation">
    status?: StringFilter<"AiBlockchainOperation"> | string
    error?: StringNullableFilter<"AiBlockchainOperation"> | string | null
    createdAt?: DateTimeFilter<"AiBlockchainOperation"> | Date | string
  }

  export type AiBlockchainOperationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    operationType?: SortOrder
    blockchain?: SortOrderInput | SortOrder
    prompt?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AiBlockchainOperationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiBlockchainOperationWhereInput | AiBlockchainOperationWhereInput[]
    OR?: AiBlockchainOperationWhereInput[]
    NOT?: AiBlockchainOperationWhereInput | AiBlockchainOperationWhereInput[]
    userId?: StringFilter<"AiBlockchainOperation"> | string
    executionId?: StringFilter<"AiBlockchainOperation"> | string
    nodeId?: StringFilter<"AiBlockchainOperation"> | string
    operationType?: StringFilter<"AiBlockchainOperation"> | string
    blockchain?: StringNullableFilter<"AiBlockchainOperation"> | string | null
    prompt?: StringNullableFilter<"AiBlockchainOperation"> | string | null
    result?: JsonNullableFilter<"AiBlockchainOperation">
    status?: StringFilter<"AiBlockchainOperation"> | string
    error?: StringNullableFilter<"AiBlockchainOperation"> | string | null
    createdAt?: DateTimeFilter<"AiBlockchainOperation"> | Date | string
  }, "id">

  export type AiBlockchainOperationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    operationType?: SortOrder
    blockchain?: SortOrderInput | SortOrder
    prompt?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AiBlockchainOperationCountOrderByAggregateInput
    _max?: AiBlockchainOperationMaxOrderByAggregateInput
    _min?: AiBlockchainOperationMinOrderByAggregateInput
  }

  export type AiBlockchainOperationScalarWhereWithAggregatesInput = {
    AND?: AiBlockchainOperationScalarWhereWithAggregatesInput | AiBlockchainOperationScalarWhereWithAggregatesInput[]
    OR?: AiBlockchainOperationScalarWhereWithAggregatesInput[]
    NOT?: AiBlockchainOperationScalarWhereWithAggregatesInput | AiBlockchainOperationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiBlockchainOperation"> | string
    userId?: StringWithAggregatesFilter<"AiBlockchainOperation"> | string
    executionId?: StringWithAggregatesFilter<"AiBlockchainOperation"> | string
    nodeId?: StringWithAggregatesFilter<"AiBlockchainOperation"> | string
    operationType?: StringWithAggregatesFilter<"AiBlockchainOperation"> | string
    blockchain?: StringNullableWithAggregatesFilter<"AiBlockchainOperation"> | string | null
    prompt?: StringNullableWithAggregatesFilter<"AiBlockchainOperation"> | string | null
    result?: JsonNullableWithAggregatesFilter<"AiBlockchainOperation">
    status?: StringWithAggregatesFilter<"AiBlockchainOperation"> | string
    error?: StringNullableWithAggregatesFilter<"AiBlockchainOperation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AiBlockchainOperation"> | Date | string
  }

  export type BlockExecutionWhereInput = {
    AND?: BlockExecutionWhereInput | BlockExecutionWhereInput[]
    OR?: BlockExecutionWhereInput[]
    NOT?: BlockExecutionWhereInput | BlockExecutionWhereInput[]
    id?: StringFilter<"BlockExecution"> | string
    executionId?: StringFilter<"BlockExecution"> | string
    nodeId?: StringFilter<"BlockExecution"> | string
    blockType?: StringFilter<"BlockExecution"> | string
    status?: EnumBlockStatusFilter<"BlockExecution"> | $Enums.BlockStatus
    input?: JsonNullableFilter<"BlockExecution">
    output?: JsonNullableFilter<"BlockExecution">
    error?: StringNullableFilter<"BlockExecution"> | string | null
    startTime?: DateTimeFilter<"BlockExecution"> | Date | string
    endTime?: DateTimeNullableFilter<"BlockExecution"> | Date | string | null
    execution?: XOR<WorkflowExecutionRelationFilter, WorkflowExecutionWhereInput>
    logs?: BlockExecutionLogListRelationFilter
  }

  export type BlockExecutionOrderByWithRelationInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    blockType?: SortOrder
    status?: SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    execution?: WorkflowExecutionOrderByWithRelationInput
    logs?: BlockExecutionLogOrderByRelationAggregateInput
  }

  export type BlockExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlockExecutionWhereInput | BlockExecutionWhereInput[]
    OR?: BlockExecutionWhereInput[]
    NOT?: BlockExecutionWhereInput | BlockExecutionWhereInput[]
    executionId?: StringFilter<"BlockExecution"> | string
    nodeId?: StringFilter<"BlockExecution"> | string
    blockType?: StringFilter<"BlockExecution"> | string
    status?: EnumBlockStatusFilter<"BlockExecution"> | $Enums.BlockStatus
    input?: JsonNullableFilter<"BlockExecution">
    output?: JsonNullableFilter<"BlockExecution">
    error?: StringNullableFilter<"BlockExecution"> | string | null
    startTime?: DateTimeFilter<"BlockExecution"> | Date | string
    endTime?: DateTimeNullableFilter<"BlockExecution"> | Date | string | null
    execution?: XOR<WorkflowExecutionRelationFilter, WorkflowExecutionWhereInput>
    logs?: BlockExecutionLogListRelationFilter
  }, "id">

  export type BlockExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    blockType?: SortOrder
    status?: SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    _count?: BlockExecutionCountOrderByAggregateInput
    _max?: BlockExecutionMaxOrderByAggregateInput
    _min?: BlockExecutionMinOrderByAggregateInput
  }

  export type BlockExecutionScalarWhereWithAggregatesInput = {
    AND?: BlockExecutionScalarWhereWithAggregatesInput | BlockExecutionScalarWhereWithAggregatesInput[]
    OR?: BlockExecutionScalarWhereWithAggregatesInput[]
    NOT?: BlockExecutionScalarWhereWithAggregatesInput | BlockExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlockExecution"> | string
    executionId?: StringWithAggregatesFilter<"BlockExecution"> | string
    nodeId?: StringWithAggregatesFilter<"BlockExecution"> | string
    blockType?: StringWithAggregatesFilter<"BlockExecution"> | string
    status?: EnumBlockStatusWithAggregatesFilter<"BlockExecution"> | $Enums.BlockStatus
    input?: JsonNullableWithAggregatesFilter<"BlockExecution">
    output?: JsonNullableWithAggregatesFilter<"BlockExecution">
    error?: StringNullableWithAggregatesFilter<"BlockExecution"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"BlockExecution"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"BlockExecution"> | Date | string | null
  }

  export type BlockExecutionLogWhereInput = {
    AND?: BlockExecutionLogWhereInput | BlockExecutionLogWhereInput[]
    OR?: BlockExecutionLogWhereInput[]
    NOT?: BlockExecutionLogWhereInput | BlockExecutionLogWhereInput[]
    id?: StringFilter<"BlockExecutionLog"> | string
    blockExecutionId?: StringFilter<"BlockExecutionLog"> | string
    level?: EnumLogLevelFilter<"BlockExecutionLog"> | $Enums.LogLevel
    message?: StringFilter<"BlockExecutionLog"> | string
    timestamp?: DateTimeFilter<"BlockExecutionLog"> | Date | string
    blockExecution?: XOR<BlockExecutionRelationFilter, BlockExecutionWhereInput>
  }

  export type BlockExecutionLogOrderByWithRelationInput = {
    id?: SortOrder
    blockExecutionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    blockExecution?: BlockExecutionOrderByWithRelationInput
  }

  export type BlockExecutionLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlockExecutionLogWhereInput | BlockExecutionLogWhereInput[]
    OR?: BlockExecutionLogWhereInput[]
    NOT?: BlockExecutionLogWhereInput | BlockExecutionLogWhereInput[]
    blockExecutionId?: StringFilter<"BlockExecutionLog"> | string
    level?: EnumLogLevelFilter<"BlockExecutionLog"> | $Enums.LogLevel
    message?: StringFilter<"BlockExecutionLog"> | string
    timestamp?: DateTimeFilter<"BlockExecutionLog"> | Date | string
    blockExecution?: XOR<BlockExecutionRelationFilter, BlockExecutionWhereInput>
  }, "id">

  export type BlockExecutionLogOrderByWithAggregationInput = {
    id?: SortOrder
    blockExecutionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    _count?: BlockExecutionLogCountOrderByAggregateInput
    _max?: BlockExecutionLogMaxOrderByAggregateInput
    _min?: BlockExecutionLogMinOrderByAggregateInput
  }

  export type BlockExecutionLogScalarWhereWithAggregatesInput = {
    AND?: BlockExecutionLogScalarWhereWithAggregatesInput | BlockExecutionLogScalarWhereWithAggregatesInput[]
    OR?: BlockExecutionLogScalarWhereWithAggregatesInput[]
    NOT?: BlockExecutionLogScalarWhereWithAggregatesInput | BlockExecutionLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlockExecutionLog"> | string
    blockExecutionId?: StringWithAggregatesFilter<"BlockExecutionLog"> | string
    level?: EnumLogLevelWithAggregatesFilter<"BlockExecutionLog"> | $Enums.LogLevel
    message?: StringWithAggregatesFilter<"BlockExecutionLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"BlockExecutionLog"> | Date | string
  }

  export type BlockLibraryWhereInput = {
    AND?: BlockLibraryWhereInput | BlockLibraryWhereInput[]
    OR?: BlockLibraryWhereInput[]
    NOT?: BlockLibraryWhereInput | BlockLibraryWhereInput[]
    id?: StringFilter<"BlockLibrary"> | string
    name?: StringFilter<"BlockLibrary"> | string
    description?: StringFilter<"BlockLibrary"> | string
    blockType?: StringFilter<"BlockLibrary"> | string
    category?: StringNullableFilter<"BlockLibrary"> | string | null
    configuration?: JsonFilter<"BlockLibrary">
    blockData?: JsonNullableFilter<"BlockLibrary">
    executionCode?: StringNullableFilter<"BlockLibrary"> | string | null
    userId?: StringFilter<"BlockLibrary"> | string
    isPublic?: BoolNullableFilter<"BlockLibrary"> | boolean | null
    isVerified?: BoolNullableFilter<"BlockLibrary"> | boolean | null
    rating?: FloatNullableFilter<"BlockLibrary"> | number | null
    usageCount?: IntNullableFilter<"BlockLibrary"> | number | null
    tags?: StringNullableListFilter<"BlockLibrary">
    version?: StringNullableFilter<"BlockLibrary"> | string | null
    createdAt?: DateTimeNullableFilter<"BlockLibrary"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"BlockLibrary"> | Date | string | null
    ratings?: BlockLibraryRatingListRelationFilter
  }

  export type BlockLibraryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    blockType?: SortOrder
    category?: SortOrderInput | SortOrder
    configuration?: SortOrder
    blockData?: SortOrderInput | SortOrder
    executionCode?: SortOrderInput | SortOrder
    userId?: SortOrder
    isPublic?: SortOrderInput | SortOrder
    isVerified?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    usageCount?: SortOrderInput | SortOrder
    tags?: SortOrder
    version?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    ratings?: BlockLibraryRatingOrderByRelationAggregateInput
  }

  export type BlockLibraryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlockLibraryWhereInput | BlockLibraryWhereInput[]
    OR?: BlockLibraryWhereInput[]
    NOT?: BlockLibraryWhereInput | BlockLibraryWhereInput[]
    name?: StringFilter<"BlockLibrary"> | string
    description?: StringFilter<"BlockLibrary"> | string
    blockType?: StringFilter<"BlockLibrary"> | string
    category?: StringNullableFilter<"BlockLibrary"> | string | null
    configuration?: JsonFilter<"BlockLibrary">
    blockData?: JsonNullableFilter<"BlockLibrary">
    executionCode?: StringNullableFilter<"BlockLibrary"> | string | null
    userId?: StringFilter<"BlockLibrary"> | string
    isPublic?: BoolNullableFilter<"BlockLibrary"> | boolean | null
    isVerified?: BoolNullableFilter<"BlockLibrary"> | boolean | null
    rating?: FloatNullableFilter<"BlockLibrary"> | number | null
    usageCount?: IntNullableFilter<"BlockLibrary"> | number | null
    tags?: StringNullableListFilter<"BlockLibrary">
    version?: StringNullableFilter<"BlockLibrary"> | string | null
    createdAt?: DateTimeNullableFilter<"BlockLibrary"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"BlockLibrary"> | Date | string | null
    ratings?: BlockLibraryRatingListRelationFilter
  }, "id">

  export type BlockLibraryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    blockType?: SortOrder
    category?: SortOrderInput | SortOrder
    configuration?: SortOrder
    blockData?: SortOrderInput | SortOrder
    executionCode?: SortOrderInput | SortOrder
    userId?: SortOrder
    isPublic?: SortOrderInput | SortOrder
    isVerified?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    usageCount?: SortOrderInput | SortOrder
    tags?: SortOrder
    version?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: BlockLibraryCountOrderByAggregateInput
    _avg?: BlockLibraryAvgOrderByAggregateInput
    _max?: BlockLibraryMaxOrderByAggregateInput
    _min?: BlockLibraryMinOrderByAggregateInput
    _sum?: BlockLibrarySumOrderByAggregateInput
  }

  export type BlockLibraryScalarWhereWithAggregatesInput = {
    AND?: BlockLibraryScalarWhereWithAggregatesInput | BlockLibraryScalarWhereWithAggregatesInput[]
    OR?: BlockLibraryScalarWhereWithAggregatesInput[]
    NOT?: BlockLibraryScalarWhereWithAggregatesInput | BlockLibraryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlockLibrary"> | string
    name?: StringWithAggregatesFilter<"BlockLibrary"> | string
    description?: StringWithAggregatesFilter<"BlockLibrary"> | string
    blockType?: StringWithAggregatesFilter<"BlockLibrary"> | string
    category?: StringNullableWithAggregatesFilter<"BlockLibrary"> | string | null
    configuration?: JsonWithAggregatesFilter<"BlockLibrary">
    blockData?: JsonNullableWithAggregatesFilter<"BlockLibrary">
    executionCode?: StringNullableWithAggregatesFilter<"BlockLibrary"> | string | null
    userId?: StringWithAggregatesFilter<"BlockLibrary"> | string
    isPublic?: BoolNullableWithAggregatesFilter<"BlockLibrary"> | boolean | null
    isVerified?: BoolNullableWithAggregatesFilter<"BlockLibrary"> | boolean | null
    rating?: FloatNullableWithAggregatesFilter<"BlockLibrary"> | number | null
    usageCount?: IntNullableWithAggregatesFilter<"BlockLibrary"> | number | null
    tags?: StringNullableListFilter<"BlockLibrary">
    version?: StringNullableWithAggregatesFilter<"BlockLibrary"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"BlockLibrary"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"BlockLibrary"> | Date | string | null
  }

  export type BlockLibraryRatingWhereInput = {
    AND?: BlockLibraryRatingWhereInput | BlockLibraryRatingWhereInput[]
    OR?: BlockLibraryRatingWhereInput[]
    NOT?: BlockLibraryRatingWhereInput | BlockLibraryRatingWhereInput[]
    id?: StringFilter<"BlockLibraryRating"> | string
    blockId?: StringFilter<"BlockLibraryRating"> | string
    userId?: StringFilter<"BlockLibraryRating"> | string
    rating?: IntFilter<"BlockLibraryRating"> | number
    comment?: StringNullableFilter<"BlockLibraryRating"> | string | null
    createdAt?: DateTimeFilter<"BlockLibraryRating"> | Date | string
    block?: XOR<BlockLibraryRelationFilter, BlockLibraryWhereInput>
  }

  export type BlockLibraryRatingOrderByWithRelationInput = {
    id?: SortOrder
    blockId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    block?: BlockLibraryOrderByWithRelationInput
  }

  export type BlockLibraryRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    blockId_userId?: BlockLibraryRatingBlockIdUserIdCompoundUniqueInput
    AND?: BlockLibraryRatingWhereInput | BlockLibraryRatingWhereInput[]
    OR?: BlockLibraryRatingWhereInput[]
    NOT?: BlockLibraryRatingWhereInput | BlockLibraryRatingWhereInput[]
    blockId?: StringFilter<"BlockLibraryRating"> | string
    userId?: StringFilter<"BlockLibraryRating"> | string
    rating?: IntFilter<"BlockLibraryRating"> | number
    comment?: StringNullableFilter<"BlockLibraryRating"> | string | null
    createdAt?: DateTimeFilter<"BlockLibraryRating"> | Date | string
    block?: XOR<BlockLibraryRelationFilter, BlockLibraryWhereInput>
  }, "id" | "blockId_userId">

  export type BlockLibraryRatingOrderByWithAggregationInput = {
    id?: SortOrder
    blockId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BlockLibraryRatingCountOrderByAggregateInput
    _avg?: BlockLibraryRatingAvgOrderByAggregateInput
    _max?: BlockLibraryRatingMaxOrderByAggregateInput
    _min?: BlockLibraryRatingMinOrderByAggregateInput
    _sum?: BlockLibraryRatingSumOrderByAggregateInput
  }

  export type BlockLibraryRatingScalarWhereWithAggregatesInput = {
    AND?: BlockLibraryRatingScalarWhereWithAggregatesInput | BlockLibraryRatingScalarWhereWithAggregatesInput[]
    OR?: BlockLibraryRatingScalarWhereWithAggregatesInput[]
    NOT?: BlockLibraryRatingScalarWhereWithAggregatesInput | BlockLibraryRatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlockLibraryRating"> | string
    blockId?: StringWithAggregatesFilter<"BlockLibraryRating"> | string
    userId?: StringWithAggregatesFilter<"BlockLibraryRating"> | string
    rating?: IntWithAggregatesFilter<"BlockLibraryRating"> | number
    comment?: StringNullableWithAggregatesFilter<"BlockLibraryRating"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlockLibraryRating"> | Date | string
  }

  export type CustomBlockWhereInput = {
    AND?: CustomBlockWhereInput | CustomBlockWhereInput[]
    OR?: CustomBlockWhereInput[]
    NOT?: CustomBlockWhereInput | CustomBlockWhereInput[]
    id?: StringFilter<"CustomBlock"> | string
    userId?: StringFilter<"CustomBlock"> | string
    name?: StringFilter<"CustomBlock"> | string
    description?: StringNullableFilter<"CustomBlock"> | string | null
    blockType?: StringNullableFilter<"CustomBlock"> | string | null
    category?: StringFilter<"CustomBlock"> | string
    code?: StringFilter<"CustomBlock"> | string
    logic?: StringFilter<"CustomBlock"> | string
    logicType?: StringFilter<"CustomBlock"> | string
    blockData?: JsonNullableFilter<"CustomBlock">
    tags?: JsonFilter<"CustomBlock">
    createdBy?: StringNullableFilter<"CustomBlock"> | string | null
    icon?: StringNullableFilter<"CustomBlock"> | string | null
    isPublic?: BoolNullableFilter<"CustomBlock"> | boolean | null
    isVerified?: BoolNullableFilter<"CustomBlock"> | boolean | null
    rating?: FloatNullableFilter<"CustomBlock"> | number | null
    usageCount?: IntNullableFilter<"CustomBlock"> | number | null
    version?: StringNullableFilter<"CustomBlock"> | string | null
    createdAt?: DateTimeNullableFilter<"CustomBlock"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CustomBlock"> | Date | string | null
    updatedBy?: StringNullableFilter<"CustomBlock"> | string | null
  }

  export type CustomBlockOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    blockType?: SortOrderInput | SortOrder
    category?: SortOrder
    code?: SortOrder
    logic?: SortOrder
    logicType?: SortOrder
    blockData?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    isPublic?: SortOrderInput | SortOrder
    isVerified?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    usageCount?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
  }

  export type CustomBlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomBlockWhereInput | CustomBlockWhereInput[]
    OR?: CustomBlockWhereInput[]
    NOT?: CustomBlockWhereInput | CustomBlockWhereInput[]
    userId?: StringFilter<"CustomBlock"> | string
    name?: StringFilter<"CustomBlock"> | string
    description?: StringNullableFilter<"CustomBlock"> | string | null
    blockType?: StringNullableFilter<"CustomBlock"> | string | null
    category?: StringFilter<"CustomBlock"> | string
    code?: StringFilter<"CustomBlock"> | string
    logic?: StringFilter<"CustomBlock"> | string
    logicType?: StringFilter<"CustomBlock"> | string
    blockData?: JsonNullableFilter<"CustomBlock">
    tags?: JsonFilter<"CustomBlock">
    createdBy?: StringNullableFilter<"CustomBlock"> | string | null
    icon?: StringNullableFilter<"CustomBlock"> | string | null
    isPublic?: BoolNullableFilter<"CustomBlock"> | boolean | null
    isVerified?: BoolNullableFilter<"CustomBlock"> | boolean | null
    rating?: FloatNullableFilter<"CustomBlock"> | number | null
    usageCount?: IntNullableFilter<"CustomBlock"> | number | null
    version?: StringNullableFilter<"CustomBlock"> | string | null
    createdAt?: DateTimeNullableFilter<"CustomBlock"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CustomBlock"> | Date | string | null
    updatedBy?: StringNullableFilter<"CustomBlock"> | string | null
  }, "id">

  export type CustomBlockOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    blockType?: SortOrderInput | SortOrder
    category?: SortOrder
    code?: SortOrder
    logic?: SortOrder
    logicType?: SortOrder
    blockData?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    isPublic?: SortOrderInput | SortOrder
    isVerified?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    usageCount?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: CustomBlockCountOrderByAggregateInput
    _avg?: CustomBlockAvgOrderByAggregateInput
    _max?: CustomBlockMaxOrderByAggregateInput
    _min?: CustomBlockMinOrderByAggregateInput
    _sum?: CustomBlockSumOrderByAggregateInput
  }

  export type CustomBlockScalarWhereWithAggregatesInput = {
    AND?: CustomBlockScalarWhereWithAggregatesInput | CustomBlockScalarWhereWithAggregatesInput[]
    OR?: CustomBlockScalarWhereWithAggregatesInput[]
    NOT?: CustomBlockScalarWhereWithAggregatesInput | CustomBlockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomBlock"> | string
    userId?: StringWithAggregatesFilter<"CustomBlock"> | string
    name?: StringWithAggregatesFilter<"CustomBlock"> | string
    description?: StringNullableWithAggregatesFilter<"CustomBlock"> | string | null
    blockType?: StringNullableWithAggregatesFilter<"CustomBlock"> | string | null
    category?: StringWithAggregatesFilter<"CustomBlock"> | string
    code?: StringWithAggregatesFilter<"CustomBlock"> | string
    logic?: StringWithAggregatesFilter<"CustomBlock"> | string
    logicType?: StringWithAggregatesFilter<"CustomBlock"> | string
    blockData?: JsonNullableWithAggregatesFilter<"CustomBlock">
    tags?: JsonWithAggregatesFilter<"CustomBlock">
    createdBy?: StringNullableWithAggregatesFilter<"CustomBlock"> | string | null
    icon?: StringNullableWithAggregatesFilter<"CustomBlock"> | string | null
    isPublic?: BoolNullableWithAggregatesFilter<"CustomBlock"> | boolean | null
    isVerified?: BoolNullableWithAggregatesFilter<"CustomBlock"> | boolean | null
    rating?: FloatNullableWithAggregatesFilter<"CustomBlock"> | number | null
    usageCount?: IntNullableWithAggregatesFilter<"CustomBlock"> | number | null
    version?: StringNullableWithAggregatesFilter<"CustomBlock"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"CustomBlock"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"CustomBlock"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"CustomBlock"> | string | null
  }

  export type ExecutionQueueWhereInput = {
    AND?: ExecutionQueueWhereInput | ExecutionQueueWhereInput[]
    OR?: ExecutionQueueWhereInput[]
    NOT?: ExecutionQueueWhereInput | ExecutionQueueWhereInput[]
    id?: StringFilter<"ExecutionQueue"> | string
    workflowId?: StringFilter<"ExecutionQueue"> | string
    executionId?: StringFilter<"ExecutionQueue"> | string
    userId?: StringNullableFilter<"ExecutionQueue"> | string | null
    priority?: IntFilter<"ExecutionQueue"> | number
    status?: StringFilter<"ExecutionQueue"> | string
    payload?: JsonNullableFilter<"ExecutionQueue">
    error?: StringNullableFilter<"ExecutionQueue"> | string | null
    retryCount?: IntFilter<"ExecutionQueue"> | number
    maxRetries?: IntFilter<"ExecutionQueue"> | number
    lockedBy?: StringNullableFilter<"ExecutionQueue"> | string | null
    lockedUntil?: DateTimeNullableFilter<"ExecutionQueue"> | Date | string | null
    scheduledFor?: DateTimeFilter<"ExecutionQueue"> | Date | string
    createdAt?: DateTimeFilter<"ExecutionQueue"> | Date | string
    updatedAt?: DateTimeFilter<"ExecutionQueue"> | Date | string
  }

  export type ExecutionQueueOrderByWithRelationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    executionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    payload?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    lockedBy?: SortOrderInput | SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    scheduledFor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExecutionQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExecutionQueueWhereInput | ExecutionQueueWhereInput[]
    OR?: ExecutionQueueWhereInput[]
    NOT?: ExecutionQueueWhereInput | ExecutionQueueWhereInput[]
    workflowId?: StringFilter<"ExecutionQueue"> | string
    executionId?: StringFilter<"ExecutionQueue"> | string
    userId?: StringNullableFilter<"ExecutionQueue"> | string | null
    priority?: IntFilter<"ExecutionQueue"> | number
    status?: StringFilter<"ExecutionQueue"> | string
    payload?: JsonNullableFilter<"ExecutionQueue">
    error?: StringNullableFilter<"ExecutionQueue"> | string | null
    retryCount?: IntFilter<"ExecutionQueue"> | number
    maxRetries?: IntFilter<"ExecutionQueue"> | number
    lockedBy?: StringNullableFilter<"ExecutionQueue"> | string | null
    lockedUntil?: DateTimeNullableFilter<"ExecutionQueue"> | Date | string | null
    scheduledFor?: DateTimeFilter<"ExecutionQueue"> | Date | string
    createdAt?: DateTimeFilter<"ExecutionQueue"> | Date | string
    updatedAt?: DateTimeFilter<"ExecutionQueue"> | Date | string
  }, "id">

  export type ExecutionQueueOrderByWithAggregationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    executionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    payload?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    lockedBy?: SortOrderInput | SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    scheduledFor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExecutionQueueCountOrderByAggregateInput
    _avg?: ExecutionQueueAvgOrderByAggregateInput
    _max?: ExecutionQueueMaxOrderByAggregateInput
    _min?: ExecutionQueueMinOrderByAggregateInput
    _sum?: ExecutionQueueSumOrderByAggregateInput
  }

  export type ExecutionQueueScalarWhereWithAggregatesInput = {
    AND?: ExecutionQueueScalarWhereWithAggregatesInput | ExecutionQueueScalarWhereWithAggregatesInput[]
    OR?: ExecutionQueueScalarWhereWithAggregatesInput[]
    NOT?: ExecutionQueueScalarWhereWithAggregatesInput | ExecutionQueueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExecutionQueue"> | string
    workflowId?: StringWithAggregatesFilter<"ExecutionQueue"> | string
    executionId?: StringWithAggregatesFilter<"ExecutionQueue"> | string
    userId?: StringNullableWithAggregatesFilter<"ExecutionQueue"> | string | null
    priority?: IntWithAggregatesFilter<"ExecutionQueue"> | number
    status?: StringWithAggregatesFilter<"ExecutionQueue"> | string
    payload?: JsonNullableWithAggregatesFilter<"ExecutionQueue">
    error?: StringNullableWithAggregatesFilter<"ExecutionQueue"> | string | null
    retryCount?: IntWithAggregatesFilter<"ExecutionQueue"> | number
    maxRetries?: IntWithAggregatesFilter<"ExecutionQueue"> | number
    lockedBy?: StringNullableWithAggregatesFilter<"ExecutionQueue"> | string | null
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"ExecutionQueue"> | Date | string | null
    scheduledFor?: DateTimeWithAggregatesFilter<"ExecutionQueue"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ExecutionQueue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExecutionQueue"> | Date | string
  }

  export type ExecutionNodeStatusWhereInput = {
    AND?: ExecutionNodeStatusWhereInput | ExecutionNodeStatusWhereInput[]
    OR?: ExecutionNodeStatusWhereInput[]
    NOT?: ExecutionNodeStatusWhereInput | ExecutionNodeStatusWhereInput[]
    id?: StringFilter<"ExecutionNodeStatus"> | string
    nodeId?: StringFilter<"ExecutionNodeStatus"> | string
    status?: StringFilter<"ExecutionNodeStatus"> | string
    lastHeartbeat?: DateTimeFilter<"ExecutionNodeStatus"> | Date | string
    metadata?: JsonNullableFilter<"ExecutionNodeStatus">
  }

  export type ExecutionNodeStatusOrderByWithRelationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    metadata?: SortOrderInput | SortOrder
  }

  export type ExecutionNodeStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nodeId?: string
    AND?: ExecutionNodeStatusWhereInput | ExecutionNodeStatusWhereInput[]
    OR?: ExecutionNodeStatusWhereInput[]
    NOT?: ExecutionNodeStatusWhereInput | ExecutionNodeStatusWhereInput[]
    status?: StringFilter<"ExecutionNodeStatus"> | string
    lastHeartbeat?: DateTimeFilter<"ExecutionNodeStatus"> | Date | string
    metadata?: JsonNullableFilter<"ExecutionNodeStatus">
  }, "id" | "nodeId">

  export type ExecutionNodeStatusOrderByWithAggregationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: ExecutionNodeStatusCountOrderByAggregateInput
    _max?: ExecutionNodeStatusMaxOrderByAggregateInput
    _min?: ExecutionNodeStatusMinOrderByAggregateInput
  }

  export type ExecutionNodeStatusScalarWhereWithAggregatesInput = {
    AND?: ExecutionNodeStatusScalarWhereWithAggregatesInput | ExecutionNodeStatusScalarWhereWithAggregatesInput[]
    OR?: ExecutionNodeStatusScalarWhereWithAggregatesInput[]
    NOT?: ExecutionNodeStatusScalarWhereWithAggregatesInput | ExecutionNodeStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExecutionNodeStatus"> | string
    nodeId?: StringWithAggregatesFilter<"ExecutionNodeStatus"> | string
    status?: StringWithAggregatesFilter<"ExecutionNodeStatus"> | string
    lastHeartbeat?: DateTimeWithAggregatesFilter<"ExecutionNodeStatus"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"ExecutionNodeStatus">
  }

  export type CircuitBreakerStateWhereInput = {
    AND?: CircuitBreakerStateWhereInput | CircuitBreakerStateWhereInput[]
    OR?: CircuitBreakerStateWhereInput[]
    NOT?: CircuitBreakerStateWhereInput | CircuitBreakerStateWhereInput[]
    id?: StringFilter<"CircuitBreakerState"> | string
    circuitId?: StringFilter<"CircuitBreakerState"> | string
    state?: StringFilter<"CircuitBreakerState"> | string
    failureCount?: IntFilter<"CircuitBreakerState"> | number
    successCount?: IntFilter<"CircuitBreakerState"> | number
    lastFailureTime?: DateTimeNullableFilter<"CircuitBreakerState"> | Date | string | null
    lastSuccessTime?: DateTimeNullableFilter<"CircuitBreakerState"> | Date | string | null
    lastHalfOpenTime?: DateTimeNullableFilter<"CircuitBreakerState"> | Date | string | null
    createdAt?: DateTimeFilter<"CircuitBreakerState"> | Date | string
    updatedAt?: DateTimeFilter<"CircuitBreakerState"> | Date | string
  }

  export type CircuitBreakerStateOrderByWithRelationInput = {
    id?: SortOrder
    circuitId?: SortOrder
    state?: SortOrder
    failureCount?: SortOrder
    successCount?: SortOrder
    lastFailureTime?: SortOrderInput | SortOrder
    lastSuccessTime?: SortOrderInput | SortOrder
    lastHalfOpenTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CircuitBreakerStateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CircuitBreakerStateWhereInput | CircuitBreakerStateWhereInput[]
    OR?: CircuitBreakerStateWhereInput[]
    NOT?: CircuitBreakerStateWhereInput | CircuitBreakerStateWhereInput[]
    circuitId?: StringFilter<"CircuitBreakerState"> | string
    state?: StringFilter<"CircuitBreakerState"> | string
    failureCount?: IntFilter<"CircuitBreakerState"> | number
    successCount?: IntFilter<"CircuitBreakerState"> | number
    lastFailureTime?: DateTimeNullableFilter<"CircuitBreakerState"> | Date | string | null
    lastSuccessTime?: DateTimeNullableFilter<"CircuitBreakerState"> | Date | string | null
    lastHalfOpenTime?: DateTimeNullableFilter<"CircuitBreakerState"> | Date | string | null
    createdAt?: DateTimeFilter<"CircuitBreakerState"> | Date | string
    updatedAt?: DateTimeFilter<"CircuitBreakerState"> | Date | string
  }, "id">

  export type CircuitBreakerStateOrderByWithAggregationInput = {
    id?: SortOrder
    circuitId?: SortOrder
    state?: SortOrder
    failureCount?: SortOrder
    successCount?: SortOrder
    lastFailureTime?: SortOrderInput | SortOrder
    lastSuccessTime?: SortOrderInput | SortOrder
    lastHalfOpenTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CircuitBreakerStateCountOrderByAggregateInput
    _avg?: CircuitBreakerStateAvgOrderByAggregateInput
    _max?: CircuitBreakerStateMaxOrderByAggregateInput
    _min?: CircuitBreakerStateMinOrderByAggregateInput
    _sum?: CircuitBreakerStateSumOrderByAggregateInput
  }

  export type CircuitBreakerStateScalarWhereWithAggregatesInput = {
    AND?: CircuitBreakerStateScalarWhereWithAggregatesInput | CircuitBreakerStateScalarWhereWithAggregatesInput[]
    OR?: CircuitBreakerStateScalarWhereWithAggregatesInput[]
    NOT?: CircuitBreakerStateScalarWhereWithAggregatesInput | CircuitBreakerStateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CircuitBreakerState"> | string
    circuitId?: StringWithAggregatesFilter<"CircuitBreakerState"> | string
    state?: StringWithAggregatesFilter<"CircuitBreakerState"> | string
    failureCount?: IntWithAggregatesFilter<"CircuitBreakerState"> | number
    successCount?: IntWithAggregatesFilter<"CircuitBreakerState"> | number
    lastFailureTime?: DateTimeNullableWithAggregatesFilter<"CircuitBreakerState"> | Date | string | null
    lastSuccessTime?: DateTimeNullableWithAggregatesFilter<"CircuitBreakerState"> | Date | string | null
    lastHalfOpenTime?: DateTimeNullableWithAggregatesFilter<"CircuitBreakerState"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CircuitBreakerState"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CircuitBreakerState"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    data?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    id?: StringFilter<"NotificationPreference"> | string
    userId?: StringFilter<"NotificationPreference"> | string
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    pushEnabled?: BoolFilter<"NotificationPreference"> | boolean
    webhookEnabled?: BoolFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeNullableFilter<"NotificationPreference"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"NotificationPreference"> | Date | string | null
    telegramChatId?: StringNullableFilter<"NotificationPreference"> | string | null
    discordWebhookUrl?: StringNullableFilter<"NotificationPreference"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    pushEnabled?: SortOrder
    webhookEnabled?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    telegramChatId?: SortOrderInput | SortOrder
    discordWebhookUrl?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    pushEnabled?: BoolFilter<"NotificationPreference"> | boolean
    webhookEnabled?: BoolFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeNullableFilter<"NotificationPreference"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"NotificationPreference"> | Date | string | null
    telegramChatId?: StringNullableFilter<"NotificationPreference"> | string | null
    discordWebhookUrl?: StringNullableFilter<"NotificationPreference"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    pushEnabled?: SortOrder
    webhookEnabled?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    telegramChatId?: SortOrderInput | SortOrder
    discordWebhookUrl?: SortOrderInput | SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPreference"> | string
    userId?: StringWithAggregatesFilter<"NotificationPreference"> | string
    emailEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    pushEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    webhookEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"NotificationPreference"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"NotificationPreference"> | Date | string | null
    telegramChatId?: StringNullableWithAggregatesFilter<"NotificationPreference"> | string | null
    discordWebhookUrl?: StringNullableWithAggregatesFilter<"NotificationPreference"> | string | null
  }

  export type NotificationTemplateWhereInput = {
    AND?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    OR?: NotificationTemplateWhereInput[]
    NOT?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    id?: StringFilter<"NotificationTemplate"> | string
    type?: StringFilter<"NotificationTemplate"> | string
    title?: StringFilter<"NotificationTemplate"> | string
    message?: StringFilter<"NotificationTemplate"> | string
    createdAt?: DateTimeFilter<"NotificationTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationTemplate"> | Date | string
  }

  export type NotificationTemplateOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    type?: string
    AND?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    OR?: NotificationTemplateWhereInput[]
    NOT?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    title?: StringFilter<"NotificationTemplate"> | string
    message?: StringFilter<"NotificationTemplate"> | string
    createdAt?: DateTimeFilter<"NotificationTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationTemplate"> | Date | string
  }, "id" | "type">

  export type NotificationTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationTemplateCountOrderByAggregateInput
    _max?: NotificationTemplateMaxOrderByAggregateInput
    _min?: NotificationTemplateMinOrderByAggregateInput
  }

  export type NotificationTemplateScalarWhereWithAggregatesInput = {
    AND?: NotificationTemplateScalarWhereWithAggregatesInput | NotificationTemplateScalarWhereWithAggregatesInput[]
    OR?: NotificationTemplateScalarWhereWithAggregatesInput[]
    NOT?: NotificationTemplateScalarWhereWithAggregatesInput | NotificationTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    type?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    title?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    message?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NotificationTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationTemplate"> | Date | string
  }

  export type NotificationLogWhereInput = {
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    userId?: StringFilter<"NotificationLog"> | string
    channel?: StringFilter<"NotificationLog"> | string
    status?: StringFilter<"NotificationLog"> | string
    error?: StringNullableFilter<"NotificationLog"> | string | null
    notificationId?: StringNullableFilter<"NotificationLog"> | string | null
    createdAt?: DateTimeFilter<"NotificationLog"> | Date | string
  }

  export type NotificationLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    notificationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type NotificationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    userId?: StringFilter<"NotificationLog"> | string
    channel?: StringFilter<"NotificationLog"> | string
    status?: StringFilter<"NotificationLog"> | string
    error?: StringNullableFilter<"NotificationLog"> | string | null
    notificationId?: StringNullableFilter<"NotificationLog"> | string | null
    createdAt?: DateTimeFilter<"NotificationLog"> | Date | string
  }, "id">

  export type NotificationLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    notificationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationLogCountOrderByAggregateInput
    _max?: NotificationLogMaxOrderByAggregateInput
    _min?: NotificationLogMinOrderByAggregateInput
  }

  export type NotificationLogScalarWhereWithAggregatesInput = {
    AND?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    OR?: NotificationLogScalarWhereWithAggregatesInput[]
    NOT?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationLog"> | string
    userId?: StringWithAggregatesFilter<"NotificationLog"> | string
    channel?: StringWithAggregatesFilter<"NotificationLog"> | string
    status?: StringWithAggregatesFilter<"NotificationLog"> | string
    error?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    notificationId?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NotificationLog"> | Date | string
  }

  export type PricingTierWhereInput = {
    AND?: PricingTierWhereInput | PricingTierWhereInput[]
    OR?: PricingTierWhereInput[]
    NOT?: PricingTierWhereInput | PricingTierWhereInput[]
    id?: StringFilter<"PricingTier"> | string
    name?: StringFilter<"PricingTier"> | string
    description?: StringNullableFilter<"PricingTier"> | string | null
    priceMonthly?: DecimalFilter<"PricingTier"> | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFilter<"PricingTier"> | Decimal | DecimalJsLike | number | string
    workflowLimit?: IntFilter<"PricingTier"> | number
    executionLimit?: IntFilter<"PricingTier"> | number
    features?: JsonFilter<"PricingTier">
    createdAt?: DateTimeFilter<"PricingTier"> | Date | string
    updatedAt?: DateTimeFilter<"PricingTier"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }

  export type PricingTierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    workflowLimit?: SortOrder
    executionLimit?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptions?: SubscriptionOrderByRelationAggregateInput
  }

  export type PricingTierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PricingTierWhereInput | PricingTierWhereInput[]
    OR?: PricingTierWhereInput[]
    NOT?: PricingTierWhereInput | PricingTierWhereInput[]
    name?: StringFilter<"PricingTier"> | string
    description?: StringNullableFilter<"PricingTier"> | string | null
    priceMonthly?: DecimalFilter<"PricingTier"> | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFilter<"PricingTier"> | Decimal | DecimalJsLike | number | string
    workflowLimit?: IntFilter<"PricingTier"> | number
    executionLimit?: IntFilter<"PricingTier"> | number
    features?: JsonFilter<"PricingTier">
    createdAt?: DateTimeFilter<"PricingTier"> | Date | string
    updatedAt?: DateTimeFilter<"PricingTier"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }, "id">

  export type PricingTierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    workflowLimit?: SortOrder
    executionLimit?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PricingTierCountOrderByAggregateInput
    _avg?: PricingTierAvgOrderByAggregateInput
    _max?: PricingTierMaxOrderByAggregateInput
    _min?: PricingTierMinOrderByAggregateInput
    _sum?: PricingTierSumOrderByAggregateInput
  }

  export type PricingTierScalarWhereWithAggregatesInput = {
    AND?: PricingTierScalarWhereWithAggregatesInput | PricingTierScalarWhereWithAggregatesInput[]
    OR?: PricingTierScalarWhereWithAggregatesInput[]
    NOT?: PricingTierScalarWhereWithAggregatesInput | PricingTierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PricingTier"> | string
    name?: StringWithAggregatesFilter<"PricingTier"> | string
    description?: StringNullableWithAggregatesFilter<"PricingTier"> | string | null
    priceMonthly?: DecimalWithAggregatesFilter<"PricingTier"> | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalWithAggregatesFilter<"PricingTier"> | Decimal | DecimalJsLike | number | string
    workflowLimit?: IntWithAggregatesFilter<"PricingTier"> | number
    executionLimit?: IntWithAggregatesFilter<"PricingTier"> | number
    features?: JsonWithAggregatesFilter<"PricingTier">
    createdAt?: DateTimeWithAggregatesFilter<"PricingTier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PricingTier"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    tierId?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    stripePriceId?: StringNullableFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tier?: XOR<PricingTierRelationFilter, PricingTierWhereInput>
    invoices?: SubscriptionInvoiceListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tierId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tier?: PricingTierOrderByWithRelationInput
    invoices?: SubscriptionInvoiceOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    tierId?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    stripePriceId?: StringNullableFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tier?: XOR<PricingTierRelationFilter, PricingTierWhereInput>
    invoices?: SubscriptionInvoiceListRelationFilter
  }, "id" | "userId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tierId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    tierId?: StringWithAggregatesFilter<"Subscription"> | string
    status?: StringWithAggregatesFilter<"Subscription"> | string
    currentPeriodStart?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"Subscription"> | boolean
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripePriceId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    canceledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type SubscriptionInvoiceWhereInput = {
    AND?: SubscriptionInvoiceWhereInput | SubscriptionInvoiceWhereInput[]
    OR?: SubscriptionInvoiceWhereInput[]
    NOT?: SubscriptionInvoiceWhereInput | SubscriptionInvoiceWhereInput[]
    id?: StringFilter<"SubscriptionInvoice"> | string
    subscriptionId?: StringFilter<"SubscriptionInvoice"> | string
    stripeInvoiceId?: StringNullableFilter<"SubscriptionInvoice"> | string | null
    amount?: DecimalFilter<"SubscriptionInvoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"SubscriptionInvoice"> | string
    paidAt?: DateTimeNullableFilter<"SubscriptionInvoice"> | Date | string | null
    invoiceUrl?: StringNullableFilter<"SubscriptionInvoice"> | string | null
    createdAt?: DateTimeFilter<"SubscriptionInvoice"> | Date | string
    subscription?: XOR<SubscriptionRelationFilter, SubscriptionWhereInput>
  }

  export type SubscriptionInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    invoiceUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type SubscriptionInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionInvoiceWhereInput | SubscriptionInvoiceWhereInput[]
    OR?: SubscriptionInvoiceWhereInput[]
    NOT?: SubscriptionInvoiceWhereInput | SubscriptionInvoiceWhereInput[]
    subscriptionId?: StringFilter<"SubscriptionInvoice"> | string
    stripeInvoiceId?: StringNullableFilter<"SubscriptionInvoice"> | string | null
    amount?: DecimalFilter<"SubscriptionInvoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"SubscriptionInvoice"> | string
    paidAt?: DateTimeNullableFilter<"SubscriptionInvoice"> | Date | string | null
    invoiceUrl?: StringNullableFilter<"SubscriptionInvoice"> | string | null
    createdAt?: DateTimeFilter<"SubscriptionInvoice"> | Date | string
    subscription?: XOR<SubscriptionRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type SubscriptionInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    invoiceUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SubscriptionInvoiceCountOrderByAggregateInput
    _avg?: SubscriptionInvoiceAvgOrderByAggregateInput
    _max?: SubscriptionInvoiceMaxOrderByAggregateInput
    _min?: SubscriptionInvoiceMinOrderByAggregateInput
    _sum?: SubscriptionInvoiceSumOrderByAggregateInput
  }

  export type SubscriptionInvoiceScalarWhereWithAggregatesInput = {
    AND?: SubscriptionInvoiceScalarWhereWithAggregatesInput | SubscriptionInvoiceScalarWhereWithAggregatesInput[]
    OR?: SubscriptionInvoiceScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionInvoiceScalarWhereWithAggregatesInput | SubscriptionInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionInvoice"> | string
    subscriptionId?: StringWithAggregatesFilter<"SubscriptionInvoice"> | string
    stripeInvoiceId?: StringNullableWithAggregatesFilter<"SubscriptionInvoice"> | string | null
    amount?: DecimalWithAggregatesFilter<"SubscriptionInvoice"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"SubscriptionInvoice"> | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"SubscriptionInvoice"> | Date | string | null
    invoiceUrl?: StringNullableWithAggregatesFilter<"SubscriptionInvoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionInvoice"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    createdBy?: StringFilter<"Team"> | string
    createdAt?: DateTimeNullableFilter<"Team"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Team"> | Date | string | null
    owner?: XOR<UserRelationFilter, UserWhereInput>
    members?: TeamMemberListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    owner?: UserOrderByWithRelationInput
    members?: TeamMemberOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    createdBy?: StringFilter<"Team"> | string
    createdAt?: DateTimeNullableFilter<"Team"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Team"> | Date | string | null
    owner?: XOR<UserRelationFilter, UserWhereInput>
    members?: TeamMemberListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    description?: StringNullableWithAggregatesFilter<"Team"> | string | null
    createdBy?: StringWithAggregatesFilter<"Team"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Team"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Team"> | Date | string | null
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    role?: StringFilter<"TeamMember"> | string
    joinedAt?: DateTimeNullableFilter<"TeamMember"> | Date | string | null
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TeamMemberOrderByWithRelationInput = {
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    teamId_userId?: TeamMemberTeamIdUserIdCompoundUniqueInput
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    role?: StringFilter<"TeamMember"> | string
    joinedAt?: DateTimeNullableFilter<"TeamMember"> | Date | string | null
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "teamId_userId">

  export type TeamMemberOrderByWithAggregationInput = {
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    teamId?: StringWithAggregatesFilter<"TeamMember"> | string
    userId?: StringWithAggregatesFilter<"TeamMember"> | string
    role?: StringWithAggregatesFilter<"TeamMember"> | string
    joinedAt?: DateTimeNullableWithAggregatesFilter<"TeamMember"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type UsageLogWhereInput = {
    AND?: UsageLogWhereInput | UsageLogWhereInput[]
    OR?: UsageLogWhereInput[]
    NOT?: UsageLogWhereInput | UsageLogWhereInput[]
    id?: StringFilter<"UsageLog"> | string
    userId?: StringFilter<"UsageLog"> | string
    resourceType?: StringFilter<"UsageLog"> | string
    action?: StringFilter<"UsageLog"> | string
    quantity?: IntFilter<"UsageLog"> | number
    metadata?: JsonNullableFilter<"UsageLog">
    createdAt?: DateTimeFilter<"UsageLog"> | Date | string
  }

  export type UsageLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    resourceType?: SortOrder
    action?: SortOrder
    quantity?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type UsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsageLogWhereInput | UsageLogWhereInput[]
    OR?: UsageLogWhereInput[]
    NOT?: UsageLogWhereInput | UsageLogWhereInput[]
    userId?: StringFilter<"UsageLog"> | string
    resourceType?: StringFilter<"UsageLog"> | string
    action?: StringFilter<"UsageLog"> | string
    quantity?: IntFilter<"UsageLog"> | number
    metadata?: JsonNullableFilter<"UsageLog">
    createdAt?: DateTimeFilter<"UsageLog"> | Date | string
  }, "id">

  export type UsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    resourceType?: SortOrder
    action?: SortOrder
    quantity?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UsageLogCountOrderByAggregateInput
    _avg?: UsageLogAvgOrderByAggregateInput
    _max?: UsageLogMaxOrderByAggregateInput
    _min?: UsageLogMinOrderByAggregateInput
    _sum?: UsageLogSumOrderByAggregateInput
  }

  export type UsageLogScalarWhereWithAggregatesInput = {
    AND?: UsageLogScalarWhereWithAggregatesInput | UsageLogScalarWhereWithAggregatesInput[]
    OR?: UsageLogScalarWhereWithAggregatesInput[]
    NOT?: UsageLogScalarWhereWithAggregatesInput | UsageLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageLog"> | string
    userId?: StringWithAggregatesFilter<"UsageLog"> | string
    resourceType?: StringWithAggregatesFilter<"UsageLog"> | string
    action?: StringWithAggregatesFilter<"UsageLog"> | string
    quantity?: IntWithAggregatesFilter<"UsageLog"> | number
    metadata?: JsonNullableWithAggregatesFilter<"UsageLog">
    createdAt?: DateTimeWithAggregatesFilter<"UsageLog"> | Date | string
  }

  export type WalletTransactionWhereInput = {
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    id?: StringFilter<"WalletTransaction"> | string
    userId?: StringFilter<"WalletTransaction"> | string
    walletAddress?: StringFilter<"WalletTransaction"> | string
    txHash?: StringFilter<"WalletTransaction"> | string
    chainId?: IntFilter<"WalletTransaction"> | number
    value?: StringFilter<"WalletTransaction"> | string
    status?: StringFilter<"WalletTransaction"> | string
    blockNumber?: IntNullableFilter<"WalletTransaction"> | number | null
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"WalletTransaction"> | Date | string
  }

  export type WalletTransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    walletAddress?: SortOrder
    txHash?: SortOrder
    chainId?: SortOrder
    value?: SortOrder
    status?: SortOrder
    blockNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    userId?: StringFilter<"WalletTransaction"> | string
    walletAddress?: StringFilter<"WalletTransaction"> | string
    txHash?: StringFilter<"WalletTransaction"> | string
    chainId?: IntFilter<"WalletTransaction"> | number
    value?: StringFilter<"WalletTransaction"> | string
    status?: StringFilter<"WalletTransaction"> | string
    blockNumber?: IntNullableFilter<"WalletTransaction"> | number | null
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"WalletTransaction"> | Date | string
  }, "id">

  export type WalletTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    walletAddress?: SortOrder
    txHash?: SortOrder
    chainId?: SortOrder
    value?: SortOrder
    status?: SortOrder
    blockNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WalletTransactionCountOrderByAggregateInput
    _avg?: WalletTransactionAvgOrderByAggregateInput
    _max?: WalletTransactionMaxOrderByAggregateInput
    _min?: WalletTransactionMinOrderByAggregateInput
    _sum?: WalletTransactionSumOrderByAggregateInput
  }

  export type WalletTransactionScalarWhereWithAggregatesInput = {
    AND?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    OR?: WalletTransactionScalarWhereWithAggregatesInput[]
    NOT?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WalletTransaction"> | string
    userId?: StringWithAggregatesFilter<"WalletTransaction"> | string
    walletAddress?: StringWithAggregatesFilter<"WalletTransaction"> | string
    txHash?: StringWithAggregatesFilter<"WalletTransaction"> | string
    chainId?: IntWithAggregatesFilter<"WalletTransaction"> | number
    value?: StringWithAggregatesFilter<"WalletTransaction"> | string
    status?: StringWithAggregatesFilter<"WalletTransaction"> | string
    blockNumber?: IntNullableWithAggregatesFilter<"WalletTransaction"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"WalletTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WalletTransaction"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    userWallets?: UserWalletCreateNestedManyWithoutUserInput
    workflows?: WorkflowCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    ownedTeams?: TeamCreateNestedManyWithoutOwnerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    userWallets?: UserWalletUncheckedCreateNestedManyWithoutUserInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    ownedTeams?: TeamUncheckedCreateNestedManyWithoutOwnerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    userWallets?: UserWalletUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    ownedTeams?: TeamUpdateManyWithoutOwnerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    userWallets?: UserWalletUncheckedUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedTeams?: TeamUncheckedUpdateManyWithoutOwnerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    email?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    subscriptionTier?: string | null
    subscriptionStatus?: string | null
    subscriptionExpiresAt?: Date | string | null
    monthlyExecutionQuota?: number | null
    monthlyExecutionCount?: number | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    monthlyExecutionsUsed?: number
    telegramChatId?: string | null
    discordWebhookUrl?: string | null
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id: string
    email?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    subscriptionTier?: string | null
    subscriptionStatus?: string | null
    subscriptionExpiresAt?: Date | string | null
    monthlyExecutionQuota?: number | null
    monthlyExecutionCount?: number | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    monthlyExecutionsUsed?: number
    telegramChatId?: string | null
    discordWebhookUrl?: string | null
  }

  export type ProfileUpdateInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyExecutionQuota?: NullableIntFieldUpdateOperationsInput | number | null
    monthlyExecutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyExecutionsUsed?: IntFieldUpdateOperationsInput | number
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    discordWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyExecutionQuota?: NullableIntFieldUpdateOperationsInput | number | null
    monthlyExecutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyExecutionsUsed?: IntFieldUpdateOperationsInput | number
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    discordWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileCreateManyInput = {
    id: string
    email?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    subscriptionTier?: string | null
    subscriptionStatus?: string | null
    subscriptionExpiresAt?: Date | string | null
    monthlyExecutionQuota?: number | null
    monthlyExecutionCount?: number | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    monthlyExecutionsUsed?: number
    telegramChatId?: string | null
    discordWebhookUrl?: string | null
  }

  export type ProfileUpdateManyMutationInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyExecutionQuota?: NullableIntFieldUpdateOperationsInput | number | null
    monthlyExecutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyExecutionsUsed?: IntFieldUpdateOperationsInput | number
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    discordWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyExecutionQuota?: NullableIntFieldUpdateOperationsInput | number | null
    monthlyExecutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyExecutionsUsed?: IntFieldUpdateOperationsInput | number
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    discordWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserWalletCreateInput = {
    id?: string
    chainId: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walletType?: string | null
    chainType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutUserWalletsInput
  }

  export type UserWalletUncheckedCreateInput = {
    id?: string
    userId: string
    chainId: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walletType?: string | null
    chainType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserWalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walletType?: NullableStringFieldUpdateOperationsInput | string | null
    chainType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutUserWalletsNestedInput
  }

  export type UserWalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    chainId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walletType?: NullableStringFieldUpdateOperationsInput | string | null
    chainType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserWalletCreateManyInput = {
    id?: string
    userId: string
    chainId: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walletType?: string | null
    chainType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserWalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walletType?: NullableStringFieldUpdateOperationsInput | string | null
    chainType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserWalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    chainId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walletType?: NullableStringFieldUpdateOperationsInput | string | null
    chainType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type WorkflowTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type WorkflowTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type WorkflowTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowCreateInput = {
    id?: string
    name: string
    description?: string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean | null
    tags?: WorkflowCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: number
    createdBy?: string | null
    user: UserCreateNestedOneWithoutWorkflowsInput
    executions?: WorkflowExecutionCreateNestedManyWithoutWorkflowInput
    pauses?: WorkflowPauseCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean | null
    tags?: WorkflowCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: number
    createdBy?: string | null
    executions?: WorkflowExecutionUncheckedCreateNestedManyWithoutWorkflowInput
    pauses?: WorkflowPauseUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: WorkflowUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutWorkflowsNestedInput
    executions?: WorkflowExecutionUpdateManyWithoutWorkflowNestedInput
    pauses?: WorkflowPauseUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: WorkflowUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    executions?: WorkflowExecutionUncheckedUpdateManyWithoutWorkflowNestedInput
    pauses?: WorkflowPauseUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowCreateManyInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean | null
    tags?: WorkflowCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: number
    createdBy?: string | null
  }

  export type WorkflowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: WorkflowUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkflowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: WorkflowUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkflowExecutionCreateInput = {
    id?: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    workflow: WorkflowCreateNestedOneWithoutExecutionsInput
    user: UserCreateNestedOneWithoutWorkflowExecutionsInput
    nodeExecutions?: NodeExecutionCreateNestedManyWithoutExecutionInput
    executionLogs?: ExecutionLogCreateNestedManyWithoutExecutionInput
    blockExecutions?: BlockExecutionCreateNestedManyWithoutExecutionInput
    blockchainTransactions?: BlockchainTransactionCreateNestedManyWithoutExecutionInput
    workflowPauses?: WorkflowPauseCreateNestedManyWithoutExecutionInput
  }

  export type WorkflowExecutionUncheckedCreateInput = {
    id?: string
    workflowId: string
    userId: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    nodeExecutions?: NodeExecutionUncheckedCreateNestedManyWithoutExecutionInput
    executionLogs?: ExecutionLogUncheckedCreateNestedManyWithoutExecutionInput
    blockExecutions?: BlockExecutionUncheckedCreateNestedManyWithoutExecutionInput
    blockchainTransactions?: BlockchainTransactionUncheckedCreateNestedManyWithoutExecutionInput
    workflowPauses?: WorkflowPauseUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type WorkflowExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    workflow?: WorkflowUpdateOneRequiredWithoutExecutionsNestedInput
    user?: UserUpdateOneRequiredWithoutWorkflowExecutionsNestedInput
    nodeExecutions?: NodeExecutionUpdateManyWithoutExecutionNestedInput
    executionLogs?: ExecutionLogUpdateManyWithoutExecutionNestedInput
    blockExecutions?: BlockExecutionUpdateManyWithoutExecutionNestedInput
    blockchainTransactions?: BlockchainTransactionUpdateManyWithoutExecutionNestedInput
    workflowPauses?: WorkflowPauseUpdateManyWithoutExecutionNestedInput
  }

  export type WorkflowExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    nodeExecutions?: NodeExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    executionLogs?: ExecutionLogUncheckedUpdateManyWithoutExecutionNestedInput
    blockExecutions?: BlockExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    blockchainTransactions?: BlockchainTransactionUncheckedUpdateManyWithoutExecutionNestedInput
    workflowPauses?: WorkflowPauseUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type WorkflowExecutionCreateManyInput = {
    id?: string
    workflowId: string
    userId: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NodeExecutionCreateInput = {
    id?: string
    nodeId: string
    status: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string
    durationMs?: number | null
    updatedAt?: Date | string | null
    retryCount?: number | null
    finishedAt?: Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    execution: WorkflowExecutionCreateNestedOneWithoutNodeExecutionsInput
    logs?: NodeLogCreateNestedManyWithoutNodeExecutionInput
    nodeInputs?: NodeInputCreateNestedManyWithoutNodeExecutionInput
    nodeOutputs?: NodeOutputCreateNestedManyWithoutNodeExecutionInput
  }

  export type NodeExecutionUncheckedCreateInput = {
    id?: string
    executionId: string
    nodeId: string
    status: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string
    durationMs?: number | null
    updatedAt?: Date | string | null
    retryCount?: number | null
    finishedAt?: Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    logs?: NodeLogUncheckedCreateNestedManyWithoutNodeExecutionInput
    nodeInputs?: NodeInputUncheckedCreateNestedManyWithoutNodeExecutionInput
    nodeOutputs?: NodeOutputUncheckedCreateNestedManyWithoutNodeExecutionInput
  }

  export type NodeExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    execution?: WorkflowExecutionUpdateOneRequiredWithoutNodeExecutionsNestedInput
    logs?: NodeLogUpdateManyWithoutNodeExecutionNestedInput
    nodeInputs?: NodeInputUpdateManyWithoutNodeExecutionNestedInput
    nodeOutputs?: NodeOutputUpdateManyWithoutNodeExecutionNestedInput
  }

  export type NodeExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    logs?: NodeLogUncheckedUpdateManyWithoutNodeExecutionNestedInput
    nodeInputs?: NodeInputUncheckedUpdateManyWithoutNodeExecutionNestedInput
    nodeOutputs?: NodeOutputUncheckedUpdateManyWithoutNodeExecutionNestedInput
  }

  export type NodeExecutionCreateManyInput = {
    id?: string
    executionId: string
    nodeId: string
    status: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string
    durationMs?: number | null
    updatedAt?: Date | string | null
    retryCount?: number | null
    finishedAt?: Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NodeExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NodeExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NodeLogCreateInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nodeExecution: NodeExecutionCreateNestedOneWithoutLogsInput
  }

  export type NodeLogUncheckedCreateInput = {
    id?: string
    nodeExecutionId: string
    level: $Enums.LogLevel
    message: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NodeLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nodeExecution?: NodeExecutionUpdateOneRequiredWithoutLogsNestedInput
  }

  export type NodeLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeExecutionId?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NodeLogCreateManyInput = {
    id?: string
    nodeExecutionId: string
    level: $Enums.LogLevel
    message: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NodeLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NodeLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeExecutionId?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NodeInputCreateInput = {
    id?: string
    inputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    nodeExecution: NodeExecutionCreateNestedOneWithoutNodeInputsInput
  }

  export type NodeInputUncheckedCreateInput = {
    id?: string
    executionId: string
    nodeId: string
    inputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type NodeInputUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nodeExecution?: NodeExecutionUpdateOneRequiredWithoutNodeInputsNestedInput
  }

  export type NodeInputUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    inputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeInputCreateManyInput = {
    id?: string
    executionId: string
    nodeId: string
    inputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type NodeInputUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeInputUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    inputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeOutputCreateInput = {
    id?: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    nodeExecution: NodeExecutionCreateNestedOneWithoutNodeOutputsInput
  }

  export type NodeOutputUncheckedCreateInput = {
    id?: string
    executionId: string
    nodeId: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type NodeOutputUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nodeExecution?: NodeExecutionUpdateOneRequiredWithoutNodeOutputsNestedInput
  }

  export type NodeOutputUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeOutputCreateManyInput = {
    id?: string
    executionId: string
    nodeId: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type NodeOutputUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeOutputUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExecutionLogCreateInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    execution: WorkflowExecutionCreateNestedOneWithoutExecutionLogsInput
  }

  export type ExecutionLogUncheckedCreateInput = {
    id?: string
    executionId: string
    level: $Enums.LogLevel
    message: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    execution?: WorkflowExecutionUpdateOneRequiredWithoutExecutionLogsNestedInput
  }

  export type ExecutionLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionLogCreateManyInput = {
    id?: string
    executionId: string
    level: $Enums.LogLevel
    message: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowPauseCreateInput = {
    id?: string
    nodeId: string
    reason: string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: WorkflowCreateNestedOneWithoutPausesInput
    execution: WorkflowExecutionCreateNestedOneWithoutWorkflowPausesInput
  }

  export type WorkflowPauseUncheckedCreateInput = {
    id?: string
    workflowId: string
    executionId: string
    nodeId: string
    reason: string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowPauseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: WorkflowUpdateOneRequiredWithoutPausesNestedInput
    execution?: WorkflowExecutionUpdateOneRequiredWithoutWorkflowPausesNestedInput
  }

  export type WorkflowPauseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowPauseCreateManyInput = {
    id?: string
    workflowId: string
    executionId: string
    nodeId: string
    reason: string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowPauseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowPauseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockchainTransactionCreateInput = {
    id?: string
    nodeId: string
    toAddress: string
    value: string
    data?: NullableJsonNullValueInput | InputJsonValue
    chainId: number
    gasLimit?: string | null
    gasUsed?: string | null
    maxFeePerGas?: string | null
    maxPriorityFeePerGas?: string | null
    nonce?: number | null
    status: string
    hash?: string | null
    txHash?: string | null
    blockNumber?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    walletAddress: string
    effectiveGasPrice?: string | null
    error?: string | null
    fromAddress?: string | null
    execution: WorkflowExecutionCreateNestedOneWithoutBlockchainTransactionsInput
    transactionAttempts?: TransactionAttemptCreateNestedManyWithoutTransactionInput
  }

  export type BlockchainTransactionUncheckedCreateInput = {
    id?: string
    nodeId: string
    executionId: string
    toAddress: string
    value: string
    data?: NullableJsonNullValueInput | InputJsonValue
    chainId: number
    gasLimit?: string | null
    gasUsed?: string | null
    maxFeePerGas?: string | null
    maxPriorityFeePerGas?: string | null
    nonce?: number | null
    status: string
    hash?: string | null
    txHash?: string | null
    blockNumber?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    walletAddress: string
    effectiveGasPrice?: string | null
    error?: string | null
    fromAddress?: string | null
    transactionAttempts?: TransactionAttemptUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type BlockchainTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    chainId?: IntFieldUpdateOperationsInput | number
    gasLimit?: NullableStringFieldUpdateOperationsInput | string | null
    gasUsed?: NullableStringFieldUpdateOperationsInput | string | null
    maxFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    maxPriorityFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: StringFieldUpdateOperationsInput | string
    effectiveGasPrice?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: NullableStringFieldUpdateOperationsInput | string | null
    execution?: WorkflowExecutionUpdateOneRequiredWithoutBlockchainTransactionsNestedInput
    transactionAttempts?: TransactionAttemptUpdateManyWithoutTransactionNestedInput
  }

  export type BlockchainTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    chainId?: IntFieldUpdateOperationsInput | number
    gasLimit?: NullableStringFieldUpdateOperationsInput | string | null
    gasUsed?: NullableStringFieldUpdateOperationsInput | string | null
    maxFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    maxPriorityFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: StringFieldUpdateOperationsInput | string
    effectiveGasPrice?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: NullableStringFieldUpdateOperationsInput | string | null
    transactionAttempts?: TransactionAttemptUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type BlockchainTransactionCreateManyInput = {
    id?: string
    nodeId: string
    executionId: string
    toAddress: string
    value: string
    data?: NullableJsonNullValueInput | InputJsonValue
    chainId: number
    gasLimit?: string | null
    gasUsed?: string | null
    maxFeePerGas?: string | null
    maxPriorityFeePerGas?: string | null
    nonce?: number | null
    status: string
    hash?: string | null
    txHash?: string | null
    blockNumber?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    walletAddress: string
    effectiveGasPrice?: string | null
    error?: string | null
    fromAddress?: string | null
  }

  export type BlockchainTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    chainId?: IntFieldUpdateOperationsInput | number
    gasLimit?: NullableStringFieldUpdateOperationsInput | string | null
    gasUsed?: NullableStringFieldUpdateOperationsInput | string | null
    maxFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    maxPriorityFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: StringFieldUpdateOperationsInput | string
    effectiveGasPrice?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlockchainTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    chainId?: IntFieldUpdateOperationsInput | number
    gasLimit?: NullableStringFieldUpdateOperationsInput | string | null
    gasUsed?: NullableStringFieldUpdateOperationsInput | string | null
    maxFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    maxPriorityFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: StringFieldUpdateOperationsInput | string
    effectiveGasPrice?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionAttemptCreateInput = {
    id?: string
    txHash?: string | null
    status: string
    error?: string | null
    blockNumber?: number | null
    gasUsed?: string | null
    effectiveGasPrice?: string | null
    createdAt?: Date | string
    transaction: BlockchainTransactionCreateNestedOneWithoutTransactionAttemptsInput
  }

  export type TransactionAttemptUncheckedCreateInput = {
    id?: string
    transactionId: string
    txHash?: string | null
    status: string
    error?: string | null
    blockNumber?: number | null
    gasUsed?: string | null
    effectiveGasPrice?: string | null
    createdAt?: Date | string
  }

  export type TransactionAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    gasUsed?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveGasPrice?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: BlockchainTransactionUpdateOneRequiredWithoutTransactionAttemptsNestedInput
  }

  export type TransactionAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    gasUsed?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveGasPrice?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionAttemptCreateManyInput = {
    id?: string
    transactionId: string
    txHash?: string | null
    status: string
    error?: string | null
    blockNumber?: number | null
    gasUsed?: string | null
    effectiveGasPrice?: string | null
    createdAt?: Date | string
  }

  export type TransactionAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    gasUsed?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveGasPrice?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    gasUsed?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveGasPrice?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiBlockchainOperationCreateInput = {
    id?: string
    userId: string
    executionId: string
    nodeId: string
    operationType: string
    blockchain?: string | null
    prompt?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    status: string
    error?: string | null
    createdAt?: Date | string
  }

  export type AiBlockchainOperationUncheckedCreateInput = {
    id?: string
    userId: string
    executionId: string
    nodeId: string
    operationType: string
    blockchain?: string | null
    prompt?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    status: string
    error?: string | null
    createdAt?: Date | string
  }

  export type AiBlockchainOperationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiBlockchainOperationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiBlockchainOperationCreateManyInput = {
    id?: string
    userId: string
    executionId: string
    nodeId: string
    operationType: string
    blockchain?: string | null
    prompt?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    status: string
    error?: string | null
    createdAt?: Date | string
  }

  export type AiBlockchainOperationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiBlockchainOperationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockExecutionCreateInput = {
    id?: string
    nodeId: string
    blockType: string
    status: $Enums.BlockStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    execution: WorkflowExecutionCreateNestedOneWithoutBlockExecutionsInput
    logs?: BlockExecutionLogCreateNestedManyWithoutBlockExecutionInput
  }

  export type BlockExecutionUncheckedCreateInput = {
    id?: string
    executionId: string
    nodeId: string
    blockType: string
    status: $Enums.BlockStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    logs?: BlockExecutionLogUncheckedCreateNestedManyWithoutBlockExecutionInput
  }

  export type BlockExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    status?: EnumBlockStatusFieldUpdateOperationsInput | $Enums.BlockStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    execution?: WorkflowExecutionUpdateOneRequiredWithoutBlockExecutionsNestedInput
    logs?: BlockExecutionLogUpdateManyWithoutBlockExecutionNestedInput
  }

  export type BlockExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    status?: EnumBlockStatusFieldUpdateOperationsInput | $Enums.BlockStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: BlockExecutionLogUncheckedUpdateManyWithoutBlockExecutionNestedInput
  }

  export type BlockExecutionCreateManyInput = {
    id?: string
    executionId: string
    nodeId: string
    blockType: string
    status: $Enums.BlockStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startTime: Date | string
    endTime?: Date | string | null
  }

  export type BlockExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    status?: EnumBlockStatusFieldUpdateOperationsInput | $Enums.BlockStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlockExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    status?: EnumBlockStatusFieldUpdateOperationsInput | $Enums.BlockStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlockExecutionLogCreateInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    timestamp?: Date | string
    blockExecution: BlockExecutionCreateNestedOneWithoutLogsInput
  }

  export type BlockExecutionLogUncheckedCreateInput = {
    id?: string
    blockExecutionId: string
    level: $Enums.LogLevel
    message: string
    timestamp?: Date | string
  }

  export type BlockExecutionLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    blockExecution?: BlockExecutionUpdateOneRequiredWithoutLogsNestedInput
  }

  export type BlockExecutionLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockExecutionId?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockExecutionLogCreateManyInput = {
    id?: string
    blockExecutionId: string
    level: $Enums.LogLevel
    message: string
    timestamp?: Date | string
  }

  export type BlockExecutionLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockExecutionLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockExecutionId?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockLibraryCreateInput = {
    id?: string
    name: string
    description: string
    blockType: string
    category?: string | null
    configuration?: JsonNullValueInput | InputJsonValue
    blockData?: NullableJsonNullValueInput | InputJsonValue
    executionCode?: string | null
    userId: string
    isPublic?: boolean | null
    isVerified?: boolean | null
    rating?: number | null
    usageCount?: number | null
    tags?: BlockLibraryCreatetagsInput | string[]
    version?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ratings?: BlockLibraryRatingCreateNestedManyWithoutBlockInput
  }

  export type BlockLibraryUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    blockType: string
    category?: string | null
    configuration?: JsonNullValueInput | InputJsonValue
    blockData?: NullableJsonNullValueInput | InputJsonValue
    executionCode?: string | null
    userId: string
    isPublic?: boolean | null
    isVerified?: boolean | null
    rating?: number | null
    usageCount?: number | null
    tags?: BlockLibraryCreatetagsInput | string[]
    version?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ratings?: BlockLibraryRatingUncheckedCreateNestedManyWithoutBlockInput
  }

  export type BlockLibraryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    configuration?: JsonNullValueInput | InputJsonValue
    blockData?: NullableJsonNullValueInput | InputJsonValue
    executionCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    usageCount?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: BlockLibraryUpdatetagsInput | string[]
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratings?: BlockLibraryRatingUpdateManyWithoutBlockNestedInput
  }

  export type BlockLibraryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    configuration?: JsonNullValueInput | InputJsonValue
    blockData?: NullableJsonNullValueInput | InputJsonValue
    executionCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    usageCount?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: BlockLibraryUpdatetagsInput | string[]
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratings?: BlockLibraryRatingUncheckedUpdateManyWithoutBlockNestedInput
  }

  export type BlockLibraryCreateManyInput = {
    id?: string
    name: string
    description: string
    blockType: string
    category?: string | null
    configuration?: JsonNullValueInput | InputJsonValue
    blockData?: NullableJsonNullValueInput | InputJsonValue
    executionCode?: string | null
    userId: string
    isPublic?: boolean | null
    isVerified?: boolean | null
    rating?: number | null
    usageCount?: number | null
    tags?: BlockLibraryCreatetagsInput | string[]
    version?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BlockLibraryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    configuration?: JsonNullValueInput | InputJsonValue
    blockData?: NullableJsonNullValueInput | InputJsonValue
    executionCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    usageCount?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: BlockLibraryUpdatetagsInput | string[]
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlockLibraryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    configuration?: JsonNullValueInput | InputJsonValue
    blockData?: NullableJsonNullValueInput | InputJsonValue
    executionCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    usageCount?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: BlockLibraryUpdatetagsInput | string[]
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlockLibraryRatingCreateInput = {
    id?: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    block: BlockLibraryCreateNestedOneWithoutRatingsInput
  }

  export type BlockLibraryRatingUncheckedCreateInput = {
    id?: string
    blockId: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type BlockLibraryRatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: BlockLibraryUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type BlockLibraryRatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockLibraryRatingCreateManyInput = {
    id?: string
    blockId: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type BlockLibraryRatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockLibraryRatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomBlockCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    blockType?: string | null
    category: string
    code: string
    logic: string
    logicType: string
    blockData?: NullableJsonNullValueInput | InputJsonValue
    tags?: JsonNullValueInput | InputJsonValue
    createdBy?: string | null
    icon?: string | null
    isPublic?: boolean | null
    isVerified?: boolean | null
    rating?: number | null
    usageCount?: number | null
    version?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type CustomBlockUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    blockType?: string | null
    category: string
    code: string
    logic: string
    logicType: string
    blockData?: NullableJsonNullValueInput | InputJsonValue
    tags?: JsonNullValueInput | InputJsonValue
    createdBy?: string | null
    icon?: string | null
    isPublic?: boolean | null
    isVerified?: boolean | null
    rating?: number | null
    usageCount?: number | null
    version?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type CustomBlockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    blockType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logic?: StringFieldUpdateOperationsInput | string
    logicType?: StringFieldUpdateOperationsInput | string
    blockData?: NullableJsonNullValueInput | InputJsonValue
    tags?: JsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    usageCount?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomBlockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    blockType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logic?: StringFieldUpdateOperationsInput | string
    logicType?: StringFieldUpdateOperationsInput | string
    blockData?: NullableJsonNullValueInput | InputJsonValue
    tags?: JsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    usageCount?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomBlockCreateManyInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    blockType?: string | null
    category: string
    code: string
    logic: string
    logicType: string
    blockData?: NullableJsonNullValueInput | InputJsonValue
    tags?: JsonNullValueInput | InputJsonValue
    createdBy?: string | null
    icon?: string | null
    isPublic?: boolean | null
    isVerified?: boolean | null
    rating?: number | null
    usageCount?: number | null
    version?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type CustomBlockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    blockType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logic?: StringFieldUpdateOperationsInput | string
    logicType?: StringFieldUpdateOperationsInput | string
    blockData?: NullableJsonNullValueInput | InputJsonValue
    tags?: JsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    usageCount?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomBlockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    blockType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logic?: StringFieldUpdateOperationsInput | string
    logicType?: StringFieldUpdateOperationsInput | string
    blockData?: NullableJsonNullValueInput | InputJsonValue
    tags?: JsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    usageCount?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExecutionQueueCreateInput = {
    id?: string
    workflowId: string
    executionId: string
    userId?: string | null
    priority?: number
    status?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    retryCount?: number
    maxRetries?: number
    lockedBy?: string | null
    lockedUntil?: Date | string | null
    scheduledFor?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExecutionQueueUncheckedCreateInput = {
    id?: string
    workflowId: string
    executionId: string
    userId?: string | null
    priority?: number
    status?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    retryCount?: number
    maxRetries?: number
    lockedBy?: string | null
    lockedUntil?: Date | string | null
    scheduledFor?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExecutionQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutionQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutionQueueCreateManyInput = {
    id?: string
    workflowId: string
    executionId: string
    userId?: string | null
    priority?: number
    status?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    retryCount?: number
    maxRetries?: number
    lockedBy?: string | null
    lockedUntil?: Date | string | null
    scheduledFor?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExecutionQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutionQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutionNodeStatusCreateInput = {
    id?: string
    nodeId: string
    status?: string
    lastHeartbeat?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionNodeStatusUncheckedCreateInput = {
    id?: string
    nodeId: string
    status?: string
    lastHeartbeat?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionNodeStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionNodeStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionNodeStatusCreateManyInput = {
    id?: string
    nodeId: string
    status?: string
    lastHeartbeat?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionNodeStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionNodeStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CircuitBreakerStateCreateInput = {
    id?: string
    circuitId: string
    state?: string
    failureCount?: number
    successCount?: number
    lastFailureTime?: Date | string | null
    lastSuccessTime?: Date | string | null
    lastHalfOpenTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CircuitBreakerStateUncheckedCreateInput = {
    id?: string
    circuitId: string
    state?: string
    failureCount?: number
    successCount?: number
    lastFailureTime?: Date | string | null
    lastSuccessTime?: Date | string | null
    lastHalfOpenTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CircuitBreakerStateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    circuitId?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    failureCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    lastFailureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastHalfOpenTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CircuitBreakerStateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    circuitId?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    failureCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    lastFailureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastHalfOpenTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CircuitBreakerStateCreateManyInput = {
    id?: string
    circuitId: string
    state?: string
    failureCount?: number
    successCount?: number
    lastFailureTime?: Date | string | null
    lastSuccessTime?: Date | string | null
    lastHalfOpenTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CircuitBreakerStateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    circuitId?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    failureCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    lastFailureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastHalfOpenTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CircuitBreakerStateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    circuitId?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    failureCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    lastFailureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastHalfOpenTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: string
    read?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    read?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    read?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationPreferenceCreateInput = {
    id?: string
    emailEnabled?: boolean
    pushEnabled?: boolean
    webhookEnabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    telegramChatId?: string | null
    discordWebhookUrl?: string | null
    user: UserCreateNestedOneWithoutNotificationPreferencesInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    emailEnabled?: boolean
    pushEnabled?: boolean
    webhookEnabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    telegramChatId?: string | null
    discordWebhookUrl?: string | null
  }

  export type NotificationPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    webhookEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    discordWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutNotificationPreferencesNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    webhookEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    discordWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationPreferenceCreateManyInput = {
    id?: string
    userId: string
    emailEnabled?: boolean
    pushEnabled?: boolean
    webhookEnabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    telegramChatId?: string | null
    discordWebhookUrl?: string | null
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    webhookEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    discordWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    webhookEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    discordWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationTemplateCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationTemplateUncheckedCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTemplateCreateManyInput = {
    id?: string
    type: string
    title: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateInput = {
    id?: string
    userId: string
    channel: string
    status: string
    error?: string | null
    notificationId?: string | null
    createdAt?: Date | string
  }

  export type NotificationLogUncheckedCreateInput = {
    id?: string
    userId: string
    channel: string
    status: string
    error?: string | null
    notificationId?: string | null
    createdAt?: Date | string
  }

  export type NotificationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    notificationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    notificationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateManyInput = {
    id?: string
    userId: string
    channel: string
    status: string
    error?: string | null
    notificationId?: string | null
    createdAt?: Date | string
  }

  export type NotificationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    notificationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    notificationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingTierCreateInput = {
    id?: string
    name: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    workflowLimit: number
    executionLimit: number
    features?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutTierInput
  }

  export type PricingTierUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    workflowLimit: number
    executionLimit: number
    features?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTierInput
  }

  export type PricingTierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workflowLimit?: IntFieldUpdateOperationsInput | number
    executionLimit?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutTierNestedInput
  }

  export type PricingTierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workflowLimit?: IntFieldUpdateOperationsInput | number
    executionLimit?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTierNestedInput
  }

  export type PricingTierCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    workflowLimit: number
    executionLimit: number
    features?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricingTierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workflowLimit?: IntFieldUpdateOperationsInput | number
    executionLimit?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingTierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workflowLimit?: IntFieldUpdateOperationsInput | number
    executionLimit?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    stripeCustomerId?: string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
    tier: PricingTierCreateNestedOneWithoutSubscriptionsInput
    invoices?: SubscriptionInvoiceCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    tierId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    stripeCustomerId?: string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: SubscriptionInvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    tier?: PricingTierUpdateOneRequiredWithoutSubscriptionsNestedInput
    invoices?: SubscriptionInvoiceUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tierId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: SubscriptionInvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    tierId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    stripeCustomerId?: string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tierId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionInvoiceCreateInput = {
    id?: string
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: string
    paidAt?: Date | string | null
    invoiceUrl?: string | null
    createdAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutInvoicesInput
  }

  export type SubscriptionInvoiceUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: string
    paidAt?: Date | string | null
    invoiceUrl?: string | null
    createdAt?: Date | string
  }

  export type SubscriptionInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type SubscriptionInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionInvoiceCreateManyInput = {
    id?: string
    subscriptionId: string
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: string
    paidAt?: Date | string | null
    invoiceUrl?: string | null
    createdAt?: Date | string
  }

  export type SubscriptionInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    owner: UserCreateNestedOneWithoutOwnedTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdBy: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdBy: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMemberCreateInput = {
    role: string
    joinedAt?: Date | string | null
    team: TeamCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMemberUncheckedCreateInput = {
    teamId: string
    userId: string
    role: string
    joinedAt?: Date | string | null
  }

  export type TeamMemberUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMemberCreateManyInput = {
    teamId: string
    userId: string
    role: string
    joinedAt?: Date | string | null
  }

  export type TeamMemberUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    userId?: string | null
    action: string
    resource?: string | null
    resourceId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    resource?: string | null
    resourceId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    resource?: string | null
    resourceId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogCreateInput = {
    id?: string
    userId: string
    resourceType: string
    action: string
    quantity?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageLogUncheckedCreateInput = {
    id?: string
    userId: string
    resourceType: string
    action: string
    quantity?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogCreateManyInput = {
    id?: string
    userId: string
    resourceType: string
    action: string
    quantity?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateInput = {
    id?: string
    userId: string
    walletAddress: string
    txHash: string
    chainId: number
    value: string
    status: string
    blockNumber?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletTransactionUncheckedCreateInput = {
    id?: string
    userId: string
    walletAddress: string
    txHash: string
    chainId: number
    value: string
    status: string
    blockNumber?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateManyInput = {
    id?: string
    userId: string
    walletAddress: string
    txHash: string
    chainId: number
    value: string
    status: string
    blockNumber?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProfileNullableRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type UserWalletListRelationFilter = {
    every?: UserWalletWhereInput
    some?: UserWalletWhereInput
    none?: UserWalletWhereInput
  }

  export type WorkflowListRelationFilter = {
    every?: WorkflowWhereInput
    some?: WorkflowWhereInput
    none?: WorkflowWhereInput
  }

  export type WorkflowExecutionListRelationFilter = {
    every?: WorkflowExecutionWhereInput
    some?: WorkflowExecutionWhereInput
    none?: WorkflowExecutionWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SubscriptionNullableRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type NotificationPreferenceNullableRelationFilter = {
    is?: NotificationPreferenceWhereInput | null
    isNot?: NotificationPreferenceWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserWalletOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    avatarUrl?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionExpiresAt?: SortOrder
    monthlyExecutionQuota?: SortOrder
    monthlyExecutionCount?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSeenAt?: SortOrder
    monthlyExecutionsUsed?: SortOrder
    telegramChatId?: SortOrder
    discordWebhookUrl?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    monthlyExecutionQuota?: SortOrder
    monthlyExecutionCount?: SortOrder
    monthlyExecutionsUsed?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    avatarUrl?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionExpiresAt?: SortOrder
    monthlyExecutionQuota?: SortOrder
    monthlyExecutionCount?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSeenAt?: SortOrder
    monthlyExecutionsUsed?: SortOrder
    telegramChatId?: SortOrder
    discordWebhookUrl?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    avatarUrl?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionExpiresAt?: SortOrder
    monthlyExecutionQuota?: SortOrder
    monthlyExecutionCount?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSeenAt?: SortOrder
    monthlyExecutionsUsed?: SortOrder
    telegramChatId?: SortOrder
    discordWebhookUrl?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    monthlyExecutionQuota?: SortOrder
    monthlyExecutionCount?: SortOrder
    monthlyExecutionsUsed?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserWalletCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chainId?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    walletType?: SortOrder
    chainType?: SortOrder
    metadata?: SortOrder
  }

  export type UserWalletMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chainId?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    walletType?: SortOrder
    chainType?: SortOrder
  }

  export type UserWalletMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chainId?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    walletType?: SortOrder
    chainType?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type WorkflowTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    nodes?: SortOrder
    edges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type WorkflowPauseListRelationFilter = {
    every?: WorkflowPauseWhereInput
    some?: WorkflowPauseWhereInput
    none?: WorkflowPauseWhereInput
  }

  export type WorkflowPauseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    nodes?: SortOrder
    edges?: SortOrder
    isPublic?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    definition?: SortOrder
    version?: SortOrder
    createdBy?: SortOrder
  }

  export type WorkflowAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type WorkflowMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    createdBy?: SortOrder
  }

  export type WorkflowMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    createdBy?: SortOrder
  }

  export type WorkflowSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumWorkflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusFilter<$PrismaModel> | $Enums.WorkflowStatus
  }

  export type WorkflowRelationFilter = {
    is?: WorkflowWhereInput
    isNot?: WorkflowWhereInput
  }

  export type NodeExecutionListRelationFilter = {
    every?: NodeExecutionWhereInput
    some?: NodeExecutionWhereInput
    none?: NodeExecutionWhereInput
  }

  export type ExecutionLogListRelationFilter = {
    every?: ExecutionLogWhereInput
    some?: ExecutionLogWhereInput
    none?: ExecutionLogWhereInput
  }

  export type BlockExecutionListRelationFilter = {
    every?: BlockExecutionWhereInput
    some?: BlockExecutionWhereInput
    none?: BlockExecutionWhereInput
  }

  export type BlockchainTransactionListRelationFilter = {
    every?: BlockchainTransactionWhereInput
    some?: BlockchainTransactionWhereInput
    none?: BlockchainTransactionWhereInput
  }

  export type NodeExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExecutionLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockchainTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    input?: SortOrder
    output?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    error?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggerType?: SortOrder
    triggerData?: SortOrder
    lockedBy?: SortOrder
    logs?: SortOrder
  }

  export type WorkflowExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggerType?: SortOrder
    lockedBy?: SortOrder
  }

  export type WorkflowExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggerType?: SortOrder
    lockedBy?: SortOrder
  }

  export type EnumWorkflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStatusFilter<$PrismaModel>
  }

  export type WorkflowExecutionRelationFilter = {
    is?: WorkflowExecutionWhereInput
    isNot?: WorkflowExecutionWhereInput
  }

  export type NodeLogListRelationFilter = {
    every?: NodeLogWhereInput
    some?: NodeLogWhereInput
    none?: NodeLogWhereInput
  }

  export type NodeInputListRelationFilter = {
    every?: NodeInputWhereInput
    some?: NodeInputWhereInput
    none?: NodeInputWhereInput
  }

  export type NodeOutputListRelationFilter = {
    every?: NodeOutputWhereInput
    some?: NodeOutputWhereInput
    none?: NodeOutputWhereInput
  }

  export type NodeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NodeInputOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NodeOutputOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NodeExecutionExecutionIdNodeIdCompoundUniqueInput = {
    executionId: string
    nodeId: string
  }

  export type NodeExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    status?: SortOrder
    outputData?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationMs?: SortOrder
    updatedAt?: SortOrder
    retryCount?: SortOrder
    finishedAt?: SortOrder
    output?: SortOrder
  }

  export type NodeExecutionAvgOrderByAggregateInput = {
    durationMs?: SortOrder
    retryCount?: SortOrder
  }

  export type NodeExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    status?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationMs?: SortOrder
    updatedAt?: SortOrder
    retryCount?: SortOrder
    finishedAt?: SortOrder
  }

  export type NodeExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    status?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationMs?: SortOrder
    updatedAt?: SortOrder
    retryCount?: SortOrder
    finishedAt?: SortOrder
  }

  export type NodeExecutionSumOrderByAggregateInput = {
    durationMs?: SortOrder
    retryCount?: SortOrder
  }

  export type EnumLogLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelFilter<$PrismaModel> | $Enums.LogLevel
  }

  export type NodeExecutionRelationFilter = {
    is?: NodeExecutionWhereInput
    isNot?: NodeExecutionWhereInput
  }

  export type NodeLogCountOrderByAggregateInput = {
    id?: SortOrder
    nodeExecutionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
  }

  export type NodeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    nodeExecutionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type NodeLogMinOrderByAggregateInput = {
    id?: SortOrder
    nodeExecutionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumLogLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelWithAggregatesFilter<$PrismaModel> | $Enums.LogLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogLevelFilter<$PrismaModel>
    _max?: NestedEnumLogLevelFilter<$PrismaModel>
  }

  export type NodeInputCountOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    inputData?: SortOrder
    createdAt?: SortOrder
  }

  export type NodeInputMaxOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    createdAt?: SortOrder
  }

  export type NodeInputMinOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    createdAt?: SortOrder
  }

  export type NodeOutputCountOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    outputData?: SortOrder
    createdAt?: SortOrder
  }

  export type NodeOutputMaxOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    createdAt?: SortOrder
  }

  export type NodeOutputMinOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    createdAt?: SortOrder
  }

  export type ExecutionLogCountOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
  }

  export type ExecutionLogMaxOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
  }

  export type ExecutionLogMinOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
  }

  export type WorkflowPauseCountOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    reason?: SortOrder
    resumeData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowPauseMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowPauseMinOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAttemptListRelationFilter = {
    every?: TransactionAttemptWhereInput
    some?: TransactionAttemptWhereInput
    none?: TransactionAttemptWhereInput
  }

  export type TransactionAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockchainTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    executionId?: SortOrder
    toAddress?: SortOrder
    value?: SortOrder
    data?: SortOrder
    chainId?: SortOrder
    gasLimit?: SortOrder
    gasUsed?: SortOrder
    maxFeePerGas?: SortOrder
    maxPriorityFeePerGas?: SortOrder
    nonce?: SortOrder
    status?: SortOrder
    hash?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    walletAddress?: SortOrder
    effectiveGasPrice?: SortOrder
    error?: SortOrder
    fromAddress?: SortOrder
  }

  export type BlockchainTransactionAvgOrderByAggregateInput = {
    chainId?: SortOrder
    nonce?: SortOrder
    blockNumber?: SortOrder
  }

  export type BlockchainTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    executionId?: SortOrder
    toAddress?: SortOrder
    value?: SortOrder
    chainId?: SortOrder
    gasLimit?: SortOrder
    gasUsed?: SortOrder
    maxFeePerGas?: SortOrder
    maxPriorityFeePerGas?: SortOrder
    nonce?: SortOrder
    status?: SortOrder
    hash?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    walletAddress?: SortOrder
    effectiveGasPrice?: SortOrder
    error?: SortOrder
    fromAddress?: SortOrder
  }

  export type BlockchainTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    executionId?: SortOrder
    toAddress?: SortOrder
    value?: SortOrder
    chainId?: SortOrder
    gasLimit?: SortOrder
    gasUsed?: SortOrder
    maxFeePerGas?: SortOrder
    maxPriorityFeePerGas?: SortOrder
    nonce?: SortOrder
    status?: SortOrder
    hash?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    walletAddress?: SortOrder
    effectiveGasPrice?: SortOrder
    error?: SortOrder
    fromAddress?: SortOrder
  }

  export type BlockchainTransactionSumOrderByAggregateInput = {
    chainId?: SortOrder
    nonce?: SortOrder
    blockNumber?: SortOrder
  }

  export type BlockchainTransactionRelationFilter = {
    is?: BlockchainTransactionWhereInput
    isNot?: BlockchainTransactionWhereInput
  }

  export type TransactionAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    txHash?: SortOrder
    status?: SortOrder
    error?: SortOrder
    blockNumber?: SortOrder
    gasUsed?: SortOrder
    effectiveGasPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAttemptAvgOrderByAggregateInput = {
    blockNumber?: SortOrder
  }

  export type TransactionAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    txHash?: SortOrder
    status?: SortOrder
    error?: SortOrder
    blockNumber?: SortOrder
    gasUsed?: SortOrder
    effectiveGasPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    txHash?: SortOrder
    status?: SortOrder
    error?: SortOrder
    blockNumber?: SortOrder
    gasUsed?: SortOrder
    effectiveGasPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAttemptSumOrderByAggregateInput = {
    blockNumber?: SortOrder
  }

  export type AiBlockchainOperationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    operationType?: SortOrder
    blockchain?: SortOrder
    prompt?: SortOrder
    result?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type AiBlockchainOperationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    operationType?: SortOrder
    blockchain?: SortOrder
    prompt?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type AiBlockchainOperationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    operationType?: SortOrder
    blockchain?: SortOrder
    prompt?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumBlockStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BlockStatus | EnumBlockStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BlockStatus[] | ListEnumBlockStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlockStatus[] | ListEnumBlockStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBlockStatusFilter<$PrismaModel> | $Enums.BlockStatus
  }

  export type BlockExecutionLogListRelationFilter = {
    every?: BlockExecutionLogWhereInput
    some?: BlockExecutionLogWhereInput
    none?: BlockExecutionLogWhereInput
  }

  export type BlockExecutionLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    blockType?: SortOrder
    status?: SortOrder
    input?: SortOrder
    output?: SortOrder
    error?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type BlockExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    blockType?: SortOrder
    status?: SortOrder
    error?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type BlockExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    nodeId?: SortOrder
    blockType?: SortOrder
    status?: SortOrder
    error?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type EnumBlockStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BlockStatus | EnumBlockStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BlockStatus[] | ListEnumBlockStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlockStatus[] | ListEnumBlockStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBlockStatusWithAggregatesFilter<$PrismaModel> | $Enums.BlockStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBlockStatusFilter<$PrismaModel>
    _max?: NestedEnumBlockStatusFilter<$PrismaModel>
  }

  export type BlockExecutionRelationFilter = {
    is?: BlockExecutionWhereInput
    isNot?: BlockExecutionWhereInput
  }

  export type BlockExecutionLogCountOrderByAggregateInput = {
    id?: SortOrder
    blockExecutionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
  }

  export type BlockExecutionLogMaxOrderByAggregateInput = {
    id?: SortOrder
    blockExecutionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
  }

  export type BlockExecutionLogMinOrderByAggregateInput = {
    id?: SortOrder
    blockExecutionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BlockLibraryRatingListRelationFilter = {
    every?: BlockLibraryRatingWhereInput
    some?: BlockLibraryRatingWhereInput
    none?: BlockLibraryRatingWhereInput
  }

  export type BlockLibraryRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockLibraryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    blockType?: SortOrder
    category?: SortOrder
    configuration?: SortOrder
    blockData?: SortOrder
    executionCode?: SortOrder
    userId?: SortOrder
    isPublic?: SortOrder
    isVerified?: SortOrder
    rating?: SortOrder
    usageCount?: SortOrder
    tags?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockLibraryAvgOrderByAggregateInput = {
    rating?: SortOrder
    usageCount?: SortOrder
  }

  export type BlockLibraryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    blockType?: SortOrder
    category?: SortOrder
    executionCode?: SortOrder
    userId?: SortOrder
    isPublic?: SortOrder
    isVerified?: SortOrder
    rating?: SortOrder
    usageCount?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockLibraryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    blockType?: SortOrder
    category?: SortOrder
    executionCode?: SortOrder
    userId?: SortOrder
    isPublic?: SortOrder
    isVerified?: SortOrder
    rating?: SortOrder
    usageCount?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockLibrarySumOrderByAggregateInput = {
    rating?: SortOrder
    usageCount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BlockLibraryRelationFilter = {
    is?: BlockLibraryWhereInput
    isNot?: BlockLibraryWhereInput
  }

  export type BlockLibraryRatingBlockIdUserIdCompoundUniqueInput = {
    blockId: string
    userId: string
  }

  export type BlockLibraryRatingCountOrderByAggregateInput = {
    id?: SortOrder
    blockId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockLibraryRatingAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type BlockLibraryRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    blockId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockLibraryRatingMinOrderByAggregateInput = {
    id?: SortOrder
    blockId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockLibraryRatingSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type CustomBlockCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    blockType?: SortOrder
    category?: SortOrder
    code?: SortOrder
    logic?: SortOrder
    logicType?: SortOrder
    blockData?: SortOrder
    tags?: SortOrder
    createdBy?: SortOrder
    icon?: SortOrder
    isPublic?: SortOrder
    isVerified?: SortOrder
    rating?: SortOrder
    usageCount?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CustomBlockAvgOrderByAggregateInput = {
    rating?: SortOrder
    usageCount?: SortOrder
  }

  export type CustomBlockMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    blockType?: SortOrder
    category?: SortOrder
    code?: SortOrder
    logic?: SortOrder
    logicType?: SortOrder
    createdBy?: SortOrder
    icon?: SortOrder
    isPublic?: SortOrder
    isVerified?: SortOrder
    rating?: SortOrder
    usageCount?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CustomBlockMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    blockType?: SortOrder
    category?: SortOrder
    code?: SortOrder
    logic?: SortOrder
    logicType?: SortOrder
    createdBy?: SortOrder
    icon?: SortOrder
    isPublic?: SortOrder
    isVerified?: SortOrder
    rating?: SortOrder
    usageCount?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CustomBlockSumOrderByAggregateInput = {
    rating?: SortOrder
    usageCount?: SortOrder
  }

  export type ExecutionQueueCountOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    executionId?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    payload?: SortOrder
    error?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    lockedBy?: SortOrder
    lockedUntil?: SortOrder
    scheduledFor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExecutionQueueAvgOrderByAggregateInput = {
    priority?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
  }

  export type ExecutionQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    executionId?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    error?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    lockedBy?: SortOrder
    lockedUntil?: SortOrder
    scheduledFor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExecutionQueueMinOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    executionId?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    error?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    lockedBy?: SortOrder
    lockedUntil?: SortOrder
    scheduledFor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExecutionQueueSumOrderByAggregateInput = {
    priority?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
  }

  export type ExecutionNodeStatusCountOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    metadata?: SortOrder
  }

  export type ExecutionNodeStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
  }

  export type ExecutionNodeStatusMinOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
  }

  export type CircuitBreakerStateCountOrderByAggregateInput = {
    id?: SortOrder
    circuitId?: SortOrder
    state?: SortOrder
    failureCount?: SortOrder
    successCount?: SortOrder
    lastFailureTime?: SortOrder
    lastSuccessTime?: SortOrder
    lastHalfOpenTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CircuitBreakerStateAvgOrderByAggregateInput = {
    failureCount?: SortOrder
    successCount?: SortOrder
  }

  export type CircuitBreakerStateMaxOrderByAggregateInput = {
    id?: SortOrder
    circuitId?: SortOrder
    state?: SortOrder
    failureCount?: SortOrder
    successCount?: SortOrder
    lastFailureTime?: SortOrder
    lastSuccessTime?: SortOrder
    lastHalfOpenTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CircuitBreakerStateMinOrderByAggregateInput = {
    id?: SortOrder
    circuitId?: SortOrder
    state?: SortOrder
    failureCount?: SortOrder
    successCount?: SortOrder
    lastFailureTime?: SortOrder
    lastSuccessTime?: SortOrder
    lastHalfOpenTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CircuitBreakerStateSumOrderByAggregateInput = {
    failureCount?: SortOrder
    successCount?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    pushEnabled?: SortOrder
    webhookEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telegramChatId?: SortOrder
    discordWebhookUrl?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    pushEnabled?: SortOrder
    webhookEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telegramChatId?: SortOrder
    discordWebhookUrl?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    pushEnabled?: SortOrder
    webhookEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telegramChatId?: SortOrder
    discordWebhookUrl?: SortOrder
  }

  export type NotificationTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    error?: SortOrder
    notificationId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    error?: SortOrder
    notificationId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    error?: SortOrder
    notificationId?: SortOrder
    createdAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PricingTierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    workflowLimit?: SortOrder
    executionLimit?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PricingTierAvgOrderByAggregateInput = {
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    workflowLimit?: SortOrder
    executionLimit?: SortOrder
  }

  export type PricingTierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    workflowLimit?: SortOrder
    executionLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PricingTierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    workflowLimit?: SortOrder
    executionLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PricingTierSumOrderByAggregateInput = {
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    workflowLimit?: SortOrder
    executionLimit?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type PricingTierRelationFilter = {
    is?: PricingTierWhereInput
    isNot?: PricingTierWhereInput
  }

  export type SubscriptionInvoiceListRelationFilter = {
    every?: SubscriptionInvoiceWhereInput
    some?: SubscriptionInvoiceWhereInput
    none?: SubscriptionInvoiceWhereInput
  }

  export type SubscriptionInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tierId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    stripeCustomerId?: SortOrder
    canceledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tierId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    stripeCustomerId?: SortOrder
    canceledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tierId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    stripeCustomerId?: SortOrder
    canceledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type SubscriptionInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    invoiceUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionInvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SubscriptionInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    invoiceUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    invoiceUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionInvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type TeamMemberTeamIdUserIdCompoundUniqueInput = {
    teamId: string
    userId: string
  }

  export type TeamMemberCountOrderByAggregateInput = {
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resourceType?: SortOrder
    action?: SortOrder
    quantity?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageLogAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type UsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resourceType?: SortOrder
    action?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resourceType?: SortOrder
    action?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageLogSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type WalletTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    walletAddress?: SortOrder
    txHash?: SortOrder
    chainId?: SortOrder
    value?: SortOrder
    status?: SortOrder
    blockNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletTransactionAvgOrderByAggregateInput = {
    chainId?: SortOrder
    blockNumber?: SortOrder
  }

  export type WalletTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    walletAddress?: SortOrder
    txHash?: SortOrder
    chainId?: SortOrder
    value?: SortOrder
    status?: SortOrder
    blockNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    walletAddress?: SortOrder
    txHash?: SortOrder
    chainId?: SortOrder
    value?: SortOrder
    status?: SortOrder
    blockNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletTransactionSumOrderByAggregateInput = {
    chainId?: SortOrder
    blockNumber?: SortOrder
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type UserWalletCreateNestedManyWithoutUserInput = {
    create?: XOR<UserWalletCreateWithoutUserInput, UserWalletUncheckedCreateWithoutUserInput> | UserWalletCreateWithoutUserInput[] | UserWalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserWalletCreateOrConnectWithoutUserInput | UserWalletCreateOrConnectWithoutUserInput[]
    createMany?: UserWalletCreateManyUserInputEnvelope
    connect?: UserWalletWhereUniqueInput | UserWalletWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput> | WorkflowCreateWithoutUserInput[] | WorkflowUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutUserInput | WorkflowCreateOrConnectWithoutUserInput[]
    createMany?: WorkflowCreateManyUserInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type WorkflowExecutionCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkflowExecutionCreateWithoutUserInput, WorkflowExecutionUncheckedCreateWithoutUserInput> | WorkflowExecutionCreateWithoutUserInput[] | WorkflowExecutionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutUserInput | WorkflowExecutionCreateOrConnectWithoutUserInput[]
    createMany?: WorkflowExecutionCreateManyUserInputEnvelope
    connect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutOwnerInput = {
    create?: XOR<TeamCreateWithoutOwnerInput, TeamUncheckedCreateWithoutOwnerInput> | TeamCreateWithoutOwnerInput[] | TeamUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOwnerInput | TeamCreateOrConnectWithoutOwnerInput[]
    createMany?: TeamCreateManyOwnerInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type NotificationPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type UserWalletUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserWalletCreateWithoutUserInput, UserWalletUncheckedCreateWithoutUserInput> | UserWalletCreateWithoutUserInput[] | UserWalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserWalletCreateOrConnectWithoutUserInput | UserWalletCreateOrConnectWithoutUserInput[]
    createMany?: UserWalletCreateManyUserInputEnvelope
    connect?: UserWalletWhereUniqueInput | UserWalletWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput> | WorkflowCreateWithoutUserInput[] | WorkflowUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutUserInput | WorkflowCreateOrConnectWithoutUserInput[]
    createMany?: WorkflowCreateManyUserInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type WorkflowExecutionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkflowExecutionCreateWithoutUserInput, WorkflowExecutionUncheckedCreateWithoutUserInput> | WorkflowExecutionCreateWithoutUserInput[] | WorkflowExecutionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutUserInput | WorkflowExecutionCreateOrConnectWithoutUserInput[]
    createMany?: WorkflowExecutionCreateManyUserInputEnvelope
    connect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<TeamCreateWithoutOwnerInput, TeamUncheckedCreateWithoutOwnerInput> | TeamCreateWithoutOwnerInput[] | TeamUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOwnerInput | TeamCreateOrConnectWithoutOwnerInput[]
    createMany?: TeamCreateManyOwnerInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserWalletUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserWalletCreateWithoutUserInput, UserWalletUncheckedCreateWithoutUserInput> | UserWalletCreateWithoutUserInput[] | UserWalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserWalletCreateOrConnectWithoutUserInput | UserWalletCreateOrConnectWithoutUserInput[]
    upsert?: UserWalletUpsertWithWhereUniqueWithoutUserInput | UserWalletUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserWalletCreateManyUserInputEnvelope
    set?: UserWalletWhereUniqueInput | UserWalletWhereUniqueInput[]
    disconnect?: UserWalletWhereUniqueInput | UserWalletWhereUniqueInput[]
    delete?: UserWalletWhereUniqueInput | UserWalletWhereUniqueInput[]
    connect?: UserWalletWhereUniqueInput | UserWalletWhereUniqueInput[]
    update?: UserWalletUpdateWithWhereUniqueWithoutUserInput | UserWalletUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserWalletUpdateManyWithWhereWithoutUserInput | UserWalletUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserWalletScalarWhereInput | UserWalletScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput> | WorkflowCreateWithoutUserInput[] | WorkflowUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutUserInput | WorkflowCreateOrConnectWithoutUserInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutUserInput | WorkflowUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkflowCreateManyUserInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutUserInput | WorkflowUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutUserInput | WorkflowUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type WorkflowExecutionUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkflowExecutionCreateWithoutUserInput, WorkflowExecutionUncheckedCreateWithoutUserInput> | WorkflowExecutionCreateWithoutUserInput[] | WorkflowExecutionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutUserInput | WorkflowExecutionCreateOrConnectWithoutUserInput[]
    upsert?: WorkflowExecutionUpsertWithWhereUniqueWithoutUserInput | WorkflowExecutionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkflowExecutionCreateManyUserInputEnvelope
    set?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    disconnect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    delete?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    connect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    update?: WorkflowExecutionUpdateWithWhereUniqueWithoutUserInput | WorkflowExecutionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkflowExecutionUpdateManyWithWhereWithoutUserInput | WorkflowExecutionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkflowExecutionScalarWhereInput | WorkflowExecutionScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<TeamCreateWithoutOwnerInput, TeamUncheckedCreateWithoutOwnerInput> | TeamCreateWithoutOwnerInput[] | TeamUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOwnerInput | TeamCreateOrConnectWithoutOwnerInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutOwnerInput | TeamUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: TeamCreateManyOwnerInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutOwnerInput | TeamUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutOwnerInput | TeamUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type NotificationPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserWalletUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserWalletCreateWithoutUserInput, UserWalletUncheckedCreateWithoutUserInput> | UserWalletCreateWithoutUserInput[] | UserWalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserWalletCreateOrConnectWithoutUserInput | UserWalletCreateOrConnectWithoutUserInput[]
    upsert?: UserWalletUpsertWithWhereUniqueWithoutUserInput | UserWalletUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserWalletCreateManyUserInputEnvelope
    set?: UserWalletWhereUniqueInput | UserWalletWhereUniqueInput[]
    disconnect?: UserWalletWhereUniqueInput | UserWalletWhereUniqueInput[]
    delete?: UserWalletWhereUniqueInput | UserWalletWhereUniqueInput[]
    connect?: UserWalletWhereUniqueInput | UserWalletWhereUniqueInput[]
    update?: UserWalletUpdateWithWhereUniqueWithoutUserInput | UserWalletUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserWalletUpdateManyWithWhereWithoutUserInput | UserWalletUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserWalletScalarWhereInput | UserWalletScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput> | WorkflowCreateWithoutUserInput[] | WorkflowUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutUserInput | WorkflowCreateOrConnectWithoutUserInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutUserInput | WorkflowUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkflowCreateManyUserInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutUserInput | WorkflowUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutUserInput | WorkflowUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type WorkflowExecutionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkflowExecutionCreateWithoutUserInput, WorkflowExecutionUncheckedCreateWithoutUserInput> | WorkflowExecutionCreateWithoutUserInput[] | WorkflowExecutionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutUserInput | WorkflowExecutionCreateOrConnectWithoutUserInput[]
    upsert?: WorkflowExecutionUpsertWithWhereUniqueWithoutUserInput | WorkflowExecutionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkflowExecutionCreateManyUserInputEnvelope
    set?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    disconnect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    delete?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    connect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    update?: WorkflowExecutionUpdateWithWhereUniqueWithoutUserInput | WorkflowExecutionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkflowExecutionUpdateManyWithWhereWithoutUserInput | WorkflowExecutionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkflowExecutionScalarWhereInput | WorkflowExecutionScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<TeamCreateWithoutOwnerInput, TeamUncheckedCreateWithoutOwnerInput> | TeamCreateWithoutOwnerInput[] | TeamUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOwnerInput | TeamCreateOrConnectWithoutOwnerInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutOwnerInput | TeamUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: TeamCreateManyOwnerInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutOwnerInput | TeamUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutOwnerInput | TeamUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutUserWalletsInput = {
    create?: XOR<UserCreateWithoutUserWalletsInput, UserUncheckedCreateWithoutUserWalletsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserWalletsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserWalletsNestedInput = {
    create?: XOR<UserCreateWithoutUserWalletsInput, UserUncheckedCreateWithoutUserWalletsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserWalletsInput
    upsert?: UserUpsertWithoutUserWalletsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserWalletsInput, UserUpdateWithoutUserWalletsInput>, UserUncheckedUpdateWithoutUserWalletsInput>
  }

  export type WorkflowCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkflowExecutionCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowExecutionCreateWithoutWorkflowInput, WorkflowExecutionUncheckedCreateWithoutWorkflowInput> | WorkflowExecutionCreateWithoutWorkflowInput[] | WorkflowExecutionUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutWorkflowInput | WorkflowExecutionCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowExecutionCreateManyWorkflowInputEnvelope
    connect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
  }

  export type WorkflowPauseCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowPauseCreateWithoutWorkflowInput, WorkflowPauseUncheckedCreateWithoutWorkflowInput> | WorkflowPauseCreateWithoutWorkflowInput[] | WorkflowPauseUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowPauseCreateOrConnectWithoutWorkflowInput | WorkflowPauseCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowPauseCreateManyWorkflowInputEnvelope
    connect?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
  }

  export type WorkflowExecutionUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowExecutionCreateWithoutWorkflowInput, WorkflowExecutionUncheckedCreateWithoutWorkflowInput> | WorkflowExecutionCreateWithoutWorkflowInput[] | WorkflowExecutionUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutWorkflowInput | WorkflowExecutionCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowExecutionCreateManyWorkflowInputEnvelope
    connect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
  }

  export type WorkflowPauseUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowPauseCreateWithoutWorkflowInput, WorkflowPauseUncheckedCreateWithoutWorkflowInput> | WorkflowPauseCreateWithoutWorkflowInput[] | WorkflowPauseUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowPauseCreateOrConnectWithoutWorkflowInput | WorkflowPauseCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowPauseCreateManyWorkflowInputEnvelope
    connect?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type WorkflowUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutWorkflowsNestedInput = {
    create?: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowsInput
    upsert?: UserUpsertWithoutWorkflowsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkflowsInput, UserUpdateWithoutWorkflowsInput>, UserUncheckedUpdateWithoutWorkflowsInput>
  }

  export type WorkflowExecutionUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowExecutionCreateWithoutWorkflowInput, WorkflowExecutionUncheckedCreateWithoutWorkflowInput> | WorkflowExecutionCreateWithoutWorkflowInput[] | WorkflowExecutionUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutWorkflowInput | WorkflowExecutionCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowExecutionUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowExecutionUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowExecutionCreateManyWorkflowInputEnvelope
    set?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    disconnect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    delete?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    connect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    update?: WorkflowExecutionUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowExecutionUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowExecutionUpdateManyWithWhereWithoutWorkflowInput | WorkflowExecutionUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowExecutionScalarWhereInput | WorkflowExecutionScalarWhereInput[]
  }

  export type WorkflowPauseUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowPauseCreateWithoutWorkflowInput, WorkflowPauseUncheckedCreateWithoutWorkflowInput> | WorkflowPauseCreateWithoutWorkflowInput[] | WorkflowPauseUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowPauseCreateOrConnectWithoutWorkflowInput | WorkflowPauseCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowPauseUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowPauseUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowPauseCreateManyWorkflowInputEnvelope
    set?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
    disconnect?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
    delete?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
    connect?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
    update?: WorkflowPauseUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowPauseUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowPauseUpdateManyWithWhereWithoutWorkflowInput | WorkflowPauseUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowPauseScalarWhereInput | WorkflowPauseScalarWhereInput[]
  }

  export type WorkflowExecutionUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowExecutionCreateWithoutWorkflowInput, WorkflowExecutionUncheckedCreateWithoutWorkflowInput> | WorkflowExecutionCreateWithoutWorkflowInput[] | WorkflowExecutionUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutWorkflowInput | WorkflowExecutionCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowExecutionUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowExecutionUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowExecutionCreateManyWorkflowInputEnvelope
    set?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    disconnect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    delete?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    connect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    update?: WorkflowExecutionUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowExecutionUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowExecutionUpdateManyWithWhereWithoutWorkflowInput | WorkflowExecutionUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowExecutionScalarWhereInput | WorkflowExecutionScalarWhereInput[]
  }

  export type WorkflowPauseUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowPauseCreateWithoutWorkflowInput, WorkflowPauseUncheckedCreateWithoutWorkflowInput> | WorkflowPauseCreateWithoutWorkflowInput[] | WorkflowPauseUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowPauseCreateOrConnectWithoutWorkflowInput | WorkflowPauseCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowPauseUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowPauseUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowPauseCreateManyWorkflowInputEnvelope
    set?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
    disconnect?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
    delete?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
    connect?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
    update?: WorkflowPauseUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowPauseUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowPauseUpdateManyWithWhereWithoutWorkflowInput | WorkflowPauseUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowPauseScalarWhereInput | WorkflowPauseScalarWhereInput[]
  }

  export type WorkflowCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<WorkflowCreateWithoutExecutionsInput, WorkflowUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutExecutionsInput
    connect?: WorkflowWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWorkflowExecutionsInput = {
    create?: XOR<UserCreateWithoutWorkflowExecutionsInput, UserUncheckedCreateWithoutWorkflowExecutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowExecutionsInput
    connect?: UserWhereUniqueInput
  }

  export type NodeExecutionCreateNestedManyWithoutExecutionInput = {
    create?: XOR<NodeExecutionCreateWithoutExecutionInput, NodeExecutionUncheckedCreateWithoutExecutionInput> | NodeExecutionCreateWithoutExecutionInput[] | NodeExecutionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: NodeExecutionCreateOrConnectWithoutExecutionInput | NodeExecutionCreateOrConnectWithoutExecutionInput[]
    createMany?: NodeExecutionCreateManyExecutionInputEnvelope
    connect?: NodeExecutionWhereUniqueInput | NodeExecutionWhereUniqueInput[]
  }

  export type ExecutionLogCreateNestedManyWithoutExecutionInput = {
    create?: XOR<ExecutionLogCreateWithoutExecutionInput, ExecutionLogUncheckedCreateWithoutExecutionInput> | ExecutionLogCreateWithoutExecutionInput[] | ExecutionLogUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: ExecutionLogCreateOrConnectWithoutExecutionInput | ExecutionLogCreateOrConnectWithoutExecutionInput[]
    createMany?: ExecutionLogCreateManyExecutionInputEnvelope
    connect?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
  }

  export type BlockExecutionCreateNestedManyWithoutExecutionInput = {
    create?: XOR<BlockExecutionCreateWithoutExecutionInput, BlockExecutionUncheckedCreateWithoutExecutionInput> | BlockExecutionCreateWithoutExecutionInput[] | BlockExecutionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: BlockExecutionCreateOrConnectWithoutExecutionInput | BlockExecutionCreateOrConnectWithoutExecutionInput[]
    createMany?: BlockExecutionCreateManyExecutionInputEnvelope
    connect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
  }

  export type BlockchainTransactionCreateNestedManyWithoutExecutionInput = {
    create?: XOR<BlockchainTransactionCreateWithoutExecutionInput, BlockchainTransactionUncheckedCreateWithoutExecutionInput> | BlockchainTransactionCreateWithoutExecutionInput[] | BlockchainTransactionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: BlockchainTransactionCreateOrConnectWithoutExecutionInput | BlockchainTransactionCreateOrConnectWithoutExecutionInput[]
    createMany?: BlockchainTransactionCreateManyExecutionInputEnvelope
    connect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
  }

  export type WorkflowPauseCreateNestedManyWithoutExecutionInput = {
    create?: XOR<WorkflowPauseCreateWithoutExecutionInput, WorkflowPauseUncheckedCreateWithoutExecutionInput> | WorkflowPauseCreateWithoutExecutionInput[] | WorkflowPauseUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: WorkflowPauseCreateOrConnectWithoutExecutionInput | WorkflowPauseCreateOrConnectWithoutExecutionInput[]
    createMany?: WorkflowPauseCreateManyExecutionInputEnvelope
    connect?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
  }

  export type NodeExecutionUncheckedCreateNestedManyWithoutExecutionInput = {
    create?: XOR<NodeExecutionCreateWithoutExecutionInput, NodeExecutionUncheckedCreateWithoutExecutionInput> | NodeExecutionCreateWithoutExecutionInput[] | NodeExecutionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: NodeExecutionCreateOrConnectWithoutExecutionInput | NodeExecutionCreateOrConnectWithoutExecutionInput[]
    createMany?: NodeExecutionCreateManyExecutionInputEnvelope
    connect?: NodeExecutionWhereUniqueInput | NodeExecutionWhereUniqueInput[]
  }

  export type ExecutionLogUncheckedCreateNestedManyWithoutExecutionInput = {
    create?: XOR<ExecutionLogCreateWithoutExecutionInput, ExecutionLogUncheckedCreateWithoutExecutionInput> | ExecutionLogCreateWithoutExecutionInput[] | ExecutionLogUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: ExecutionLogCreateOrConnectWithoutExecutionInput | ExecutionLogCreateOrConnectWithoutExecutionInput[]
    createMany?: ExecutionLogCreateManyExecutionInputEnvelope
    connect?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
  }

  export type BlockExecutionUncheckedCreateNestedManyWithoutExecutionInput = {
    create?: XOR<BlockExecutionCreateWithoutExecutionInput, BlockExecutionUncheckedCreateWithoutExecutionInput> | BlockExecutionCreateWithoutExecutionInput[] | BlockExecutionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: BlockExecutionCreateOrConnectWithoutExecutionInput | BlockExecutionCreateOrConnectWithoutExecutionInput[]
    createMany?: BlockExecutionCreateManyExecutionInputEnvelope
    connect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
  }

  export type BlockchainTransactionUncheckedCreateNestedManyWithoutExecutionInput = {
    create?: XOR<BlockchainTransactionCreateWithoutExecutionInput, BlockchainTransactionUncheckedCreateWithoutExecutionInput> | BlockchainTransactionCreateWithoutExecutionInput[] | BlockchainTransactionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: BlockchainTransactionCreateOrConnectWithoutExecutionInput | BlockchainTransactionCreateOrConnectWithoutExecutionInput[]
    createMany?: BlockchainTransactionCreateManyExecutionInputEnvelope
    connect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
  }

  export type WorkflowPauseUncheckedCreateNestedManyWithoutExecutionInput = {
    create?: XOR<WorkflowPauseCreateWithoutExecutionInput, WorkflowPauseUncheckedCreateWithoutExecutionInput> | WorkflowPauseCreateWithoutExecutionInput[] | WorkflowPauseUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: WorkflowPauseCreateOrConnectWithoutExecutionInput | WorkflowPauseCreateOrConnectWithoutExecutionInput[]
    createMany?: WorkflowPauseCreateManyExecutionInputEnvelope
    connect?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
  }

  export type EnumWorkflowStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkflowStatus
  }

  export type WorkflowUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<WorkflowCreateWithoutExecutionsInput, WorkflowUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutExecutionsInput
    upsert?: WorkflowUpsertWithoutExecutionsInput
    connect?: WorkflowWhereUniqueInput
    update?: XOR<XOR<WorkflowUpdateToOneWithWhereWithoutExecutionsInput, WorkflowUpdateWithoutExecutionsInput>, WorkflowUncheckedUpdateWithoutExecutionsInput>
  }

  export type UserUpdateOneRequiredWithoutWorkflowExecutionsNestedInput = {
    create?: XOR<UserCreateWithoutWorkflowExecutionsInput, UserUncheckedCreateWithoutWorkflowExecutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowExecutionsInput
    upsert?: UserUpsertWithoutWorkflowExecutionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkflowExecutionsInput, UserUpdateWithoutWorkflowExecutionsInput>, UserUncheckedUpdateWithoutWorkflowExecutionsInput>
  }

  export type NodeExecutionUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<NodeExecutionCreateWithoutExecutionInput, NodeExecutionUncheckedCreateWithoutExecutionInput> | NodeExecutionCreateWithoutExecutionInput[] | NodeExecutionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: NodeExecutionCreateOrConnectWithoutExecutionInput | NodeExecutionCreateOrConnectWithoutExecutionInput[]
    upsert?: NodeExecutionUpsertWithWhereUniqueWithoutExecutionInput | NodeExecutionUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: NodeExecutionCreateManyExecutionInputEnvelope
    set?: NodeExecutionWhereUniqueInput | NodeExecutionWhereUniqueInput[]
    disconnect?: NodeExecutionWhereUniqueInput | NodeExecutionWhereUniqueInput[]
    delete?: NodeExecutionWhereUniqueInput | NodeExecutionWhereUniqueInput[]
    connect?: NodeExecutionWhereUniqueInput | NodeExecutionWhereUniqueInput[]
    update?: NodeExecutionUpdateWithWhereUniqueWithoutExecutionInput | NodeExecutionUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: NodeExecutionUpdateManyWithWhereWithoutExecutionInput | NodeExecutionUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: NodeExecutionScalarWhereInput | NodeExecutionScalarWhereInput[]
  }

  export type ExecutionLogUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<ExecutionLogCreateWithoutExecutionInput, ExecutionLogUncheckedCreateWithoutExecutionInput> | ExecutionLogCreateWithoutExecutionInput[] | ExecutionLogUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: ExecutionLogCreateOrConnectWithoutExecutionInput | ExecutionLogCreateOrConnectWithoutExecutionInput[]
    upsert?: ExecutionLogUpsertWithWhereUniqueWithoutExecutionInput | ExecutionLogUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: ExecutionLogCreateManyExecutionInputEnvelope
    set?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
    disconnect?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
    delete?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
    connect?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
    update?: ExecutionLogUpdateWithWhereUniqueWithoutExecutionInput | ExecutionLogUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: ExecutionLogUpdateManyWithWhereWithoutExecutionInput | ExecutionLogUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: ExecutionLogScalarWhereInput | ExecutionLogScalarWhereInput[]
  }

  export type BlockExecutionUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<BlockExecutionCreateWithoutExecutionInput, BlockExecutionUncheckedCreateWithoutExecutionInput> | BlockExecutionCreateWithoutExecutionInput[] | BlockExecutionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: BlockExecutionCreateOrConnectWithoutExecutionInput | BlockExecutionCreateOrConnectWithoutExecutionInput[]
    upsert?: BlockExecutionUpsertWithWhereUniqueWithoutExecutionInput | BlockExecutionUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: BlockExecutionCreateManyExecutionInputEnvelope
    set?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    disconnect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    delete?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    connect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    update?: BlockExecutionUpdateWithWhereUniqueWithoutExecutionInput | BlockExecutionUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: BlockExecutionUpdateManyWithWhereWithoutExecutionInput | BlockExecutionUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: BlockExecutionScalarWhereInput | BlockExecutionScalarWhereInput[]
  }

  export type BlockchainTransactionUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<BlockchainTransactionCreateWithoutExecutionInput, BlockchainTransactionUncheckedCreateWithoutExecutionInput> | BlockchainTransactionCreateWithoutExecutionInput[] | BlockchainTransactionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: BlockchainTransactionCreateOrConnectWithoutExecutionInput | BlockchainTransactionCreateOrConnectWithoutExecutionInput[]
    upsert?: BlockchainTransactionUpsertWithWhereUniqueWithoutExecutionInput | BlockchainTransactionUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: BlockchainTransactionCreateManyExecutionInputEnvelope
    set?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    disconnect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    delete?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    connect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    update?: BlockchainTransactionUpdateWithWhereUniqueWithoutExecutionInput | BlockchainTransactionUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: BlockchainTransactionUpdateManyWithWhereWithoutExecutionInput | BlockchainTransactionUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: BlockchainTransactionScalarWhereInput | BlockchainTransactionScalarWhereInput[]
  }

  export type WorkflowPauseUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<WorkflowPauseCreateWithoutExecutionInput, WorkflowPauseUncheckedCreateWithoutExecutionInput> | WorkflowPauseCreateWithoutExecutionInput[] | WorkflowPauseUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: WorkflowPauseCreateOrConnectWithoutExecutionInput | WorkflowPauseCreateOrConnectWithoutExecutionInput[]
    upsert?: WorkflowPauseUpsertWithWhereUniqueWithoutExecutionInput | WorkflowPauseUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: WorkflowPauseCreateManyExecutionInputEnvelope
    set?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
    disconnect?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
    delete?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
    connect?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
    update?: WorkflowPauseUpdateWithWhereUniqueWithoutExecutionInput | WorkflowPauseUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: WorkflowPauseUpdateManyWithWhereWithoutExecutionInput | WorkflowPauseUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: WorkflowPauseScalarWhereInput | WorkflowPauseScalarWhereInput[]
  }

  export type NodeExecutionUncheckedUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<NodeExecutionCreateWithoutExecutionInput, NodeExecutionUncheckedCreateWithoutExecutionInput> | NodeExecutionCreateWithoutExecutionInput[] | NodeExecutionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: NodeExecutionCreateOrConnectWithoutExecutionInput | NodeExecutionCreateOrConnectWithoutExecutionInput[]
    upsert?: NodeExecutionUpsertWithWhereUniqueWithoutExecutionInput | NodeExecutionUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: NodeExecutionCreateManyExecutionInputEnvelope
    set?: NodeExecutionWhereUniqueInput | NodeExecutionWhereUniqueInput[]
    disconnect?: NodeExecutionWhereUniqueInput | NodeExecutionWhereUniqueInput[]
    delete?: NodeExecutionWhereUniqueInput | NodeExecutionWhereUniqueInput[]
    connect?: NodeExecutionWhereUniqueInput | NodeExecutionWhereUniqueInput[]
    update?: NodeExecutionUpdateWithWhereUniqueWithoutExecutionInput | NodeExecutionUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: NodeExecutionUpdateManyWithWhereWithoutExecutionInput | NodeExecutionUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: NodeExecutionScalarWhereInput | NodeExecutionScalarWhereInput[]
  }

  export type ExecutionLogUncheckedUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<ExecutionLogCreateWithoutExecutionInput, ExecutionLogUncheckedCreateWithoutExecutionInput> | ExecutionLogCreateWithoutExecutionInput[] | ExecutionLogUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: ExecutionLogCreateOrConnectWithoutExecutionInput | ExecutionLogCreateOrConnectWithoutExecutionInput[]
    upsert?: ExecutionLogUpsertWithWhereUniqueWithoutExecutionInput | ExecutionLogUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: ExecutionLogCreateManyExecutionInputEnvelope
    set?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
    disconnect?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
    delete?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
    connect?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
    update?: ExecutionLogUpdateWithWhereUniqueWithoutExecutionInput | ExecutionLogUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: ExecutionLogUpdateManyWithWhereWithoutExecutionInput | ExecutionLogUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: ExecutionLogScalarWhereInput | ExecutionLogScalarWhereInput[]
  }

  export type BlockExecutionUncheckedUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<BlockExecutionCreateWithoutExecutionInput, BlockExecutionUncheckedCreateWithoutExecutionInput> | BlockExecutionCreateWithoutExecutionInput[] | BlockExecutionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: BlockExecutionCreateOrConnectWithoutExecutionInput | BlockExecutionCreateOrConnectWithoutExecutionInput[]
    upsert?: BlockExecutionUpsertWithWhereUniqueWithoutExecutionInput | BlockExecutionUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: BlockExecutionCreateManyExecutionInputEnvelope
    set?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    disconnect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    delete?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    connect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    update?: BlockExecutionUpdateWithWhereUniqueWithoutExecutionInput | BlockExecutionUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: BlockExecutionUpdateManyWithWhereWithoutExecutionInput | BlockExecutionUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: BlockExecutionScalarWhereInput | BlockExecutionScalarWhereInput[]
  }

  export type BlockchainTransactionUncheckedUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<BlockchainTransactionCreateWithoutExecutionInput, BlockchainTransactionUncheckedCreateWithoutExecutionInput> | BlockchainTransactionCreateWithoutExecutionInput[] | BlockchainTransactionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: BlockchainTransactionCreateOrConnectWithoutExecutionInput | BlockchainTransactionCreateOrConnectWithoutExecutionInput[]
    upsert?: BlockchainTransactionUpsertWithWhereUniqueWithoutExecutionInput | BlockchainTransactionUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: BlockchainTransactionCreateManyExecutionInputEnvelope
    set?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    disconnect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    delete?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    connect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    update?: BlockchainTransactionUpdateWithWhereUniqueWithoutExecutionInput | BlockchainTransactionUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: BlockchainTransactionUpdateManyWithWhereWithoutExecutionInput | BlockchainTransactionUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: BlockchainTransactionScalarWhereInput | BlockchainTransactionScalarWhereInput[]
  }

  export type WorkflowPauseUncheckedUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<WorkflowPauseCreateWithoutExecutionInput, WorkflowPauseUncheckedCreateWithoutExecutionInput> | WorkflowPauseCreateWithoutExecutionInput[] | WorkflowPauseUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: WorkflowPauseCreateOrConnectWithoutExecutionInput | WorkflowPauseCreateOrConnectWithoutExecutionInput[]
    upsert?: WorkflowPauseUpsertWithWhereUniqueWithoutExecutionInput | WorkflowPauseUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: WorkflowPauseCreateManyExecutionInputEnvelope
    set?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
    disconnect?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
    delete?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
    connect?: WorkflowPauseWhereUniqueInput | WorkflowPauseWhereUniqueInput[]
    update?: WorkflowPauseUpdateWithWhereUniqueWithoutExecutionInput | WorkflowPauseUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: WorkflowPauseUpdateManyWithWhereWithoutExecutionInput | WorkflowPauseUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: WorkflowPauseScalarWhereInput | WorkflowPauseScalarWhereInput[]
  }

  export type WorkflowExecutionCreateNestedOneWithoutNodeExecutionsInput = {
    create?: XOR<WorkflowExecutionCreateWithoutNodeExecutionsInput, WorkflowExecutionUncheckedCreateWithoutNodeExecutionsInput>
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutNodeExecutionsInput
    connect?: WorkflowExecutionWhereUniqueInput
  }

  export type NodeLogCreateNestedManyWithoutNodeExecutionInput = {
    create?: XOR<NodeLogCreateWithoutNodeExecutionInput, NodeLogUncheckedCreateWithoutNodeExecutionInput> | NodeLogCreateWithoutNodeExecutionInput[] | NodeLogUncheckedCreateWithoutNodeExecutionInput[]
    connectOrCreate?: NodeLogCreateOrConnectWithoutNodeExecutionInput | NodeLogCreateOrConnectWithoutNodeExecutionInput[]
    createMany?: NodeLogCreateManyNodeExecutionInputEnvelope
    connect?: NodeLogWhereUniqueInput | NodeLogWhereUniqueInput[]
  }

  export type NodeInputCreateNestedManyWithoutNodeExecutionInput = {
    create?: XOR<NodeInputCreateWithoutNodeExecutionInput, NodeInputUncheckedCreateWithoutNodeExecutionInput> | NodeInputCreateWithoutNodeExecutionInput[] | NodeInputUncheckedCreateWithoutNodeExecutionInput[]
    connectOrCreate?: NodeInputCreateOrConnectWithoutNodeExecutionInput | NodeInputCreateOrConnectWithoutNodeExecutionInput[]
    createMany?: NodeInputCreateManyNodeExecutionInputEnvelope
    connect?: NodeInputWhereUniqueInput | NodeInputWhereUniqueInput[]
  }

  export type NodeOutputCreateNestedManyWithoutNodeExecutionInput = {
    create?: XOR<NodeOutputCreateWithoutNodeExecutionInput, NodeOutputUncheckedCreateWithoutNodeExecutionInput> | NodeOutputCreateWithoutNodeExecutionInput[] | NodeOutputUncheckedCreateWithoutNodeExecutionInput[]
    connectOrCreate?: NodeOutputCreateOrConnectWithoutNodeExecutionInput | NodeOutputCreateOrConnectWithoutNodeExecutionInput[]
    createMany?: NodeOutputCreateManyNodeExecutionInputEnvelope
    connect?: NodeOutputWhereUniqueInput | NodeOutputWhereUniqueInput[]
  }

  export type NodeLogUncheckedCreateNestedManyWithoutNodeExecutionInput = {
    create?: XOR<NodeLogCreateWithoutNodeExecutionInput, NodeLogUncheckedCreateWithoutNodeExecutionInput> | NodeLogCreateWithoutNodeExecutionInput[] | NodeLogUncheckedCreateWithoutNodeExecutionInput[]
    connectOrCreate?: NodeLogCreateOrConnectWithoutNodeExecutionInput | NodeLogCreateOrConnectWithoutNodeExecutionInput[]
    createMany?: NodeLogCreateManyNodeExecutionInputEnvelope
    connect?: NodeLogWhereUniqueInput | NodeLogWhereUniqueInput[]
  }

  export type NodeInputUncheckedCreateNestedManyWithoutNodeExecutionInput = {
    create?: XOR<NodeInputCreateWithoutNodeExecutionInput, NodeInputUncheckedCreateWithoutNodeExecutionInput> | NodeInputCreateWithoutNodeExecutionInput[] | NodeInputUncheckedCreateWithoutNodeExecutionInput[]
    connectOrCreate?: NodeInputCreateOrConnectWithoutNodeExecutionInput | NodeInputCreateOrConnectWithoutNodeExecutionInput[]
    createMany?: NodeInputCreateManyNodeExecutionInputEnvelope
    connect?: NodeInputWhereUniqueInput | NodeInputWhereUniqueInput[]
  }

  export type NodeOutputUncheckedCreateNestedManyWithoutNodeExecutionInput = {
    create?: XOR<NodeOutputCreateWithoutNodeExecutionInput, NodeOutputUncheckedCreateWithoutNodeExecutionInput> | NodeOutputCreateWithoutNodeExecutionInput[] | NodeOutputUncheckedCreateWithoutNodeExecutionInput[]
    connectOrCreate?: NodeOutputCreateOrConnectWithoutNodeExecutionInput | NodeOutputCreateOrConnectWithoutNodeExecutionInput[]
    createMany?: NodeOutputCreateManyNodeExecutionInputEnvelope
    connect?: NodeOutputWhereUniqueInput | NodeOutputWhereUniqueInput[]
  }

  export type WorkflowExecutionUpdateOneRequiredWithoutNodeExecutionsNestedInput = {
    create?: XOR<WorkflowExecutionCreateWithoutNodeExecutionsInput, WorkflowExecutionUncheckedCreateWithoutNodeExecutionsInput>
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutNodeExecutionsInput
    upsert?: WorkflowExecutionUpsertWithoutNodeExecutionsInput
    connect?: WorkflowExecutionWhereUniqueInput
    update?: XOR<XOR<WorkflowExecutionUpdateToOneWithWhereWithoutNodeExecutionsInput, WorkflowExecutionUpdateWithoutNodeExecutionsInput>, WorkflowExecutionUncheckedUpdateWithoutNodeExecutionsInput>
  }

  export type NodeLogUpdateManyWithoutNodeExecutionNestedInput = {
    create?: XOR<NodeLogCreateWithoutNodeExecutionInput, NodeLogUncheckedCreateWithoutNodeExecutionInput> | NodeLogCreateWithoutNodeExecutionInput[] | NodeLogUncheckedCreateWithoutNodeExecutionInput[]
    connectOrCreate?: NodeLogCreateOrConnectWithoutNodeExecutionInput | NodeLogCreateOrConnectWithoutNodeExecutionInput[]
    upsert?: NodeLogUpsertWithWhereUniqueWithoutNodeExecutionInput | NodeLogUpsertWithWhereUniqueWithoutNodeExecutionInput[]
    createMany?: NodeLogCreateManyNodeExecutionInputEnvelope
    set?: NodeLogWhereUniqueInput | NodeLogWhereUniqueInput[]
    disconnect?: NodeLogWhereUniqueInput | NodeLogWhereUniqueInput[]
    delete?: NodeLogWhereUniqueInput | NodeLogWhereUniqueInput[]
    connect?: NodeLogWhereUniqueInput | NodeLogWhereUniqueInput[]
    update?: NodeLogUpdateWithWhereUniqueWithoutNodeExecutionInput | NodeLogUpdateWithWhereUniqueWithoutNodeExecutionInput[]
    updateMany?: NodeLogUpdateManyWithWhereWithoutNodeExecutionInput | NodeLogUpdateManyWithWhereWithoutNodeExecutionInput[]
    deleteMany?: NodeLogScalarWhereInput | NodeLogScalarWhereInput[]
  }

  export type NodeInputUpdateManyWithoutNodeExecutionNestedInput = {
    create?: XOR<NodeInputCreateWithoutNodeExecutionInput, NodeInputUncheckedCreateWithoutNodeExecutionInput> | NodeInputCreateWithoutNodeExecutionInput[] | NodeInputUncheckedCreateWithoutNodeExecutionInput[]
    connectOrCreate?: NodeInputCreateOrConnectWithoutNodeExecutionInput | NodeInputCreateOrConnectWithoutNodeExecutionInput[]
    upsert?: NodeInputUpsertWithWhereUniqueWithoutNodeExecutionInput | NodeInputUpsertWithWhereUniqueWithoutNodeExecutionInput[]
    createMany?: NodeInputCreateManyNodeExecutionInputEnvelope
    set?: NodeInputWhereUniqueInput | NodeInputWhereUniqueInput[]
    disconnect?: NodeInputWhereUniqueInput | NodeInputWhereUniqueInput[]
    delete?: NodeInputWhereUniqueInput | NodeInputWhereUniqueInput[]
    connect?: NodeInputWhereUniqueInput | NodeInputWhereUniqueInput[]
    update?: NodeInputUpdateWithWhereUniqueWithoutNodeExecutionInput | NodeInputUpdateWithWhereUniqueWithoutNodeExecutionInput[]
    updateMany?: NodeInputUpdateManyWithWhereWithoutNodeExecutionInput | NodeInputUpdateManyWithWhereWithoutNodeExecutionInput[]
    deleteMany?: NodeInputScalarWhereInput | NodeInputScalarWhereInput[]
  }

  export type NodeOutputUpdateManyWithoutNodeExecutionNestedInput = {
    create?: XOR<NodeOutputCreateWithoutNodeExecutionInput, NodeOutputUncheckedCreateWithoutNodeExecutionInput> | NodeOutputCreateWithoutNodeExecutionInput[] | NodeOutputUncheckedCreateWithoutNodeExecutionInput[]
    connectOrCreate?: NodeOutputCreateOrConnectWithoutNodeExecutionInput | NodeOutputCreateOrConnectWithoutNodeExecutionInput[]
    upsert?: NodeOutputUpsertWithWhereUniqueWithoutNodeExecutionInput | NodeOutputUpsertWithWhereUniqueWithoutNodeExecutionInput[]
    createMany?: NodeOutputCreateManyNodeExecutionInputEnvelope
    set?: NodeOutputWhereUniqueInput | NodeOutputWhereUniqueInput[]
    disconnect?: NodeOutputWhereUniqueInput | NodeOutputWhereUniqueInput[]
    delete?: NodeOutputWhereUniqueInput | NodeOutputWhereUniqueInput[]
    connect?: NodeOutputWhereUniqueInput | NodeOutputWhereUniqueInput[]
    update?: NodeOutputUpdateWithWhereUniqueWithoutNodeExecutionInput | NodeOutputUpdateWithWhereUniqueWithoutNodeExecutionInput[]
    updateMany?: NodeOutputUpdateManyWithWhereWithoutNodeExecutionInput | NodeOutputUpdateManyWithWhereWithoutNodeExecutionInput[]
    deleteMany?: NodeOutputScalarWhereInput | NodeOutputScalarWhereInput[]
  }

  export type NodeLogUncheckedUpdateManyWithoutNodeExecutionNestedInput = {
    create?: XOR<NodeLogCreateWithoutNodeExecutionInput, NodeLogUncheckedCreateWithoutNodeExecutionInput> | NodeLogCreateWithoutNodeExecutionInput[] | NodeLogUncheckedCreateWithoutNodeExecutionInput[]
    connectOrCreate?: NodeLogCreateOrConnectWithoutNodeExecutionInput | NodeLogCreateOrConnectWithoutNodeExecutionInput[]
    upsert?: NodeLogUpsertWithWhereUniqueWithoutNodeExecutionInput | NodeLogUpsertWithWhereUniqueWithoutNodeExecutionInput[]
    createMany?: NodeLogCreateManyNodeExecutionInputEnvelope
    set?: NodeLogWhereUniqueInput | NodeLogWhereUniqueInput[]
    disconnect?: NodeLogWhereUniqueInput | NodeLogWhereUniqueInput[]
    delete?: NodeLogWhereUniqueInput | NodeLogWhereUniqueInput[]
    connect?: NodeLogWhereUniqueInput | NodeLogWhereUniqueInput[]
    update?: NodeLogUpdateWithWhereUniqueWithoutNodeExecutionInput | NodeLogUpdateWithWhereUniqueWithoutNodeExecutionInput[]
    updateMany?: NodeLogUpdateManyWithWhereWithoutNodeExecutionInput | NodeLogUpdateManyWithWhereWithoutNodeExecutionInput[]
    deleteMany?: NodeLogScalarWhereInput | NodeLogScalarWhereInput[]
  }

  export type NodeInputUncheckedUpdateManyWithoutNodeExecutionNestedInput = {
    create?: XOR<NodeInputCreateWithoutNodeExecutionInput, NodeInputUncheckedCreateWithoutNodeExecutionInput> | NodeInputCreateWithoutNodeExecutionInput[] | NodeInputUncheckedCreateWithoutNodeExecutionInput[]
    connectOrCreate?: NodeInputCreateOrConnectWithoutNodeExecutionInput | NodeInputCreateOrConnectWithoutNodeExecutionInput[]
    upsert?: NodeInputUpsertWithWhereUniqueWithoutNodeExecutionInput | NodeInputUpsertWithWhereUniqueWithoutNodeExecutionInput[]
    createMany?: NodeInputCreateManyNodeExecutionInputEnvelope
    set?: NodeInputWhereUniqueInput | NodeInputWhereUniqueInput[]
    disconnect?: NodeInputWhereUniqueInput | NodeInputWhereUniqueInput[]
    delete?: NodeInputWhereUniqueInput | NodeInputWhereUniqueInput[]
    connect?: NodeInputWhereUniqueInput | NodeInputWhereUniqueInput[]
    update?: NodeInputUpdateWithWhereUniqueWithoutNodeExecutionInput | NodeInputUpdateWithWhereUniqueWithoutNodeExecutionInput[]
    updateMany?: NodeInputUpdateManyWithWhereWithoutNodeExecutionInput | NodeInputUpdateManyWithWhereWithoutNodeExecutionInput[]
    deleteMany?: NodeInputScalarWhereInput | NodeInputScalarWhereInput[]
  }

  export type NodeOutputUncheckedUpdateManyWithoutNodeExecutionNestedInput = {
    create?: XOR<NodeOutputCreateWithoutNodeExecutionInput, NodeOutputUncheckedCreateWithoutNodeExecutionInput> | NodeOutputCreateWithoutNodeExecutionInput[] | NodeOutputUncheckedCreateWithoutNodeExecutionInput[]
    connectOrCreate?: NodeOutputCreateOrConnectWithoutNodeExecutionInput | NodeOutputCreateOrConnectWithoutNodeExecutionInput[]
    upsert?: NodeOutputUpsertWithWhereUniqueWithoutNodeExecutionInput | NodeOutputUpsertWithWhereUniqueWithoutNodeExecutionInput[]
    createMany?: NodeOutputCreateManyNodeExecutionInputEnvelope
    set?: NodeOutputWhereUniqueInput | NodeOutputWhereUniqueInput[]
    disconnect?: NodeOutputWhereUniqueInput | NodeOutputWhereUniqueInput[]
    delete?: NodeOutputWhereUniqueInput | NodeOutputWhereUniqueInput[]
    connect?: NodeOutputWhereUniqueInput | NodeOutputWhereUniqueInput[]
    update?: NodeOutputUpdateWithWhereUniqueWithoutNodeExecutionInput | NodeOutputUpdateWithWhereUniqueWithoutNodeExecutionInput[]
    updateMany?: NodeOutputUpdateManyWithWhereWithoutNodeExecutionInput | NodeOutputUpdateManyWithWhereWithoutNodeExecutionInput[]
    deleteMany?: NodeOutputScalarWhereInput | NodeOutputScalarWhereInput[]
  }

  export type NodeExecutionCreateNestedOneWithoutLogsInput = {
    create?: XOR<NodeExecutionCreateWithoutLogsInput, NodeExecutionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: NodeExecutionCreateOrConnectWithoutLogsInput
    connect?: NodeExecutionWhereUniqueInput
  }

  export type EnumLogLevelFieldUpdateOperationsInput = {
    set?: $Enums.LogLevel
  }

  export type NodeExecutionUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<NodeExecutionCreateWithoutLogsInput, NodeExecutionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: NodeExecutionCreateOrConnectWithoutLogsInput
    upsert?: NodeExecutionUpsertWithoutLogsInput
    connect?: NodeExecutionWhereUniqueInput
    update?: XOR<XOR<NodeExecutionUpdateToOneWithWhereWithoutLogsInput, NodeExecutionUpdateWithoutLogsInput>, NodeExecutionUncheckedUpdateWithoutLogsInput>
  }

  export type NodeExecutionCreateNestedOneWithoutNodeInputsInput = {
    create?: XOR<NodeExecutionCreateWithoutNodeInputsInput, NodeExecutionUncheckedCreateWithoutNodeInputsInput>
    connectOrCreate?: NodeExecutionCreateOrConnectWithoutNodeInputsInput
    connect?: NodeExecutionWhereUniqueInput
  }

  export type NodeExecutionUpdateOneRequiredWithoutNodeInputsNestedInput = {
    create?: XOR<NodeExecutionCreateWithoutNodeInputsInput, NodeExecutionUncheckedCreateWithoutNodeInputsInput>
    connectOrCreate?: NodeExecutionCreateOrConnectWithoutNodeInputsInput
    upsert?: NodeExecutionUpsertWithoutNodeInputsInput
    connect?: NodeExecutionWhereUniqueInput
    update?: XOR<XOR<NodeExecutionUpdateToOneWithWhereWithoutNodeInputsInput, NodeExecutionUpdateWithoutNodeInputsInput>, NodeExecutionUncheckedUpdateWithoutNodeInputsInput>
  }

  export type NodeExecutionCreateNestedOneWithoutNodeOutputsInput = {
    create?: XOR<NodeExecutionCreateWithoutNodeOutputsInput, NodeExecutionUncheckedCreateWithoutNodeOutputsInput>
    connectOrCreate?: NodeExecutionCreateOrConnectWithoutNodeOutputsInput
    connect?: NodeExecutionWhereUniqueInput
  }

  export type NodeExecutionUpdateOneRequiredWithoutNodeOutputsNestedInput = {
    create?: XOR<NodeExecutionCreateWithoutNodeOutputsInput, NodeExecutionUncheckedCreateWithoutNodeOutputsInput>
    connectOrCreate?: NodeExecutionCreateOrConnectWithoutNodeOutputsInput
    upsert?: NodeExecutionUpsertWithoutNodeOutputsInput
    connect?: NodeExecutionWhereUniqueInput
    update?: XOR<XOR<NodeExecutionUpdateToOneWithWhereWithoutNodeOutputsInput, NodeExecutionUpdateWithoutNodeOutputsInput>, NodeExecutionUncheckedUpdateWithoutNodeOutputsInput>
  }

  export type WorkflowExecutionCreateNestedOneWithoutExecutionLogsInput = {
    create?: XOR<WorkflowExecutionCreateWithoutExecutionLogsInput, WorkflowExecutionUncheckedCreateWithoutExecutionLogsInput>
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutExecutionLogsInput
    connect?: WorkflowExecutionWhereUniqueInput
  }

  export type WorkflowExecutionUpdateOneRequiredWithoutExecutionLogsNestedInput = {
    create?: XOR<WorkflowExecutionCreateWithoutExecutionLogsInput, WorkflowExecutionUncheckedCreateWithoutExecutionLogsInput>
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutExecutionLogsInput
    upsert?: WorkflowExecutionUpsertWithoutExecutionLogsInput
    connect?: WorkflowExecutionWhereUniqueInput
    update?: XOR<XOR<WorkflowExecutionUpdateToOneWithWhereWithoutExecutionLogsInput, WorkflowExecutionUpdateWithoutExecutionLogsInput>, WorkflowExecutionUncheckedUpdateWithoutExecutionLogsInput>
  }

  export type WorkflowCreateNestedOneWithoutPausesInput = {
    create?: XOR<WorkflowCreateWithoutPausesInput, WorkflowUncheckedCreateWithoutPausesInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutPausesInput
    connect?: WorkflowWhereUniqueInput
  }

  export type WorkflowExecutionCreateNestedOneWithoutWorkflowPausesInput = {
    create?: XOR<WorkflowExecutionCreateWithoutWorkflowPausesInput, WorkflowExecutionUncheckedCreateWithoutWorkflowPausesInput>
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutWorkflowPausesInput
    connect?: WorkflowExecutionWhereUniqueInput
  }

  export type WorkflowUpdateOneRequiredWithoutPausesNestedInput = {
    create?: XOR<WorkflowCreateWithoutPausesInput, WorkflowUncheckedCreateWithoutPausesInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutPausesInput
    upsert?: WorkflowUpsertWithoutPausesInput
    connect?: WorkflowWhereUniqueInput
    update?: XOR<XOR<WorkflowUpdateToOneWithWhereWithoutPausesInput, WorkflowUpdateWithoutPausesInput>, WorkflowUncheckedUpdateWithoutPausesInput>
  }

  export type WorkflowExecutionUpdateOneRequiredWithoutWorkflowPausesNestedInput = {
    create?: XOR<WorkflowExecutionCreateWithoutWorkflowPausesInput, WorkflowExecutionUncheckedCreateWithoutWorkflowPausesInput>
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutWorkflowPausesInput
    upsert?: WorkflowExecutionUpsertWithoutWorkflowPausesInput
    connect?: WorkflowExecutionWhereUniqueInput
    update?: XOR<XOR<WorkflowExecutionUpdateToOneWithWhereWithoutWorkflowPausesInput, WorkflowExecutionUpdateWithoutWorkflowPausesInput>, WorkflowExecutionUncheckedUpdateWithoutWorkflowPausesInput>
  }

  export type WorkflowExecutionCreateNestedOneWithoutBlockchainTransactionsInput = {
    create?: XOR<WorkflowExecutionCreateWithoutBlockchainTransactionsInput, WorkflowExecutionUncheckedCreateWithoutBlockchainTransactionsInput>
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutBlockchainTransactionsInput
    connect?: WorkflowExecutionWhereUniqueInput
  }

  export type TransactionAttemptCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionAttemptCreateWithoutTransactionInput, TransactionAttemptUncheckedCreateWithoutTransactionInput> | TransactionAttemptCreateWithoutTransactionInput[] | TransactionAttemptUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionAttemptCreateOrConnectWithoutTransactionInput | TransactionAttemptCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionAttemptCreateManyTransactionInputEnvelope
    connect?: TransactionAttemptWhereUniqueInput | TransactionAttemptWhereUniqueInput[]
  }

  export type TransactionAttemptUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionAttemptCreateWithoutTransactionInput, TransactionAttemptUncheckedCreateWithoutTransactionInput> | TransactionAttemptCreateWithoutTransactionInput[] | TransactionAttemptUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionAttemptCreateOrConnectWithoutTransactionInput | TransactionAttemptCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionAttemptCreateManyTransactionInputEnvelope
    connect?: TransactionAttemptWhereUniqueInput | TransactionAttemptWhereUniqueInput[]
  }

  export type WorkflowExecutionUpdateOneRequiredWithoutBlockchainTransactionsNestedInput = {
    create?: XOR<WorkflowExecutionCreateWithoutBlockchainTransactionsInput, WorkflowExecutionUncheckedCreateWithoutBlockchainTransactionsInput>
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutBlockchainTransactionsInput
    upsert?: WorkflowExecutionUpsertWithoutBlockchainTransactionsInput
    connect?: WorkflowExecutionWhereUniqueInput
    update?: XOR<XOR<WorkflowExecutionUpdateToOneWithWhereWithoutBlockchainTransactionsInput, WorkflowExecutionUpdateWithoutBlockchainTransactionsInput>, WorkflowExecutionUncheckedUpdateWithoutBlockchainTransactionsInput>
  }

  export type TransactionAttemptUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionAttemptCreateWithoutTransactionInput, TransactionAttemptUncheckedCreateWithoutTransactionInput> | TransactionAttemptCreateWithoutTransactionInput[] | TransactionAttemptUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionAttemptCreateOrConnectWithoutTransactionInput | TransactionAttemptCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionAttemptUpsertWithWhereUniqueWithoutTransactionInput | TransactionAttemptUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionAttemptCreateManyTransactionInputEnvelope
    set?: TransactionAttemptWhereUniqueInput | TransactionAttemptWhereUniqueInput[]
    disconnect?: TransactionAttemptWhereUniqueInput | TransactionAttemptWhereUniqueInput[]
    delete?: TransactionAttemptWhereUniqueInput | TransactionAttemptWhereUniqueInput[]
    connect?: TransactionAttemptWhereUniqueInput | TransactionAttemptWhereUniqueInput[]
    update?: TransactionAttemptUpdateWithWhereUniqueWithoutTransactionInput | TransactionAttemptUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionAttemptUpdateManyWithWhereWithoutTransactionInput | TransactionAttemptUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionAttemptScalarWhereInput | TransactionAttemptScalarWhereInput[]
  }

  export type TransactionAttemptUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionAttemptCreateWithoutTransactionInput, TransactionAttemptUncheckedCreateWithoutTransactionInput> | TransactionAttemptCreateWithoutTransactionInput[] | TransactionAttemptUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionAttemptCreateOrConnectWithoutTransactionInput | TransactionAttemptCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionAttemptUpsertWithWhereUniqueWithoutTransactionInput | TransactionAttemptUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionAttemptCreateManyTransactionInputEnvelope
    set?: TransactionAttemptWhereUniqueInput | TransactionAttemptWhereUniqueInput[]
    disconnect?: TransactionAttemptWhereUniqueInput | TransactionAttemptWhereUniqueInput[]
    delete?: TransactionAttemptWhereUniqueInput | TransactionAttemptWhereUniqueInput[]
    connect?: TransactionAttemptWhereUniqueInput | TransactionAttemptWhereUniqueInput[]
    update?: TransactionAttemptUpdateWithWhereUniqueWithoutTransactionInput | TransactionAttemptUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionAttemptUpdateManyWithWhereWithoutTransactionInput | TransactionAttemptUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionAttemptScalarWhereInput | TransactionAttemptScalarWhereInput[]
  }

  export type BlockchainTransactionCreateNestedOneWithoutTransactionAttemptsInput = {
    create?: XOR<BlockchainTransactionCreateWithoutTransactionAttemptsInput, BlockchainTransactionUncheckedCreateWithoutTransactionAttemptsInput>
    connectOrCreate?: BlockchainTransactionCreateOrConnectWithoutTransactionAttemptsInput
    connect?: BlockchainTransactionWhereUniqueInput
  }

  export type BlockchainTransactionUpdateOneRequiredWithoutTransactionAttemptsNestedInput = {
    create?: XOR<BlockchainTransactionCreateWithoutTransactionAttemptsInput, BlockchainTransactionUncheckedCreateWithoutTransactionAttemptsInput>
    connectOrCreate?: BlockchainTransactionCreateOrConnectWithoutTransactionAttemptsInput
    upsert?: BlockchainTransactionUpsertWithoutTransactionAttemptsInput
    connect?: BlockchainTransactionWhereUniqueInput
    update?: XOR<XOR<BlockchainTransactionUpdateToOneWithWhereWithoutTransactionAttemptsInput, BlockchainTransactionUpdateWithoutTransactionAttemptsInput>, BlockchainTransactionUncheckedUpdateWithoutTransactionAttemptsInput>
  }

  export type WorkflowExecutionCreateNestedOneWithoutBlockExecutionsInput = {
    create?: XOR<WorkflowExecutionCreateWithoutBlockExecutionsInput, WorkflowExecutionUncheckedCreateWithoutBlockExecutionsInput>
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutBlockExecutionsInput
    connect?: WorkflowExecutionWhereUniqueInput
  }

  export type BlockExecutionLogCreateNestedManyWithoutBlockExecutionInput = {
    create?: XOR<BlockExecutionLogCreateWithoutBlockExecutionInput, BlockExecutionLogUncheckedCreateWithoutBlockExecutionInput> | BlockExecutionLogCreateWithoutBlockExecutionInput[] | BlockExecutionLogUncheckedCreateWithoutBlockExecutionInput[]
    connectOrCreate?: BlockExecutionLogCreateOrConnectWithoutBlockExecutionInput | BlockExecutionLogCreateOrConnectWithoutBlockExecutionInput[]
    createMany?: BlockExecutionLogCreateManyBlockExecutionInputEnvelope
    connect?: BlockExecutionLogWhereUniqueInput | BlockExecutionLogWhereUniqueInput[]
  }

  export type BlockExecutionLogUncheckedCreateNestedManyWithoutBlockExecutionInput = {
    create?: XOR<BlockExecutionLogCreateWithoutBlockExecutionInput, BlockExecutionLogUncheckedCreateWithoutBlockExecutionInput> | BlockExecutionLogCreateWithoutBlockExecutionInput[] | BlockExecutionLogUncheckedCreateWithoutBlockExecutionInput[]
    connectOrCreate?: BlockExecutionLogCreateOrConnectWithoutBlockExecutionInput | BlockExecutionLogCreateOrConnectWithoutBlockExecutionInput[]
    createMany?: BlockExecutionLogCreateManyBlockExecutionInputEnvelope
    connect?: BlockExecutionLogWhereUniqueInput | BlockExecutionLogWhereUniqueInput[]
  }

  export type EnumBlockStatusFieldUpdateOperationsInput = {
    set?: $Enums.BlockStatus
  }

  export type WorkflowExecutionUpdateOneRequiredWithoutBlockExecutionsNestedInput = {
    create?: XOR<WorkflowExecutionCreateWithoutBlockExecutionsInput, WorkflowExecutionUncheckedCreateWithoutBlockExecutionsInput>
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutBlockExecutionsInput
    upsert?: WorkflowExecutionUpsertWithoutBlockExecutionsInput
    connect?: WorkflowExecutionWhereUniqueInput
    update?: XOR<XOR<WorkflowExecutionUpdateToOneWithWhereWithoutBlockExecutionsInput, WorkflowExecutionUpdateWithoutBlockExecutionsInput>, WorkflowExecutionUncheckedUpdateWithoutBlockExecutionsInput>
  }

  export type BlockExecutionLogUpdateManyWithoutBlockExecutionNestedInput = {
    create?: XOR<BlockExecutionLogCreateWithoutBlockExecutionInput, BlockExecutionLogUncheckedCreateWithoutBlockExecutionInput> | BlockExecutionLogCreateWithoutBlockExecutionInput[] | BlockExecutionLogUncheckedCreateWithoutBlockExecutionInput[]
    connectOrCreate?: BlockExecutionLogCreateOrConnectWithoutBlockExecutionInput | BlockExecutionLogCreateOrConnectWithoutBlockExecutionInput[]
    upsert?: BlockExecutionLogUpsertWithWhereUniqueWithoutBlockExecutionInput | BlockExecutionLogUpsertWithWhereUniqueWithoutBlockExecutionInput[]
    createMany?: BlockExecutionLogCreateManyBlockExecutionInputEnvelope
    set?: BlockExecutionLogWhereUniqueInput | BlockExecutionLogWhereUniqueInput[]
    disconnect?: BlockExecutionLogWhereUniqueInput | BlockExecutionLogWhereUniqueInput[]
    delete?: BlockExecutionLogWhereUniqueInput | BlockExecutionLogWhereUniqueInput[]
    connect?: BlockExecutionLogWhereUniqueInput | BlockExecutionLogWhereUniqueInput[]
    update?: BlockExecutionLogUpdateWithWhereUniqueWithoutBlockExecutionInput | BlockExecutionLogUpdateWithWhereUniqueWithoutBlockExecutionInput[]
    updateMany?: BlockExecutionLogUpdateManyWithWhereWithoutBlockExecutionInput | BlockExecutionLogUpdateManyWithWhereWithoutBlockExecutionInput[]
    deleteMany?: BlockExecutionLogScalarWhereInput | BlockExecutionLogScalarWhereInput[]
  }

  export type BlockExecutionLogUncheckedUpdateManyWithoutBlockExecutionNestedInput = {
    create?: XOR<BlockExecutionLogCreateWithoutBlockExecutionInput, BlockExecutionLogUncheckedCreateWithoutBlockExecutionInput> | BlockExecutionLogCreateWithoutBlockExecutionInput[] | BlockExecutionLogUncheckedCreateWithoutBlockExecutionInput[]
    connectOrCreate?: BlockExecutionLogCreateOrConnectWithoutBlockExecutionInput | BlockExecutionLogCreateOrConnectWithoutBlockExecutionInput[]
    upsert?: BlockExecutionLogUpsertWithWhereUniqueWithoutBlockExecutionInput | BlockExecutionLogUpsertWithWhereUniqueWithoutBlockExecutionInput[]
    createMany?: BlockExecutionLogCreateManyBlockExecutionInputEnvelope
    set?: BlockExecutionLogWhereUniqueInput | BlockExecutionLogWhereUniqueInput[]
    disconnect?: BlockExecutionLogWhereUniqueInput | BlockExecutionLogWhereUniqueInput[]
    delete?: BlockExecutionLogWhereUniqueInput | BlockExecutionLogWhereUniqueInput[]
    connect?: BlockExecutionLogWhereUniqueInput | BlockExecutionLogWhereUniqueInput[]
    update?: BlockExecutionLogUpdateWithWhereUniqueWithoutBlockExecutionInput | BlockExecutionLogUpdateWithWhereUniqueWithoutBlockExecutionInput[]
    updateMany?: BlockExecutionLogUpdateManyWithWhereWithoutBlockExecutionInput | BlockExecutionLogUpdateManyWithWhereWithoutBlockExecutionInput[]
    deleteMany?: BlockExecutionLogScalarWhereInput | BlockExecutionLogScalarWhereInput[]
  }

  export type BlockExecutionCreateNestedOneWithoutLogsInput = {
    create?: XOR<BlockExecutionCreateWithoutLogsInput, BlockExecutionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: BlockExecutionCreateOrConnectWithoutLogsInput
    connect?: BlockExecutionWhereUniqueInput
  }

  export type BlockExecutionUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<BlockExecutionCreateWithoutLogsInput, BlockExecutionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: BlockExecutionCreateOrConnectWithoutLogsInput
    upsert?: BlockExecutionUpsertWithoutLogsInput
    connect?: BlockExecutionWhereUniqueInput
    update?: XOR<XOR<BlockExecutionUpdateToOneWithWhereWithoutLogsInput, BlockExecutionUpdateWithoutLogsInput>, BlockExecutionUncheckedUpdateWithoutLogsInput>
  }

  export type BlockLibraryCreatetagsInput = {
    set: string[]
  }

  export type BlockLibraryRatingCreateNestedManyWithoutBlockInput = {
    create?: XOR<BlockLibraryRatingCreateWithoutBlockInput, BlockLibraryRatingUncheckedCreateWithoutBlockInput> | BlockLibraryRatingCreateWithoutBlockInput[] | BlockLibraryRatingUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockLibraryRatingCreateOrConnectWithoutBlockInput | BlockLibraryRatingCreateOrConnectWithoutBlockInput[]
    createMany?: BlockLibraryRatingCreateManyBlockInputEnvelope
    connect?: BlockLibraryRatingWhereUniqueInput | BlockLibraryRatingWhereUniqueInput[]
  }

  export type BlockLibraryRatingUncheckedCreateNestedManyWithoutBlockInput = {
    create?: XOR<BlockLibraryRatingCreateWithoutBlockInput, BlockLibraryRatingUncheckedCreateWithoutBlockInput> | BlockLibraryRatingCreateWithoutBlockInput[] | BlockLibraryRatingUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockLibraryRatingCreateOrConnectWithoutBlockInput | BlockLibraryRatingCreateOrConnectWithoutBlockInput[]
    createMany?: BlockLibraryRatingCreateManyBlockInputEnvelope
    connect?: BlockLibraryRatingWhereUniqueInput | BlockLibraryRatingWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BlockLibraryUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BlockLibraryRatingUpdateManyWithoutBlockNestedInput = {
    create?: XOR<BlockLibraryRatingCreateWithoutBlockInput, BlockLibraryRatingUncheckedCreateWithoutBlockInput> | BlockLibraryRatingCreateWithoutBlockInput[] | BlockLibraryRatingUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockLibraryRatingCreateOrConnectWithoutBlockInput | BlockLibraryRatingCreateOrConnectWithoutBlockInput[]
    upsert?: BlockLibraryRatingUpsertWithWhereUniqueWithoutBlockInput | BlockLibraryRatingUpsertWithWhereUniqueWithoutBlockInput[]
    createMany?: BlockLibraryRatingCreateManyBlockInputEnvelope
    set?: BlockLibraryRatingWhereUniqueInput | BlockLibraryRatingWhereUniqueInput[]
    disconnect?: BlockLibraryRatingWhereUniqueInput | BlockLibraryRatingWhereUniqueInput[]
    delete?: BlockLibraryRatingWhereUniqueInput | BlockLibraryRatingWhereUniqueInput[]
    connect?: BlockLibraryRatingWhereUniqueInput | BlockLibraryRatingWhereUniqueInput[]
    update?: BlockLibraryRatingUpdateWithWhereUniqueWithoutBlockInput | BlockLibraryRatingUpdateWithWhereUniqueWithoutBlockInput[]
    updateMany?: BlockLibraryRatingUpdateManyWithWhereWithoutBlockInput | BlockLibraryRatingUpdateManyWithWhereWithoutBlockInput[]
    deleteMany?: BlockLibraryRatingScalarWhereInput | BlockLibraryRatingScalarWhereInput[]
  }

  export type BlockLibraryRatingUncheckedUpdateManyWithoutBlockNestedInput = {
    create?: XOR<BlockLibraryRatingCreateWithoutBlockInput, BlockLibraryRatingUncheckedCreateWithoutBlockInput> | BlockLibraryRatingCreateWithoutBlockInput[] | BlockLibraryRatingUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockLibraryRatingCreateOrConnectWithoutBlockInput | BlockLibraryRatingCreateOrConnectWithoutBlockInput[]
    upsert?: BlockLibraryRatingUpsertWithWhereUniqueWithoutBlockInput | BlockLibraryRatingUpsertWithWhereUniqueWithoutBlockInput[]
    createMany?: BlockLibraryRatingCreateManyBlockInputEnvelope
    set?: BlockLibraryRatingWhereUniqueInput | BlockLibraryRatingWhereUniqueInput[]
    disconnect?: BlockLibraryRatingWhereUniqueInput | BlockLibraryRatingWhereUniqueInput[]
    delete?: BlockLibraryRatingWhereUniqueInput | BlockLibraryRatingWhereUniqueInput[]
    connect?: BlockLibraryRatingWhereUniqueInput | BlockLibraryRatingWhereUniqueInput[]
    update?: BlockLibraryRatingUpdateWithWhereUniqueWithoutBlockInput | BlockLibraryRatingUpdateWithWhereUniqueWithoutBlockInput[]
    updateMany?: BlockLibraryRatingUpdateManyWithWhereWithoutBlockInput | BlockLibraryRatingUpdateManyWithWhereWithoutBlockInput[]
    deleteMany?: BlockLibraryRatingScalarWhereInput | BlockLibraryRatingScalarWhereInput[]
  }

  export type BlockLibraryCreateNestedOneWithoutRatingsInput = {
    create?: XOR<BlockLibraryCreateWithoutRatingsInput, BlockLibraryUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: BlockLibraryCreateOrConnectWithoutRatingsInput
    connect?: BlockLibraryWhereUniqueInput
  }

  export type BlockLibraryUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<BlockLibraryCreateWithoutRatingsInput, BlockLibraryUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: BlockLibraryCreateOrConnectWithoutRatingsInput
    upsert?: BlockLibraryUpsertWithoutRatingsInput
    connect?: BlockLibraryWhereUniqueInput
    update?: XOR<XOR<BlockLibraryUpdateToOneWithWhereWithoutRatingsInput, BlockLibraryUpdateWithoutRatingsInput>, BlockLibraryUncheckedUpdateWithoutRatingsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutNotificationPreferencesInput = {
    create?: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferencesInput
    upsert?: UserUpsertWithoutNotificationPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationPreferencesInput, UserUpdateWithoutNotificationPreferencesInput>, UserUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type SubscriptionCreateNestedManyWithoutTierInput = {
    create?: XOR<SubscriptionCreateWithoutTierInput, SubscriptionUncheckedCreateWithoutTierInput> | SubscriptionCreateWithoutTierInput[] | SubscriptionUncheckedCreateWithoutTierInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutTierInput | SubscriptionCreateOrConnectWithoutTierInput[]
    createMany?: SubscriptionCreateManyTierInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutTierInput = {
    create?: XOR<SubscriptionCreateWithoutTierInput, SubscriptionUncheckedCreateWithoutTierInput> | SubscriptionCreateWithoutTierInput[] | SubscriptionUncheckedCreateWithoutTierInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutTierInput | SubscriptionCreateOrConnectWithoutTierInput[]
    createMany?: SubscriptionCreateManyTierInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type SubscriptionUpdateManyWithoutTierNestedInput = {
    create?: XOR<SubscriptionCreateWithoutTierInput, SubscriptionUncheckedCreateWithoutTierInput> | SubscriptionCreateWithoutTierInput[] | SubscriptionUncheckedCreateWithoutTierInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutTierInput | SubscriptionCreateOrConnectWithoutTierInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutTierInput | SubscriptionUpsertWithWhereUniqueWithoutTierInput[]
    createMany?: SubscriptionCreateManyTierInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutTierInput | SubscriptionUpdateWithWhereUniqueWithoutTierInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutTierInput | SubscriptionUpdateManyWithWhereWithoutTierInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutTierNestedInput = {
    create?: XOR<SubscriptionCreateWithoutTierInput, SubscriptionUncheckedCreateWithoutTierInput> | SubscriptionCreateWithoutTierInput[] | SubscriptionUncheckedCreateWithoutTierInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutTierInput | SubscriptionCreateOrConnectWithoutTierInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutTierInput | SubscriptionUpsertWithWhereUniqueWithoutTierInput[]
    createMany?: SubscriptionCreateManyTierInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutTierInput | SubscriptionUpdateWithWhereUniqueWithoutTierInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutTierInput | SubscriptionUpdateManyWithWhereWithoutTierInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type PricingTierCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<PricingTierCreateWithoutSubscriptionsInput, PricingTierUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PricingTierCreateOrConnectWithoutSubscriptionsInput
    connect?: PricingTierWhereUniqueInput
  }

  export type SubscriptionInvoiceCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<SubscriptionInvoiceCreateWithoutSubscriptionInput, SubscriptionInvoiceUncheckedCreateWithoutSubscriptionInput> | SubscriptionInvoiceCreateWithoutSubscriptionInput[] | SubscriptionInvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionInvoiceCreateOrConnectWithoutSubscriptionInput | SubscriptionInvoiceCreateOrConnectWithoutSubscriptionInput[]
    createMany?: SubscriptionInvoiceCreateManySubscriptionInputEnvelope
    connect?: SubscriptionInvoiceWhereUniqueInput | SubscriptionInvoiceWhereUniqueInput[]
  }

  export type SubscriptionInvoiceUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<SubscriptionInvoiceCreateWithoutSubscriptionInput, SubscriptionInvoiceUncheckedCreateWithoutSubscriptionInput> | SubscriptionInvoiceCreateWithoutSubscriptionInput[] | SubscriptionInvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionInvoiceCreateOrConnectWithoutSubscriptionInput | SubscriptionInvoiceCreateOrConnectWithoutSubscriptionInput[]
    createMany?: SubscriptionInvoiceCreateManySubscriptionInputEnvelope
    connect?: SubscriptionInvoiceWhereUniqueInput | SubscriptionInvoiceWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    upsert?: UserUpsertWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionInput, UserUpdateWithoutSubscriptionInput>, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PricingTierUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<PricingTierCreateWithoutSubscriptionsInput, PricingTierUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PricingTierCreateOrConnectWithoutSubscriptionsInput
    upsert?: PricingTierUpsertWithoutSubscriptionsInput
    connect?: PricingTierWhereUniqueInput
    update?: XOR<XOR<PricingTierUpdateToOneWithWhereWithoutSubscriptionsInput, PricingTierUpdateWithoutSubscriptionsInput>, PricingTierUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionInvoiceUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<SubscriptionInvoiceCreateWithoutSubscriptionInput, SubscriptionInvoiceUncheckedCreateWithoutSubscriptionInput> | SubscriptionInvoiceCreateWithoutSubscriptionInput[] | SubscriptionInvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionInvoiceCreateOrConnectWithoutSubscriptionInput | SubscriptionInvoiceCreateOrConnectWithoutSubscriptionInput[]
    upsert?: SubscriptionInvoiceUpsertWithWhereUniqueWithoutSubscriptionInput | SubscriptionInvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: SubscriptionInvoiceCreateManySubscriptionInputEnvelope
    set?: SubscriptionInvoiceWhereUniqueInput | SubscriptionInvoiceWhereUniqueInput[]
    disconnect?: SubscriptionInvoiceWhereUniqueInput | SubscriptionInvoiceWhereUniqueInput[]
    delete?: SubscriptionInvoiceWhereUniqueInput | SubscriptionInvoiceWhereUniqueInput[]
    connect?: SubscriptionInvoiceWhereUniqueInput | SubscriptionInvoiceWhereUniqueInput[]
    update?: SubscriptionInvoiceUpdateWithWhereUniqueWithoutSubscriptionInput | SubscriptionInvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: SubscriptionInvoiceUpdateManyWithWhereWithoutSubscriptionInput | SubscriptionInvoiceUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: SubscriptionInvoiceScalarWhereInput | SubscriptionInvoiceScalarWhereInput[]
  }

  export type SubscriptionInvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<SubscriptionInvoiceCreateWithoutSubscriptionInput, SubscriptionInvoiceUncheckedCreateWithoutSubscriptionInput> | SubscriptionInvoiceCreateWithoutSubscriptionInput[] | SubscriptionInvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionInvoiceCreateOrConnectWithoutSubscriptionInput | SubscriptionInvoiceCreateOrConnectWithoutSubscriptionInput[]
    upsert?: SubscriptionInvoiceUpsertWithWhereUniqueWithoutSubscriptionInput | SubscriptionInvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: SubscriptionInvoiceCreateManySubscriptionInputEnvelope
    set?: SubscriptionInvoiceWhereUniqueInput | SubscriptionInvoiceWhereUniqueInput[]
    disconnect?: SubscriptionInvoiceWhereUniqueInput | SubscriptionInvoiceWhereUniqueInput[]
    delete?: SubscriptionInvoiceWhereUniqueInput | SubscriptionInvoiceWhereUniqueInput[]
    connect?: SubscriptionInvoiceWhereUniqueInput | SubscriptionInvoiceWhereUniqueInput[]
    update?: SubscriptionInvoiceUpdateWithWhereUniqueWithoutSubscriptionInput | SubscriptionInvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: SubscriptionInvoiceUpdateManyWithWhereWithoutSubscriptionInput | SubscriptionInvoiceUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: SubscriptionInvoiceScalarWhereInput | SubscriptionInvoiceScalarWhereInput[]
  }

  export type SubscriptionCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoicesInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type SubscriptionUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoicesInput
    upsert?: SubscriptionUpsertWithoutInvoicesInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutInvoicesInput, SubscriptionUpdateWithoutInvoicesInput>, SubscriptionUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserCreateNestedOneWithoutOwnedTeamsInput = {
    create?: XOR<UserCreateWithoutOwnedTeamsInput, UserUncheckedCreateWithoutOwnedTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedTeamsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutOwnedTeamsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedTeamsInput, UserUncheckedCreateWithoutOwnedTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedTeamsInput
    upsert?: UserUpsertWithoutOwnedTeamsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedTeamsInput, UserUpdateWithoutOwnedTeamsInput>, UserUncheckedUpdateWithoutOwnedTeamsInput>
  }

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamMembershipsInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutTeamMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    upsert?: UserUpsertWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamMembershipsInput, UserUpdateWithoutTeamMembershipsInput>, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumWorkflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusFilter<$PrismaModel> | $Enums.WorkflowStatus
  }

  export type NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStatusFilter<$PrismaModel>
  }

  export type NestedEnumLogLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelFilter<$PrismaModel> | $Enums.LogLevel
  }

  export type NestedEnumLogLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelWithAggregatesFilter<$PrismaModel> | $Enums.LogLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogLevelFilter<$PrismaModel>
    _max?: NestedEnumLogLevelFilter<$PrismaModel>
  }

  export type NestedEnumBlockStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BlockStatus | EnumBlockStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BlockStatus[] | ListEnumBlockStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlockStatus[] | ListEnumBlockStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBlockStatusFilter<$PrismaModel> | $Enums.BlockStatus
  }

  export type NestedEnumBlockStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BlockStatus | EnumBlockStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BlockStatus[] | ListEnumBlockStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlockStatus[] | ListEnumBlockStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBlockStatusWithAggregatesFilter<$PrismaModel> | $Enums.BlockStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBlockStatusFilter<$PrismaModel>
    _max?: NestedEnumBlockStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ProfileCreateWithoutUserInput = {
    email?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    subscriptionTier?: string | null
    subscriptionStatus?: string | null
    subscriptionExpiresAt?: Date | string | null
    monthlyExecutionQuota?: number | null
    monthlyExecutionCount?: number | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    monthlyExecutionsUsed?: number
    telegramChatId?: string | null
    discordWebhookUrl?: string | null
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    email?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    subscriptionTier?: string | null
    subscriptionStatus?: string | null
    subscriptionExpiresAt?: Date | string | null
    monthlyExecutionQuota?: number | null
    monthlyExecutionCount?: number | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    monthlyExecutionsUsed?: number
    telegramChatId?: string | null
    discordWebhookUrl?: string | null
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type UserWalletCreateWithoutUserInput = {
    id?: string
    chainId: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walletType?: string | null
    chainType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserWalletUncheckedCreateWithoutUserInput = {
    id?: string
    chainId: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walletType?: string | null
    chainType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserWalletCreateOrConnectWithoutUserInput = {
    where: UserWalletWhereUniqueInput
    create: XOR<UserWalletCreateWithoutUserInput, UserWalletUncheckedCreateWithoutUserInput>
  }

  export type UserWalletCreateManyUserInputEnvelope = {
    data: UserWalletCreateManyUserInput | UserWalletCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean | null
    tags?: WorkflowCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: number
    createdBy?: string | null
    executions?: WorkflowExecutionCreateNestedManyWithoutWorkflowInput
    pauses?: WorkflowPauseCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean | null
    tags?: WorkflowCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: number
    createdBy?: string | null
    executions?: WorkflowExecutionUncheckedCreateNestedManyWithoutWorkflowInput
    pauses?: WorkflowPauseUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowCreateOrConnectWithoutUserInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput>
  }

  export type WorkflowCreateManyUserInputEnvelope = {
    data: WorkflowCreateManyUserInput | WorkflowCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowExecutionCreateWithoutUserInput = {
    id?: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    workflow: WorkflowCreateNestedOneWithoutExecutionsInput
    nodeExecutions?: NodeExecutionCreateNestedManyWithoutExecutionInput
    executionLogs?: ExecutionLogCreateNestedManyWithoutExecutionInput
    blockExecutions?: BlockExecutionCreateNestedManyWithoutExecutionInput
    blockchainTransactions?: BlockchainTransactionCreateNestedManyWithoutExecutionInput
    workflowPauses?: WorkflowPauseCreateNestedManyWithoutExecutionInput
  }

  export type WorkflowExecutionUncheckedCreateWithoutUserInput = {
    id?: string
    workflowId: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    nodeExecutions?: NodeExecutionUncheckedCreateNestedManyWithoutExecutionInput
    executionLogs?: ExecutionLogUncheckedCreateNestedManyWithoutExecutionInput
    blockExecutions?: BlockExecutionUncheckedCreateNestedManyWithoutExecutionInput
    blockchainTransactions?: BlockchainTransactionUncheckedCreateNestedManyWithoutExecutionInput
    workflowPauses?: WorkflowPauseUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type WorkflowExecutionCreateOrConnectWithoutUserInput = {
    where: WorkflowExecutionWhereUniqueInput
    create: XOR<WorkflowExecutionCreateWithoutUserInput, WorkflowExecutionUncheckedCreateWithoutUserInput>
  }

  export type WorkflowExecutionCreateManyUserInputEnvelope = {
    data: WorkflowExecutionCreateManyUserInput | WorkflowExecutionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    read?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    read?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    stripeCustomerId?: string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tier: PricingTierCreateNestedOneWithoutSubscriptionsInput
    invoices?: SubscriptionInvoiceCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    tierId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    stripeCustomerId?: string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: SubscriptionInvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberCreateWithoutUserInput = {
    role: string
    joinedAt?: Date | string | null
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    teamId: string
    role: string
    joinedAt?: Date | string | null
  }

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: TeamMemberCreateManyUserInput | TeamMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutOwnerInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutOwnerInput, TeamUncheckedCreateWithoutOwnerInput>
  }

  export type TeamCreateManyOwnerInputEnvelope = {
    data: TeamCreateManyOwnerInput | TeamCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type NotificationPreferenceCreateWithoutUserInput = {
    id?: string
    emailEnabled?: boolean
    pushEnabled?: boolean
    webhookEnabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    telegramChatId?: string | null
    discordWebhookUrl?: string | null
  }

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    emailEnabled?: boolean
    pushEnabled?: boolean
    webhookEnabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    telegramChatId?: string | null
    discordWebhookUrl?: string | null
  }

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyExecutionQuota?: NullableIntFieldUpdateOperationsInput | number | null
    monthlyExecutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyExecutionsUsed?: IntFieldUpdateOperationsInput | number
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    discordWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyExecutionQuota?: NullableIntFieldUpdateOperationsInput | number | null
    monthlyExecutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyExecutionsUsed?: IntFieldUpdateOperationsInput | number
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    discordWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserWalletUpsertWithWhereUniqueWithoutUserInput = {
    where: UserWalletWhereUniqueInput
    update: XOR<UserWalletUpdateWithoutUserInput, UserWalletUncheckedUpdateWithoutUserInput>
    create: XOR<UserWalletCreateWithoutUserInput, UserWalletUncheckedCreateWithoutUserInput>
  }

  export type UserWalletUpdateWithWhereUniqueWithoutUserInput = {
    where: UserWalletWhereUniqueInput
    data: XOR<UserWalletUpdateWithoutUserInput, UserWalletUncheckedUpdateWithoutUserInput>
  }

  export type UserWalletUpdateManyWithWhereWithoutUserInput = {
    where: UserWalletScalarWhereInput
    data: XOR<UserWalletUpdateManyMutationInput, UserWalletUncheckedUpdateManyWithoutUserInput>
  }

  export type UserWalletScalarWhereInput = {
    AND?: UserWalletScalarWhereInput | UserWalletScalarWhereInput[]
    OR?: UserWalletScalarWhereInput[]
    NOT?: UserWalletScalarWhereInput | UserWalletScalarWhereInput[]
    id?: StringFilter<"UserWallet"> | string
    userId?: StringFilter<"UserWallet"> | string
    chainId?: StringFilter<"UserWallet"> | string
    walletAddress?: StringFilter<"UserWallet"> | string
    createdAt?: DateTimeFilter<"UserWallet"> | Date | string
    updatedAt?: DateTimeFilter<"UserWallet"> | Date | string
    walletType?: StringNullableFilter<"UserWallet"> | string | null
    chainType?: StringNullableFilter<"UserWallet"> | string | null
    metadata?: JsonNullableFilter<"UserWallet">
  }

  export type WorkflowUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutUserInput, WorkflowUncheckedUpdateWithoutUserInput>
    create: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutUserInput, WorkflowUncheckedUpdateWithoutUserInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutUserInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkflowScalarWhereInput = {
    AND?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
    OR?: WorkflowScalarWhereInput[]
    NOT?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
    id?: StringFilter<"Workflow"> | string
    userId?: StringFilter<"Workflow"> | string
    name?: StringFilter<"Workflow"> | string
    description?: StringNullableFilter<"Workflow"> | string | null
    nodes?: JsonNullableFilter<"Workflow">
    edges?: JsonNullableFilter<"Workflow">
    isPublic?: BoolNullableFilter<"Workflow"> | boolean | null
    tags?: StringNullableListFilter<"Workflow">
    createdAt?: DateTimeNullableFilter<"Workflow"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Workflow"> | Date | string | null
    definition?: JsonFilter<"Workflow">
    version?: IntFilter<"Workflow"> | number
    createdBy?: StringNullableFilter<"Workflow"> | string | null
  }

  export type WorkflowExecutionUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkflowExecutionWhereUniqueInput
    update: XOR<WorkflowExecutionUpdateWithoutUserInput, WorkflowExecutionUncheckedUpdateWithoutUserInput>
    create: XOR<WorkflowExecutionCreateWithoutUserInput, WorkflowExecutionUncheckedCreateWithoutUserInput>
  }

  export type WorkflowExecutionUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkflowExecutionWhereUniqueInput
    data: XOR<WorkflowExecutionUpdateWithoutUserInput, WorkflowExecutionUncheckedUpdateWithoutUserInput>
  }

  export type WorkflowExecutionUpdateManyWithWhereWithoutUserInput = {
    where: WorkflowExecutionScalarWhereInput
    data: XOR<WorkflowExecutionUpdateManyMutationInput, WorkflowExecutionUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkflowExecutionScalarWhereInput = {
    AND?: WorkflowExecutionScalarWhereInput | WorkflowExecutionScalarWhereInput[]
    OR?: WorkflowExecutionScalarWhereInput[]
    NOT?: WorkflowExecutionScalarWhereInput | WorkflowExecutionScalarWhereInput[]
    id?: StringFilter<"WorkflowExecution"> | string
    workflowId?: StringFilter<"WorkflowExecution"> | string
    userId?: StringFilter<"WorkflowExecution"> | string
    status?: EnumWorkflowStatusFilter<"WorkflowExecution"> | $Enums.WorkflowStatus
    input?: JsonNullableFilter<"WorkflowExecution">
    output?: JsonNullableFilter<"WorkflowExecution">
    startedAt?: DateTimeFilter<"WorkflowExecution"> | Date | string
    finishedAt?: DateTimeNullableFilter<"WorkflowExecution"> | Date | string | null
    error?: StringNullableFilter<"WorkflowExecution"> | string | null
    metadata?: JsonNullableFilter<"WorkflowExecution">
    createdAt?: DateTimeFilter<"WorkflowExecution"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowExecution"> | Date | string
    triggerType?: StringNullableFilter<"WorkflowExecution"> | string | null
    triggerData?: JsonNullableFilter<"WorkflowExecution">
    lockedBy?: StringNullableFilter<"WorkflowExecution"> | string | null
    logs?: JsonNullableFilter<"WorkflowExecution">
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }

  export type SubscriptionUpsertWithoutUserInput = {
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutUserInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: PricingTierUpdateOneRequiredWithoutSubscriptionsNestedInput
    invoices?: SubscriptionInvoiceUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tierId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: SubscriptionInvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    OR?: TeamMemberScalarWhereInput[]
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    role?: StringFilter<"TeamMember"> | string
    joinedAt?: DateTimeNullableFilter<"TeamMember"> | Date | string | null
  }

  export type TeamUpsertWithWhereUniqueWithoutOwnerInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutOwnerInput, TeamUncheckedUpdateWithoutOwnerInput>
    create: XOR<TeamCreateWithoutOwnerInput, TeamUncheckedCreateWithoutOwnerInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutOwnerInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutOwnerInput, TeamUncheckedUpdateWithoutOwnerInput>
  }

  export type TeamUpdateManyWithWhereWithoutOwnerInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutOwnerInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    createdBy?: StringFilter<"Team"> | string
    createdAt?: DateTimeNullableFilter<"Team"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Team"> | Date | string | null
  }

  export type NotificationPreferenceUpsertWithoutUserInput = {
    update: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    where?: NotificationPreferenceWhereInput
  }

  export type NotificationPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPreferenceWhereInput
    data: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    webhookEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    discordWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    webhookEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    discordWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userWallets?: UserWalletCreateNestedManyWithoutUserInput
    workflows?: WorkflowCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    ownedTeams?: TeamCreateNestedManyWithoutOwnerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userWallets?: UserWalletUncheckedCreateNestedManyWithoutUserInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    ownedTeams?: TeamUncheckedCreateNestedManyWithoutOwnerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userWallets?: UserWalletUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    ownedTeams?: TeamUpdateManyWithoutOwnerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userWallets?: UserWalletUncheckedUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedTeams?: TeamUncheckedUpdateManyWithoutOwnerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutUserWalletsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    workflows?: WorkflowCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    ownedTeams?: TeamCreateNestedManyWithoutOwnerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserWalletsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    ownedTeams?: TeamUncheckedCreateNestedManyWithoutOwnerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserWalletsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserWalletsInput, UserUncheckedCreateWithoutUserWalletsInput>
  }

  export type UserUpsertWithoutUserWalletsInput = {
    update: XOR<UserUpdateWithoutUserWalletsInput, UserUncheckedUpdateWithoutUserWalletsInput>
    create: XOR<UserCreateWithoutUserWalletsInput, UserUncheckedCreateWithoutUserWalletsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserWalletsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserWalletsInput, UserUncheckedUpdateWithoutUserWalletsInput>
  }

  export type UserUpdateWithoutUserWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    workflows?: WorkflowUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    ownedTeams?: TeamUpdateManyWithoutOwnerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedTeams?: TeamUncheckedUpdateManyWithoutOwnerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutWorkflowsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    userWallets?: UserWalletCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    ownedTeams?: TeamCreateNestedManyWithoutOwnerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    userWallets?: UserWalletUncheckedCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    ownedTeams?: TeamUncheckedCreateNestedManyWithoutOwnerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkflowsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>
  }

  export type WorkflowExecutionCreateWithoutWorkflowInput = {
    id?: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutWorkflowExecutionsInput
    nodeExecutions?: NodeExecutionCreateNestedManyWithoutExecutionInput
    executionLogs?: ExecutionLogCreateNestedManyWithoutExecutionInput
    blockExecutions?: BlockExecutionCreateNestedManyWithoutExecutionInput
    blockchainTransactions?: BlockchainTransactionCreateNestedManyWithoutExecutionInput
    workflowPauses?: WorkflowPauseCreateNestedManyWithoutExecutionInput
  }

  export type WorkflowExecutionUncheckedCreateWithoutWorkflowInput = {
    id?: string
    userId: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    nodeExecutions?: NodeExecutionUncheckedCreateNestedManyWithoutExecutionInput
    executionLogs?: ExecutionLogUncheckedCreateNestedManyWithoutExecutionInput
    blockExecutions?: BlockExecutionUncheckedCreateNestedManyWithoutExecutionInput
    blockchainTransactions?: BlockchainTransactionUncheckedCreateNestedManyWithoutExecutionInput
    workflowPauses?: WorkflowPauseUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type WorkflowExecutionCreateOrConnectWithoutWorkflowInput = {
    where: WorkflowExecutionWhereUniqueInput
    create: XOR<WorkflowExecutionCreateWithoutWorkflowInput, WorkflowExecutionUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowExecutionCreateManyWorkflowInputEnvelope = {
    data: WorkflowExecutionCreateManyWorkflowInput | WorkflowExecutionCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowPauseCreateWithoutWorkflowInput = {
    id?: string
    nodeId: string
    reason: string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    execution: WorkflowExecutionCreateNestedOneWithoutWorkflowPausesInput
  }

  export type WorkflowPauseUncheckedCreateWithoutWorkflowInput = {
    id?: string
    executionId: string
    nodeId: string
    reason: string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowPauseCreateOrConnectWithoutWorkflowInput = {
    where: WorkflowPauseWhereUniqueInput
    create: XOR<WorkflowPauseCreateWithoutWorkflowInput, WorkflowPauseUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowPauseCreateManyWorkflowInputEnvelope = {
    data: WorkflowPauseCreateManyWorkflowInput | WorkflowPauseCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWorkflowsInput = {
    update: XOR<UserUpdateWithoutWorkflowsInput, UserUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkflowsInput, UserUncheckedUpdateWithoutWorkflowsInput>
  }

  export type UserUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    userWallets?: UserWalletUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    ownedTeams?: TeamUpdateManyWithoutOwnerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    userWallets?: UserWalletUncheckedUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedTeams?: TeamUncheckedUpdateManyWithoutOwnerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type WorkflowExecutionUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowExecutionWhereUniqueInput
    update: XOR<WorkflowExecutionUpdateWithoutWorkflowInput, WorkflowExecutionUncheckedUpdateWithoutWorkflowInput>
    create: XOR<WorkflowExecutionCreateWithoutWorkflowInput, WorkflowExecutionUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowExecutionUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowExecutionWhereUniqueInput
    data: XOR<WorkflowExecutionUpdateWithoutWorkflowInput, WorkflowExecutionUncheckedUpdateWithoutWorkflowInput>
  }

  export type WorkflowExecutionUpdateManyWithWhereWithoutWorkflowInput = {
    where: WorkflowExecutionScalarWhereInput
    data: XOR<WorkflowExecutionUpdateManyMutationInput, WorkflowExecutionUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type WorkflowPauseUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowPauseWhereUniqueInput
    update: XOR<WorkflowPauseUpdateWithoutWorkflowInput, WorkflowPauseUncheckedUpdateWithoutWorkflowInput>
    create: XOR<WorkflowPauseCreateWithoutWorkflowInput, WorkflowPauseUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowPauseUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowPauseWhereUniqueInput
    data: XOR<WorkflowPauseUpdateWithoutWorkflowInput, WorkflowPauseUncheckedUpdateWithoutWorkflowInput>
  }

  export type WorkflowPauseUpdateManyWithWhereWithoutWorkflowInput = {
    where: WorkflowPauseScalarWhereInput
    data: XOR<WorkflowPauseUpdateManyMutationInput, WorkflowPauseUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type WorkflowPauseScalarWhereInput = {
    AND?: WorkflowPauseScalarWhereInput | WorkflowPauseScalarWhereInput[]
    OR?: WorkflowPauseScalarWhereInput[]
    NOT?: WorkflowPauseScalarWhereInput | WorkflowPauseScalarWhereInput[]
    id?: StringFilter<"WorkflowPause"> | string
    workflowId?: StringFilter<"WorkflowPause"> | string
    executionId?: StringFilter<"WorkflowPause"> | string
    nodeId?: StringFilter<"WorkflowPause"> | string
    reason?: StringFilter<"WorkflowPause"> | string
    resumeData?: JsonNullableFilter<"WorkflowPause">
    createdAt?: DateTimeFilter<"WorkflowPause"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowPause"> | Date | string
  }

  export type WorkflowCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean | null
    tags?: WorkflowCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: number
    createdBy?: string | null
    user: UserCreateNestedOneWithoutWorkflowsInput
    pauses?: WorkflowPauseCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowUncheckedCreateWithoutExecutionsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean | null
    tags?: WorkflowCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: number
    createdBy?: string | null
    pauses?: WorkflowPauseUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowCreateOrConnectWithoutExecutionsInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutExecutionsInput, WorkflowUncheckedCreateWithoutExecutionsInput>
  }

  export type UserCreateWithoutWorkflowExecutionsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    userWallets?: UserWalletCreateNestedManyWithoutUserInput
    workflows?: WorkflowCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    ownedTeams?: TeamCreateNestedManyWithoutOwnerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkflowExecutionsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    userWallets?: UserWalletUncheckedCreateNestedManyWithoutUserInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    ownedTeams?: TeamUncheckedCreateNestedManyWithoutOwnerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkflowExecutionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkflowExecutionsInput, UserUncheckedCreateWithoutWorkflowExecutionsInput>
  }

  export type NodeExecutionCreateWithoutExecutionInput = {
    id?: string
    nodeId: string
    status: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string
    durationMs?: number | null
    updatedAt?: Date | string | null
    retryCount?: number | null
    finishedAt?: Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    logs?: NodeLogCreateNestedManyWithoutNodeExecutionInput
    nodeInputs?: NodeInputCreateNestedManyWithoutNodeExecutionInput
    nodeOutputs?: NodeOutputCreateNestedManyWithoutNodeExecutionInput
  }

  export type NodeExecutionUncheckedCreateWithoutExecutionInput = {
    id?: string
    nodeId: string
    status: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string
    durationMs?: number | null
    updatedAt?: Date | string | null
    retryCount?: number | null
    finishedAt?: Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    logs?: NodeLogUncheckedCreateNestedManyWithoutNodeExecutionInput
    nodeInputs?: NodeInputUncheckedCreateNestedManyWithoutNodeExecutionInput
    nodeOutputs?: NodeOutputUncheckedCreateNestedManyWithoutNodeExecutionInput
  }

  export type NodeExecutionCreateOrConnectWithoutExecutionInput = {
    where: NodeExecutionWhereUniqueInput
    create: XOR<NodeExecutionCreateWithoutExecutionInput, NodeExecutionUncheckedCreateWithoutExecutionInput>
  }

  export type NodeExecutionCreateManyExecutionInputEnvelope = {
    data: NodeExecutionCreateManyExecutionInput | NodeExecutionCreateManyExecutionInput[]
    skipDuplicates?: boolean
  }

  export type ExecutionLogCreateWithoutExecutionInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionLogUncheckedCreateWithoutExecutionInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionLogCreateOrConnectWithoutExecutionInput = {
    where: ExecutionLogWhereUniqueInput
    create: XOR<ExecutionLogCreateWithoutExecutionInput, ExecutionLogUncheckedCreateWithoutExecutionInput>
  }

  export type ExecutionLogCreateManyExecutionInputEnvelope = {
    data: ExecutionLogCreateManyExecutionInput | ExecutionLogCreateManyExecutionInput[]
    skipDuplicates?: boolean
  }

  export type BlockExecutionCreateWithoutExecutionInput = {
    id?: string
    nodeId: string
    blockType: string
    status: $Enums.BlockStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    logs?: BlockExecutionLogCreateNestedManyWithoutBlockExecutionInput
  }

  export type BlockExecutionUncheckedCreateWithoutExecutionInput = {
    id?: string
    nodeId: string
    blockType: string
    status: $Enums.BlockStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    logs?: BlockExecutionLogUncheckedCreateNestedManyWithoutBlockExecutionInput
  }

  export type BlockExecutionCreateOrConnectWithoutExecutionInput = {
    where: BlockExecutionWhereUniqueInput
    create: XOR<BlockExecutionCreateWithoutExecutionInput, BlockExecutionUncheckedCreateWithoutExecutionInput>
  }

  export type BlockExecutionCreateManyExecutionInputEnvelope = {
    data: BlockExecutionCreateManyExecutionInput | BlockExecutionCreateManyExecutionInput[]
    skipDuplicates?: boolean
  }

  export type BlockchainTransactionCreateWithoutExecutionInput = {
    id?: string
    nodeId: string
    toAddress: string
    value: string
    data?: NullableJsonNullValueInput | InputJsonValue
    chainId: number
    gasLimit?: string | null
    gasUsed?: string | null
    maxFeePerGas?: string | null
    maxPriorityFeePerGas?: string | null
    nonce?: number | null
    status: string
    hash?: string | null
    txHash?: string | null
    blockNumber?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    walletAddress: string
    effectiveGasPrice?: string | null
    error?: string | null
    fromAddress?: string | null
    transactionAttempts?: TransactionAttemptCreateNestedManyWithoutTransactionInput
  }

  export type BlockchainTransactionUncheckedCreateWithoutExecutionInput = {
    id?: string
    nodeId: string
    toAddress: string
    value: string
    data?: NullableJsonNullValueInput | InputJsonValue
    chainId: number
    gasLimit?: string | null
    gasUsed?: string | null
    maxFeePerGas?: string | null
    maxPriorityFeePerGas?: string | null
    nonce?: number | null
    status: string
    hash?: string | null
    txHash?: string | null
    blockNumber?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    walletAddress: string
    effectiveGasPrice?: string | null
    error?: string | null
    fromAddress?: string | null
    transactionAttempts?: TransactionAttemptUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type BlockchainTransactionCreateOrConnectWithoutExecutionInput = {
    where: BlockchainTransactionWhereUniqueInput
    create: XOR<BlockchainTransactionCreateWithoutExecutionInput, BlockchainTransactionUncheckedCreateWithoutExecutionInput>
  }

  export type BlockchainTransactionCreateManyExecutionInputEnvelope = {
    data: BlockchainTransactionCreateManyExecutionInput | BlockchainTransactionCreateManyExecutionInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowPauseCreateWithoutExecutionInput = {
    id?: string
    nodeId: string
    reason: string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: WorkflowCreateNestedOneWithoutPausesInput
  }

  export type WorkflowPauseUncheckedCreateWithoutExecutionInput = {
    id?: string
    workflowId: string
    nodeId: string
    reason: string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowPauseCreateOrConnectWithoutExecutionInput = {
    where: WorkflowPauseWhereUniqueInput
    create: XOR<WorkflowPauseCreateWithoutExecutionInput, WorkflowPauseUncheckedCreateWithoutExecutionInput>
  }

  export type WorkflowPauseCreateManyExecutionInputEnvelope = {
    data: WorkflowPauseCreateManyExecutionInput | WorkflowPauseCreateManyExecutionInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowUpsertWithoutExecutionsInput = {
    update: XOR<WorkflowUpdateWithoutExecutionsInput, WorkflowUncheckedUpdateWithoutExecutionsInput>
    create: XOR<WorkflowCreateWithoutExecutionsInput, WorkflowUncheckedCreateWithoutExecutionsInput>
    where?: WorkflowWhereInput
  }

  export type WorkflowUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: WorkflowWhereInput
    data: XOR<WorkflowUpdateWithoutExecutionsInput, WorkflowUncheckedUpdateWithoutExecutionsInput>
  }

  export type WorkflowUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: WorkflowUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutWorkflowsNestedInput
    pauses?: WorkflowPauseUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: WorkflowUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    pauses?: WorkflowPauseUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type UserUpsertWithoutWorkflowExecutionsInput = {
    update: XOR<UserUpdateWithoutWorkflowExecutionsInput, UserUncheckedUpdateWithoutWorkflowExecutionsInput>
    create: XOR<UserCreateWithoutWorkflowExecutionsInput, UserUncheckedCreateWithoutWorkflowExecutionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkflowExecutionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkflowExecutionsInput, UserUncheckedUpdateWithoutWorkflowExecutionsInput>
  }

  export type UserUpdateWithoutWorkflowExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    userWallets?: UserWalletUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    ownedTeams?: TeamUpdateManyWithoutOwnerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkflowExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    userWallets?: UserWalletUncheckedUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedTeams?: TeamUncheckedUpdateManyWithoutOwnerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type NodeExecutionUpsertWithWhereUniqueWithoutExecutionInput = {
    where: NodeExecutionWhereUniqueInput
    update: XOR<NodeExecutionUpdateWithoutExecutionInput, NodeExecutionUncheckedUpdateWithoutExecutionInput>
    create: XOR<NodeExecutionCreateWithoutExecutionInput, NodeExecutionUncheckedCreateWithoutExecutionInput>
  }

  export type NodeExecutionUpdateWithWhereUniqueWithoutExecutionInput = {
    where: NodeExecutionWhereUniqueInput
    data: XOR<NodeExecutionUpdateWithoutExecutionInput, NodeExecutionUncheckedUpdateWithoutExecutionInput>
  }

  export type NodeExecutionUpdateManyWithWhereWithoutExecutionInput = {
    where: NodeExecutionScalarWhereInput
    data: XOR<NodeExecutionUpdateManyMutationInput, NodeExecutionUncheckedUpdateManyWithoutExecutionInput>
  }

  export type NodeExecutionScalarWhereInput = {
    AND?: NodeExecutionScalarWhereInput | NodeExecutionScalarWhereInput[]
    OR?: NodeExecutionScalarWhereInput[]
    NOT?: NodeExecutionScalarWhereInput | NodeExecutionScalarWhereInput[]
    id?: StringFilter<"NodeExecution"> | string
    executionId?: StringFilter<"NodeExecution"> | string
    nodeId?: StringFilter<"NodeExecution"> | string
    status?: StringFilter<"NodeExecution"> | string
    outputData?: JsonNullableFilter<"NodeExecution">
    error?: StringNullableFilter<"NodeExecution"> | string | null
    startedAt?: DateTimeFilter<"NodeExecution"> | Date | string
    completedAt?: DateTimeFilter<"NodeExecution"> | Date | string
    durationMs?: IntNullableFilter<"NodeExecution"> | number | null
    updatedAt?: DateTimeNullableFilter<"NodeExecution"> | Date | string | null
    retryCount?: IntNullableFilter<"NodeExecution"> | number | null
    finishedAt?: DateTimeNullableFilter<"NodeExecution"> | Date | string | null
    output?: JsonNullableFilter<"NodeExecution">
  }

  export type ExecutionLogUpsertWithWhereUniqueWithoutExecutionInput = {
    where: ExecutionLogWhereUniqueInput
    update: XOR<ExecutionLogUpdateWithoutExecutionInput, ExecutionLogUncheckedUpdateWithoutExecutionInput>
    create: XOR<ExecutionLogCreateWithoutExecutionInput, ExecutionLogUncheckedCreateWithoutExecutionInput>
  }

  export type ExecutionLogUpdateWithWhereUniqueWithoutExecutionInput = {
    where: ExecutionLogWhereUniqueInput
    data: XOR<ExecutionLogUpdateWithoutExecutionInput, ExecutionLogUncheckedUpdateWithoutExecutionInput>
  }

  export type ExecutionLogUpdateManyWithWhereWithoutExecutionInput = {
    where: ExecutionLogScalarWhereInput
    data: XOR<ExecutionLogUpdateManyMutationInput, ExecutionLogUncheckedUpdateManyWithoutExecutionInput>
  }

  export type ExecutionLogScalarWhereInput = {
    AND?: ExecutionLogScalarWhereInput | ExecutionLogScalarWhereInput[]
    OR?: ExecutionLogScalarWhereInput[]
    NOT?: ExecutionLogScalarWhereInput | ExecutionLogScalarWhereInput[]
    id?: StringFilter<"ExecutionLog"> | string
    executionId?: StringFilter<"ExecutionLog"> | string
    level?: EnumLogLevelFilter<"ExecutionLog"> | $Enums.LogLevel
    message?: StringFilter<"ExecutionLog"> | string
    timestamp?: DateTimeFilter<"ExecutionLog"> | Date | string
    metadata?: JsonNullableFilter<"ExecutionLog">
  }

  export type BlockExecutionUpsertWithWhereUniqueWithoutExecutionInput = {
    where: BlockExecutionWhereUniqueInput
    update: XOR<BlockExecutionUpdateWithoutExecutionInput, BlockExecutionUncheckedUpdateWithoutExecutionInput>
    create: XOR<BlockExecutionCreateWithoutExecutionInput, BlockExecutionUncheckedCreateWithoutExecutionInput>
  }

  export type BlockExecutionUpdateWithWhereUniqueWithoutExecutionInput = {
    where: BlockExecutionWhereUniqueInput
    data: XOR<BlockExecutionUpdateWithoutExecutionInput, BlockExecutionUncheckedUpdateWithoutExecutionInput>
  }

  export type BlockExecutionUpdateManyWithWhereWithoutExecutionInput = {
    where: BlockExecutionScalarWhereInput
    data: XOR<BlockExecutionUpdateManyMutationInput, BlockExecutionUncheckedUpdateManyWithoutExecutionInput>
  }

  export type BlockExecutionScalarWhereInput = {
    AND?: BlockExecutionScalarWhereInput | BlockExecutionScalarWhereInput[]
    OR?: BlockExecutionScalarWhereInput[]
    NOT?: BlockExecutionScalarWhereInput | BlockExecutionScalarWhereInput[]
    id?: StringFilter<"BlockExecution"> | string
    executionId?: StringFilter<"BlockExecution"> | string
    nodeId?: StringFilter<"BlockExecution"> | string
    blockType?: StringFilter<"BlockExecution"> | string
    status?: EnumBlockStatusFilter<"BlockExecution"> | $Enums.BlockStatus
    input?: JsonNullableFilter<"BlockExecution">
    output?: JsonNullableFilter<"BlockExecution">
    error?: StringNullableFilter<"BlockExecution"> | string | null
    startTime?: DateTimeFilter<"BlockExecution"> | Date | string
    endTime?: DateTimeNullableFilter<"BlockExecution"> | Date | string | null
  }

  export type BlockchainTransactionUpsertWithWhereUniqueWithoutExecutionInput = {
    where: BlockchainTransactionWhereUniqueInput
    update: XOR<BlockchainTransactionUpdateWithoutExecutionInput, BlockchainTransactionUncheckedUpdateWithoutExecutionInput>
    create: XOR<BlockchainTransactionCreateWithoutExecutionInput, BlockchainTransactionUncheckedCreateWithoutExecutionInput>
  }

  export type BlockchainTransactionUpdateWithWhereUniqueWithoutExecutionInput = {
    where: BlockchainTransactionWhereUniqueInput
    data: XOR<BlockchainTransactionUpdateWithoutExecutionInput, BlockchainTransactionUncheckedUpdateWithoutExecutionInput>
  }

  export type BlockchainTransactionUpdateManyWithWhereWithoutExecutionInput = {
    where: BlockchainTransactionScalarWhereInput
    data: XOR<BlockchainTransactionUpdateManyMutationInput, BlockchainTransactionUncheckedUpdateManyWithoutExecutionInput>
  }

  export type BlockchainTransactionScalarWhereInput = {
    AND?: BlockchainTransactionScalarWhereInput | BlockchainTransactionScalarWhereInput[]
    OR?: BlockchainTransactionScalarWhereInput[]
    NOT?: BlockchainTransactionScalarWhereInput | BlockchainTransactionScalarWhereInput[]
    id?: StringFilter<"BlockchainTransaction"> | string
    nodeId?: StringFilter<"BlockchainTransaction"> | string
    executionId?: StringFilter<"BlockchainTransaction"> | string
    toAddress?: StringFilter<"BlockchainTransaction"> | string
    value?: StringFilter<"BlockchainTransaction"> | string
    data?: JsonNullableFilter<"BlockchainTransaction">
    chainId?: IntFilter<"BlockchainTransaction"> | number
    gasLimit?: StringNullableFilter<"BlockchainTransaction"> | string | null
    gasUsed?: StringNullableFilter<"BlockchainTransaction"> | string | null
    maxFeePerGas?: StringNullableFilter<"BlockchainTransaction"> | string | null
    maxPriorityFeePerGas?: StringNullableFilter<"BlockchainTransaction"> | string | null
    nonce?: IntNullableFilter<"BlockchainTransaction"> | number | null
    status?: StringFilter<"BlockchainTransaction"> | string
    hash?: StringNullableFilter<"BlockchainTransaction"> | string | null
    txHash?: StringNullableFilter<"BlockchainTransaction"> | string | null
    blockNumber?: IntNullableFilter<"BlockchainTransaction"> | number | null
    createdAt?: DateTimeFilter<"BlockchainTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BlockchainTransaction"> | Date | string
    userId?: StringNullableFilter<"BlockchainTransaction"> | string | null
    walletAddress?: StringFilter<"BlockchainTransaction"> | string
    effectiveGasPrice?: StringNullableFilter<"BlockchainTransaction"> | string | null
    error?: StringNullableFilter<"BlockchainTransaction"> | string | null
    fromAddress?: StringNullableFilter<"BlockchainTransaction"> | string | null
  }

  export type WorkflowPauseUpsertWithWhereUniqueWithoutExecutionInput = {
    where: WorkflowPauseWhereUniqueInput
    update: XOR<WorkflowPauseUpdateWithoutExecutionInput, WorkflowPauseUncheckedUpdateWithoutExecutionInput>
    create: XOR<WorkflowPauseCreateWithoutExecutionInput, WorkflowPauseUncheckedCreateWithoutExecutionInput>
  }

  export type WorkflowPauseUpdateWithWhereUniqueWithoutExecutionInput = {
    where: WorkflowPauseWhereUniqueInput
    data: XOR<WorkflowPauseUpdateWithoutExecutionInput, WorkflowPauseUncheckedUpdateWithoutExecutionInput>
  }

  export type WorkflowPauseUpdateManyWithWhereWithoutExecutionInput = {
    where: WorkflowPauseScalarWhereInput
    data: XOR<WorkflowPauseUpdateManyMutationInput, WorkflowPauseUncheckedUpdateManyWithoutExecutionInput>
  }

  export type WorkflowExecutionCreateWithoutNodeExecutionsInput = {
    id?: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    workflow: WorkflowCreateNestedOneWithoutExecutionsInput
    user: UserCreateNestedOneWithoutWorkflowExecutionsInput
    executionLogs?: ExecutionLogCreateNestedManyWithoutExecutionInput
    blockExecutions?: BlockExecutionCreateNestedManyWithoutExecutionInput
    blockchainTransactions?: BlockchainTransactionCreateNestedManyWithoutExecutionInput
    workflowPauses?: WorkflowPauseCreateNestedManyWithoutExecutionInput
  }

  export type WorkflowExecutionUncheckedCreateWithoutNodeExecutionsInput = {
    id?: string
    workflowId: string
    userId: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    executionLogs?: ExecutionLogUncheckedCreateNestedManyWithoutExecutionInput
    blockExecutions?: BlockExecutionUncheckedCreateNestedManyWithoutExecutionInput
    blockchainTransactions?: BlockchainTransactionUncheckedCreateNestedManyWithoutExecutionInput
    workflowPauses?: WorkflowPauseUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type WorkflowExecutionCreateOrConnectWithoutNodeExecutionsInput = {
    where: WorkflowExecutionWhereUniqueInput
    create: XOR<WorkflowExecutionCreateWithoutNodeExecutionsInput, WorkflowExecutionUncheckedCreateWithoutNodeExecutionsInput>
  }

  export type NodeLogCreateWithoutNodeExecutionInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NodeLogUncheckedCreateWithoutNodeExecutionInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NodeLogCreateOrConnectWithoutNodeExecutionInput = {
    where: NodeLogWhereUniqueInput
    create: XOR<NodeLogCreateWithoutNodeExecutionInput, NodeLogUncheckedCreateWithoutNodeExecutionInput>
  }

  export type NodeLogCreateManyNodeExecutionInputEnvelope = {
    data: NodeLogCreateManyNodeExecutionInput | NodeLogCreateManyNodeExecutionInput[]
    skipDuplicates?: boolean
  }

  export type NodeInputCreateWithoutNodeExecutionInput = {
    id?: string
    inputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type NodeInputUncheckedCreateWithoutNodeExecutionInput = {
    id?: string
    inputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type NodeInputCreateOrConnectWithoutNodeExecutionInput = {
    where: NodeInputWhereUniqueInput
    create: XOR<NodeInputCreateWithoutNodeExecutionInput, NodeInputUncheckedCreateWithoutNodeExecutionInput>
  }

  export type NodeInputCreateManyNodeExecutionInputEnvelope = {
    data: NodeInputCreateManyNodeExecutionInput | NodeInputCreateManyNodeExecutionInput[]
    skipDuplicates?: boolean
  }

  export type NodeOutputCreateWithoutNodeExecutionInput = {
    id?: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type NodeOutputUncheckedCreateWithoutNodeExecutionInput = {
    id?: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type NodeOutputCreateOrConnectWithoutNodeExecutionInput = {
    where: NodeOutputWhereUniqueInput
    create: XOR<NodeOutputCreateWithoutNodeExecutionInput, NodeOutputUncheckedCreateWithoutNodeExecutionInput>
  }

  export type NodeOutputCreateManyNodeExecutionInputEnvelope = {
    data: NodeOutputCreateManyNodeExecutionInput | NodeOutputCreateManyNodeExecutionInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowExecutionUpsertWithoutNodeExecutionsInput = {
    update: XOR<WorkflowExecutionUpdateWithoutNodeExecutionsInput, WorkflowExecutionUncheckedUpdateWithoutNodeExecutionsInput>
    create: XOR<WorkflowExecutionCreateWithoutNodeExecutionsInput, WorkflowExecutionUncheckedCreateWithoutNodeExecutionsInput>
    where?: WorkflowExecutionWhereInput
  }

  export type WorkflowExecutionUpdateToOneWithWhereWithoutNodeExecutionsInput = {
    where?: WorkflowExecutionWhereInput
    data: XOR<WorkflowExecutionUpdateWithoutNodeExecutionsInput, WorkflowExecutionUncheckedUpdateWithoutNodeExecutionsInput>
  }

  export type WorkflowExecutionUpdateWithoutNodeExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    workflow?: WorkflowUpdateOneRequiredWithoutExecutionsNestedInput
    user?: UserUpdateOneRequiredWithoutWorkflowExecutionsNestedInput
    executionLogs?: ExecutionLogUpdateManyWithoutExecutionNestedInput
    blockExecutions?: BlockExecutionUpdateManyWithoutExecutionNestedInput
    blockchainTransactions?: BlockchainTransactionUpdateManyWithoutExecutionNestedInput
    workflowPauses?: WorkflowPauseUpdateManyWithoutExecutionNestedInput
  }

  export type WorkflowExecutionUncheckedUpdateWithoutNodeExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    executionLogs?: ExecutionLogUncheckedUpdateManyWithoutExecutionNestedInput
    blockExecutions?: BlockExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    blockchainTransactions?: BlockchainTransactionUncheckedUpdateManyWithoutExecutionNestedInput
    workflowPauses?: WorkflowPauseUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type NodeLogUpsertWithWhereUniqueWithoutNodeExecutionInput = {
    where: NodeLogWhereUniqueInput
    update: XOR<NodeLogUpdateWithoutNodeExecutionInput, NodeLogUncheckedUpdateWithoutNodeExecutionInput>
    create: XOR<NodeLogCreateWithoutNodeExecutionInput, NodeLogUncheckedCreateWithoutNodeExecutionInput>
  }

  export type NodeLogUpdateWithWhereUniqueWithoutNodeExecutionInput = {
    where: NodeLogWhereUniqueInput
    data: XOR<NodeLogUpdateWithoutNodeExecutionInput, NodeLogUncheckedUpdateWithoutNodeExecutionInput>
  }

  export type NodeLogUpdateManyWithWhereWithoutNodeExecutionInput = {
    where: NodeLogScalarWhereInput
    data: XOR<NodeLogUpdateManyMutationInput, NodeLogUncheckedUpdateManyWithoutNodeExecutionInput>
  }

  export type NodeLogScalarWhereInput = {
    AND?: NodeLogScalarWhereInput | NodeLogScalarWhereInput[]
    OR?: NodeLogScalarWhereInput[]
    NOT?: NodeLogScalarWhereInput | NodeLogScalarWhereInput[]
    id?: StringFilter<"NodeLog"> | string
    nodeExecutionId?: StringFilter<"NodeLog"> | string
    level?: EnumLogLevelFilter<"NodeLog"> | $Enums.LogLevel
    message?: StringFilter<"NodeLog"> | string
    createdAt?: DateTimeFilter<"NodeLog"> | Date | string
    metadata?: JsonNullableFilter<"NodeLog">
  }

  export type NodeInputUpsertWithWhereUniqueWithoutNodeExecutionInput = {
    where: NodeInputWhereUniqueInput
    update: XOR<NodeInputUpdateWithoutNodeExecutionInput, NodeInputUncheckedUpdateWithoutNodeExecutionInput>
    create: XOR<NodeInputCreateWithoutNodeExecutionInput, NodeInputUncheckedCreateWithoutNodeExecutionInput>
  }

  export type NodeInputUpdateWithWhereUniqueWithoutNodeExecutionInput = {
    where: NodeInputWhereUniqueInput
    data: XOR<NodeInputUpdateWithoutNodeExecutionInput, NodeInputUncheckedUpdateWithoutNodeExecutionInput>
  }

  export type NodeInputUpdateManyWithWhereWithoutNodeExecutionInput = {
    where: NodeInputScalarWhereInput
    data: XOR<NodeInputUpdateManyMutationInput, NodeInputUncheckedUpdateManyWithoutNodeExecutionInput>
  }

  export type NodeInputScalarWhereInput = {
    AND?: NodeInputScalarWhereInput | NodeInputScalarWhereInput[]
    OR?: NodeInputScalarWhereInput[]
    NOT?: NodeInputScalarWhereInput | NodeInputScalarWhereInput[]
    id?: StringFilter<"NodeInput"> | string
    executionId?: StringFilter<"NodeInput"> | string
    nodeId?: StringFilter<"NodeInput"> | string
    inputData?: JsonNullableFilter<"NodeInput">
    createdAt?: DateTimeNullableFilter<"NodeInput"> | Date | string | null
  }

  export type NodeOutputUpsertWithWhereUniqueWithoutNodeExecutionInput = {
    where: NodeOutputWhereUniqueInput
    update: XOR<NodeOutputUpdateWithoutNodeExecutionInput, NodeOutputUncheckedUpdateWithoutNodeExecutionInput>
    create: XOR<NodeOutputCreateWithoutNodeExecutionInput, NodeOutputUncheckedCreateWithoutNodeExecutionInput>
  }

  export type NodeOutputUpdateWithWhereUniqueWithoutNodeExecutionInput = {
    where: NodeOutputWhereUniqueInput
    data: XOR<NodeOutputUpdateWithoutNodeExecutionInput, NodeOutputUncheckedUpdateWithoutNodeExecutionInput>
  }

  export type NodeOutputUpdateManyWithWhereWithoutNodeExecutionInput = {
    where: NodeOutputScalarWhereInput
    data: XOR<NodeOutputUpdateManyMutationInput, NodeOutputUncheckedUpdateManyWithoutNodeExecutionInput>
  }

  export type NodeOutputScalarWhereInput = {
    AND?: NodeOutputScalarWhereInput | NodeOutputScalarWhereInput[]
    OR?: NodeOutputScalarWhereInput[]
    NOT?: NodeOutputScalarWhereInput | NodeOutputScalarWhereInput[]
    id?: StringFilter<"NodeOutput"> | string
    executionId?: StringFilter<"NodeOutput"> | string
    nodeId?: StringFilter<"NodeOutput"> | string
    outputData?: JsonNullableFilter<"NodeOutput">
    createdAt?: DateTimeNullableFilter<"NodeOutput"> | Date | string | null
  }

  export type NodeExecutionCreateWithoutLogsInput = {
    id?: string
    nodeId: string
    status: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string
    durationMs?: number | null
    updatedAt?: Date | string | null
    retryCount?: number | null
    finishedAt?: Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    execution: WorkflowExecutionCreateNestedOneWithoutNodeExecutionsInput
    nodeInputs?: NodeInputCreateNestedManyWithoutNodeExecutionInput
    nodeOutputs?: NodeOutputCreateNestedManyWithoutNodeExecutionInput
  }

  export type NodeExecutionUncheckedCreateWithoutLogsInput = {
    id?: string
    executionId: string
    nodeId: string
    status: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string
    durationMs?: number | null
    updatedAt?: Date | string | null
    retryCount?: number | null
    finishedAt?: Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    nodeInputs?: NodeInputUncheckedCreateNestedManyWithoutNodeExecutionInput
    nodeOutputs?: NodeOutputUncheckedCreateNestedManyWithoutNodeExecutionInput
  }

  export type NodeExecutionCreateOrConnectWithoutLogsInput = {
    where: NodeExecutionWhereUniqueInput
    create: XOR<NodeExecutionCreateWithoutLogsInput, NodeExecutionUncheckedCreateWithoutLogsInput>
  }

  export type NodeExecutionUpsertWithoutLogsInput = {
    update: XOR<NodeExecutionUpdateWithoutLogsInput, NodeExecutionUncheckedUpdateWithoutLogsInput>
    create: XOR<NodeExecutionCreateWithoutLogsInput, NodeExecutionUncheckedCreateWithoutLogsInput>
    where?: NodeExecutionWhereInput
  }

  export type NodeExecutionUpdateToOneWithWhereWithoutLogsInput = {
    where?: NodeExecutionWhereInput
    data: XOR<NodeExecutionUpdateWithoutLogsInput, NodeExecutionUncheckedUpdateWithoutLogsInput>
  }

  export type NodeExecutionUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    execution?: WorkflowExecutionUpdateOneRequiredWithoutNodeExecutionsNestedInput
    nodeInputs?: NodeInputUpdateManyWithoutNodeExecutionNestedInput
    nodeOutputs?: NodeOutputUpdateManyWithoutNodeExecutionNestedInput
  }

  export type NodeExecutionUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    nodeInputs?: NodeInputUncheckedUpdateManyWithoutNodeExecutionNestedInput
    nodeOutputs?: NodeOutputUncheckedUpdateManyWithoutNodeExecutionNestedInput
  }

  export type NodeExecutionCreateWithoutNodeInputsInput = {
    id?: string
    nodeId: string
    status: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string
    durationMs?: number | null
    updatedAt?: Date | string | null
    retryCount?: number | null
    finishedAt?: Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    execution: WorkflowExecutionCreateNestedOneWithoutNodeExecutionsInput
    logs?: NodeLogCreateNestedManyWithoutNodeExecutionInput
    nodeOutputs?: NodeOutputCreateNestedManyWithoutNodeExecutionInput
  }

  export type NodeExecutionUncheckedCreateWithoutNodeInputsInput = {
    id?: string
    executionId: string
    nodeId: string
    status: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string
    durationMs?: number | null
    updatedAt?: Date | string | null
    retryCount?: number | null
    finishedAt?: Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    logs?: NodeLogUncheckedCreateNestedManyWithoutNodeExecutionInput
    nodeOutputs?: NodeOutputUncheckedCreateNestedManyWithoutNodeExecutionInput
  }

  export type NodeExecutionCreateOrConnectWithoutNodeInputsInput = {
    where: NodeExecutionWhereUniqueInput
    create: XOR<NodeExecutionCreateWithoutNodeInputsInput, NodeExecutionUncheckedCreateWithoutNodeInputsInput>
  }

  export type NodeExecutionUpsertWithoutNodeInputsInput = {
    update: XOR<NodeExecutionUpdateWithoutNodeInputsInput, NodeExecutionUncheckedUpdateWithoutNodeInputsInput>
    create: XOR<NodeExecutionCreateWithoutNodeInputsInput, NodeExecutionUncheckedCreateWithoutNodeInputsInput>
    where?: NodeExecutionWhereInput
  }

  export type NodeExecutionUpdateToOneWithWhereWithoutNodeInputsInput = {
    where?: NodeExecutionWhereInput
    data: XOR<NodeExecutionUpdateWithoutNodeInputsInput, NodeExecutionUncheckedUpdateWithoutNodeInputsInput>
  }

  export type NodeExecutionUpdateWithoutNodeInputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    execution?: WorkflowExecutionUpdateOneRequiredWithoutNodeExecutionsNestedInput
    logs?: NodeLogUpdateManyWithoutNodeExecutionNestedInput
    nodeOutputs?: NodeOutputUpdateManyWithoutNodeExecutionNestedInput
  }

  export type NodeExecutionUncheckedUpdateWithoutNodeInputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    logs?: NodeLogUncheckedUpdateManyWithoutNodeExecutionNestedInput
    nodeOutputs?: NodeOutputUncheckedUpdateManyWithoutNodeExecutionNestedInput
  }

  export type NodeExecutionCreateWithoutNodeOutputsInput = {
    id?: string
    nodeId: string
    status: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string
    durationMs?: number | null
    updatedAt?: Date | string | null
    retryCount?: number | null
    finishedAt?: Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    execution: WorkflowExecutionCreateNestedOneWithoutNodeExecutionsInput
    logs?: NodeLogCreateNestedManyWithoutNodeExecutionInput
    nodeInputs?: NodeInputCreateNestedManyWithoutNodeExecutionInput
  }

  export type NodeExecutionUncheckedCreateWithoutNodeOutputsInput = {
    id?: string
    executionId: string
    nodeId: string
    status: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string
    durationMs?: number | null
    updatedAt?: Date | string | null
    retryCount?: number | null
    finishedAt?: Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    logs?: NodeLogUncheckedCreateNestedManyWithoutNodeExecutionInput
    nodeInputs?: NodeInputUncheckedCreateNestedManyWithoutNodeExecutionInput
  }

  export type NodeExecutionCreateOrConnectWithoutNodeOutputsInput = {
    where: NodeExecutionWhereUniqueInput
    create: XOR<NodeExecutionCreateWithoutNodeOutputsInput, NodeExecutionUncheckedCreateWithoutNodeOutputsInput>
  }

  export type NodeExecutionUpsertWithoutNodeOutputsInput = {
    update: XOR<NodeExecutionUpdateWithoutNodeOutputsInput, NodeExecutionUncheckedUpdateWithoutNodeOutputsInput>
    create: XOR<NodeExecutionCreateWithoutNodeOutputsInput, NodeExecutionUncheckedCreateWithoutNodeOutputsInput>
    where?: NodeExecutionWhereInput
  }

  export type NodeExecutionUpdateToOneWithWhereWithoutNodeOutputsInput = {
    where?: NodeExecutionWhereInput
    data: XOR<NodeExecutionUpdateWithoutNodeOutputsInput, NodeExecutionUncheckedUpdateWithoutNodeOutputsInput>
  }

  export type NodeExecutionUpdateWithoutNodeOutputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    execution?: WorkflowExecutionUpdateOneRequiredWithoutNodeExecutionsNestedInput
    logs?: NodeLogUpdateManyWithoutNodeExecutionNestedInput
    nodeInputs?: NodeInputUpdateManyWithoutNodeExecutionNestedInput
  }

  export type NodeExecutionUncheckedUpdateWithoutNodeOutputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    logs?: NodeLogUncheckedUpdateManyWithoutNodeExecutionNestedInput
    nodeInputs?: NodeInputUncheckedUpdateManyWithoutNodeExecutionNestedInput
  }

  export type WorkflowExecutionCreateWithoutExecutionLogsInput = {
    id?: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    workflow: WorkflowCreateNestedOneWithoutExecutionsInput
    user: UserCreateNestedOneWithoutWorkflowExecutionsInput
    nodeExecutions?: NodeExecutionCreateNestedManyWithoutExecutionInput
    blockExecutions?: BlockExecutionCreateNestedManyWithoutExecutionInput
    blockchainTransactions?: BlockchainTransactionCreateNestedManyWithoutExecutionInput
    workflowPauses?: WorkflowPauseCreateNestedManyWithoutExecutionInput
  }

  export type WorkflowExecutionUncheckedCreateWithoutExecutionLogsInput = {
    id?: string
    workflowId: string
    userId: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    nodeExecutions?: NodeExecutionUncheckedCreateNestedManyWithoutExecutionInput
    blockExecutions?: BlockExecutionUncheckedCreateNestedManyWithoutExecutionInput
    blockchainTransactions?: BlockchainTransactionUncheckedCreateNestedManyWithoutExecutionInput
    workflowPauses?: WorkflowPauseUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type WorkflowExecutionCreateOrConnectWithoutExecutionLogsInput = {
    where: WorkflowExecutionWhereUniqueInput
    create: XOR<WorkflowExecutionCreateWithoutExecutionLogsInput, WorkflowExecutionUncheckedCreateWithoutExecutionLogsInput>
  }

  export type WorkflowExecutionUpsertWithoutExecutionLogsInput = {
    update: XOR<WorkflowExecutionUpdateWithoutExecutionLogsInput, WorkflowExecutionUncheckedUpdateWithoutExecutionLogsInput>
    create: XOR<WorkflowExecutionCreateWithoutExecutionLogsInput, WorkflowExecutionUncheckedCreateWithoutExecutionLogsInput>
    where?: WorkflowExecutionWhereInput
  }

  export type WorkflowExecutionUpdateToOneWithWhereWithoutExecutionLogsInput = {
    where?: WorkflowExecutionWhereInput
    data: XOR<WorkflowExecutionUpdateWithoutExecutionLogsInput, WorkflowExecutionUncheckedUpdateWithoutExecutionLogsInput>
  }

  export type WorkflowExecutionUpdateWithoutExecutionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    workflow?: WorkflowUpdateOneRequiredWithoutExecutionsNestedInput
    user?: UserUpdateOneRequiredWithoutWorkflowExecutionsNestedInput
    nodeExecutions?: NodeExecutionUpdateManyWithoutExecutionNestedInput
    blockExecutions?: BlockExecutionUpdateManyWithoutExecutionNestedInput
    blockchainTransactions?: BlockchainTransactionUpdateManyWithoutExecutionNestedInput
    workflowPauses?: WorkflowPauseUpdateManyWithoutExecutionNestedInput
  }

  export type WorkflowExecutionUncheckedUpdateWithoutExecutionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    nodeExecutions?: NodeExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    blockExecutions?: BlockExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    blockchainTransactions?: BlockchainTransactionUncheckedUpdateManyWithoutExecutionNestedInput
    workflowPauses?: WorkflowPauseUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type WorkflowCreateWithoutPausesInput = {
    id?: string
    name: string
    description?: string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean | null
    tags?: WorkflowCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: number
    createdBy?: string | null
    user: UserCreateNestedOneWithoutWorkflowsInput
    executions?: WorkflowExecutionCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowUncheckedCreateWithoutPausesInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean | null
    tags?: WorkflowCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: number
    createdBy?: string | null
    executions?: WorkflowExecutionUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowCreateOrConnectWithoutPausesInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutPausesInput, WorkflowUncheckedCreateWithoutPausesInput>
  }

  export type WorkflowExecutionCreateWithoutWorkflowPausesInput = {
    id?: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    workflow: WorkflowCreateNestedOneWithoutExecutionsInput
    user: UserCreateNestedOneWithoutWorkflowExecutionsInput
    nodeExecutions?: NodeExecutionCreateNestedManyWithoutExecutionInput
    executionLogs?: ExecutionLogCreateNestedManyWithoutExecutionInput
    blockExecutions?: BlockExecutionCreateNestedManyWithoutExecutionInput
    blockchainTransactions?: BlockchainTransactionCreateNestedManyWithoutExecutionInput
  }

  export type WorkflowExecutionUncheckedCreateWithoutWorkflowPausesInput = {
    id?: string
    workflowId: string
    userId: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    nodeExecutions?: NodeExecutionUncheckedCreateNestedManyWithoutExecutionInput
    executionLogs?: ExecutionLogUncheckedCreateNestedManyWithoutExecutionInput
    blockExecutions?: BlockExecutionUncheckedCreateNestedManyWithoutExecutionInput
    blockchainTransactions?: BlockchainTransactionUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type WorkflowExecutionCreateOrConnectWithoutWorkflowPausesInput = {
    where: WorkflowExecutionWhereUniqueInput
    create: XOR<WorkflowExecutionCreateWithoutWorkflowPausesInput, WorkflowExecutionUncheckedCreateWithoutWorkflowPausesInput>
  }

  export type WorkflowUpsertWithoutPausesInput = {
    update: XOR<WorkflowUpdateWithoutPausesInput, WorkflowUncheckedUpdateWithoutPausesInput>
    create: XOR<WorkflowCreateWithoutPausesInput, WorkflowUncheckedCreateWithoutPausesInput>
    where?: WorkflowWhereInput
  }

  export type WorkflowUpdateToOneWithWhereWithoutPausesInput = {
    where?: WorkflowWhereInput
    data: XOR<WorkflowUpdateWithoutPausesInput, WorkflowUncheckedUpdateWithoutPausesInput>
  }

  export type WorkflowUpdateWithoutPausesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: WorkflowUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutWorkflowsNestedInput
    executions?: WorkflowExecutionUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutPausesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: WorkflowUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    executions?: WorkflowExecutionUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowExecutionUpsertWithoutWorkflowPausesInput = {
    update: XOR<WorkflowExecutionUpdateWithoutWorkflowPausesInput, WorkflowExecutionUncheckedUpdateWithoutWorkflowPausesInput>
    create: XOR<WorkflowExecutionCreateWithoutWorkflowPausesInput, WorkflowExecutionUncheckedCreateWithoutWorkflowPausesInput>
    where?: WorkflowExecutionWhereInput
  }

  export type WorkflowExecutionUpdateToOneWithWhereWithoutWorkflowPausesInput = {
    where?: WorkflowExecutionWhereInput
    data: XOR<WorkflowExecutionUpdateWithoutWorkflowPausesInput, WorkflowExecutionUncheckedUpdateWithoutWorkflowPausesInput>
  }

  export type WorkflowExecutionUpdateWithoutWorkflowPausesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    workflow?: WorkflowUpdateOneRequiredWithoutExecutionsNestedInput
    user?: UserUpdateOneRequiredWithoutWorkflowExecutionsNestedInput
    nodeExecutions?: NodeExecutionUpdateManyWithoutExecutionNestedInput
    executionLogs?: ExecutionLogUpdateManyWithoutExecutionNestedInput
    blockExecutions?: BlockExecutionUpdateManyWithoutExecutionNestedInput
    blockchainTransactions?: BlockchainTransactionUpdateManyWithoutExecutionNestedInput
  }

  export type WorkflowExecutionUncheckedUpdateWithoutWorkflowPausesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    nodeExecutions?: NodeExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    executionLogs?: ExecutionLogUncheckedUpdateManyWithoutExecutionNestedInput
    blockExecutions?: BlockExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    blockchainTransactions?: BlockchainTransactionUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type WorkflowExecutionCreateWithoutBlockchainTransactionsInput = {
    id?: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    workflow: WorkflowCreateNestedOneWithoutExecutionsInput
    user: UserCreateNestedOneWithoutWorkflowExecutionsInput
    nodeExecutions?: NodeExecutionCreateNestedManyWithoutExecutionInput
    executionLogs?: ExecutionLogCreateNestedManyWithoutExecutionInput
    blockExecutions?: BlockExecutionCreateNestedManyWithoutExecutionInput
    workflowPauses?: WorkflowPauseCreateNestedManyWithoutExecutionInput
  }

  export type WorkflowExecutionUncheckedCreateWithoutBlockchainTransactionsInput = {
    id?: string
    workflowId: string
    userId: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    nodeExecutions?: NodeExecutionUncheckedCreateNestedManyWithoutExecutionInput
    executionLogs?: ExecutionLogUncheckedCreateNestedManyWithoutExecutionInput
    blockExecutions?: BlockExecutionUncheckedCreateNestedManyWithoutExecutionInput
    workflowPauses?: WorkflowPauseUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type WorkflowExecutionCreateOrConnectWithoutBlockchainTransactionsInput = {
    where: WorkflowExecutionWhereUniqueInput
    create: XOR<WorkflowExecutionCreateWithoutBlockchainTransactionsInput, WorkflowExecutionUncheckedCreateWithoutBlockchainTransactionsInput>
  }

  export type TransactionAttemptCreateWithoutTransactionInput = {
    id?: string
    txHash?: string | null
    status: string
    error?: string | null
    blockNumber?: number | null
    gasUsed?: string | null
    effectiveGasPrice?: string | null
    createdAt?: Date | string
  }

  export type TransactionAttemptUncheckedCreateWithoutTransactionInput = {
    id?: string
    txHash?: string | null
    status: string
    error?: string | null
    blockNumber?: number | null
    gasUsed?: string | null
    effectiveGasPrice?: string | null
    createdAt?: Date | string
  }

  export type TransactionAttemptCreateOrConnectWithoutTransactionInput = {
    where: TransactionAttemptWhereUniqueInput
    create: XOR<TransactionAttemptCreateWithoutTransactionInput, TransactionAttemptUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionAttemptCreateManyTransactionInputEnvelope = {
    data: TransactionAttemptCreateManyTransactionInput | TransactionAttemptCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowExecutionUpsertWithoutBlockchainTransactionsInput = {
    update: XOR<WorkflowExecutionUpdateWithoutBlockchainTransactionsInput, WorkflowExecutionUncheckedUpdateWithoutBlockchainTransactionsInput>
    create: XOR<WorkflowExecutionCreateWithoutBlockchainTransactionsInput, WorkflowExecutionUncheckedCreateWithoutBlockchainTransactionsInput>
    where?: WorkflowExecutionWhereInput
  }

  export type WorkflowExecutionUpdateToOneWithWhereWithoutBlockchainTransactionsInput = {
    where?: WorkflowExecutionWhereInput
    data: XOR<WorkflowExecutionUpdateWithoutBlockchainTransactionsInput, WorkflowExecutionUncheckedUpdateWithoutBlockchainTransactionsInput>
  }

  export type WorkflowExecutionUpdateWithoutBlockchainTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    workflow?: WorkflowUpdateOneRequiredWithoutExecutionsNestedInput
    user?: UserUpdateOneRequiredWithoutWorkflowExecutionsNestedInput
    nodeExecutions?: NodeExecutionUpdateManyWithoutExecutionNestedInput
    executionLogs?: ExecutionLogUpdateManyWithoutExecutionNestedInput
    blockExecutions?: BlockExecutionUpdateManyWithoutExecutionNestedInput
    workflowPauses?: WorkflowPauseUpdateManyWithoutExecutionNestedInput
  }

  export type WorkflowExecutionUncheckedUpdateWithoutBlockchainTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    nodeExecutions?: NodeExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    executionLogs?: ExecutionLogUncheckedUpdateManyWithoutExecutionNestedInput
    blockExecutions?: BlockExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    workflowPauses?: WorkflowPauseUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type TransactionAttemptUpsertWithWhereUniqueWithoutTransactionInput = {
    where: TransactionAttemptWhereUniqueInput
    update: XOR<TransactionAttemptUpdateWithoutTransactionInput, TransactionAttemptUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionAttemptCreateWithoutTransactionInput, TransactionAttemptUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionAttemptUpdateWithWhereUniqueWithoutTransactionInput = {
    where: TransactionAttemptWhereUniqueInput
    data: XOR<TransactionAttemptUpdateWithoutTransactionInput, TransactionAttemptUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionAttemptUpdateManyWithWhereWithoutTransactionInput = {
    where: TransactionAttemptScalarWhereInput
    data: XOR<TransactionAttemptUpdateManyMutationInput, TransactionAttemptUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionAttemptScalarWhereInput = {
    AND?: TransactionAttemptScalarWhereInput | TransactionAttemptScalarWhereInput[]
    OR?: TransactionAttemptScalarWhereInput[]
    NOT?: TransactionAttemptScalarWhereInput | TransactionAttemptScalarWhereInput[]
    id?: StringFilter<"TransactionAttempt"> | string
    transactionId?: StringFilter<"TransactionAttempt"> | string
    txHash?: StringNullableFilter<"TransactionAttempt"> | string | null
    status?: StringFilter<"TransactionAttempt"> | string
    error?: StringNullableFilter<"TransactionAttempt"> | string | null
    blockNumber?: IntNullableFilter<"TransactionAttempt"> | number | null
    gasUsed?: StringNullableFilter<"TransactionAttempt"> | string | null
    effectiveGasPrice?: StringNullableFilter<"TransactionAttempt"> | string | null
    createdAt?: DateTimeFilter<"TransactionAttempt"> | Date | string
  }

  export type BlockchainTransactionCreateWithoutTransactionAttemptsInput = {
    id?: string
    nodeId: string
    toAddress: string
    value: string
    data?: NullableJsonNullValueInput | InputJsonValue
    chainId: number
    gasLimit?: string | null
    gasUsed?: string | null
    maxFeePerGas?: string | null
    maxPriorityFeePerGas?: string | null
    nonce?: number | null
    status: string
    hash?: string | null
    txHash?: string | null
    blockNumber?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    walletAddress: string
    effectiveGasPrice?: string | null
    error?: string | null
    fromAddress?: string | null
    execution: WorkflowExecutionCreateNestedOneWithoutBlockchainTransactionsInput
  }

  export type BlockchainTransactionUncheckedCreateWithoutTransactionAttemptsInput = {
    id?: string
    nodeId: string
    executionId: string
    toAddress: string
    value: string
    data?: NullableJsonNullValueInput | InputJsonValue
    chainId: number
    gasLimit?: string | null
    gasUsed?: string | null
    maxFeePerGas?: string | null
    maxPriorityFeePerGas?: string | null
    nonce?: number | null
    status: string
    hash?: string | null
    txHash?: string | null
    blockNumber?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    walletAddress: string
    effectiveGasPrice?: string | null
    error?: string | null
    fromAddress?: string | null
  }

  export type BlockchainTransactionCreateOrConnectWithoutTransactionAttemptsInput = {
    where: BlockchainTransactionWhereUniqueInput
    create: XOR<BlockchainTransactionCreateWithoutTransactionAttemptsInput, BlockchainTransactionUncheckedCreateWithoutTransactionAttemptsInput>
  }

  export type BlockchainTransactionUpsertWithoutTransactionAttemptsInput = {
    update: XOR<BlockchainTransactionUpdateWithoutTransactionAttemptsInput, BlockchainTransactionUncheckedUpdateWithoutTransactionAttemptsInput>
    create: XOR<BlockchainTransactionCreateWithoutTransactionAttemptsInput, BlockchainTransactionUncheckedCreateWithoutTransactionAttemptsInput>
    where?: BlockchainTransactionWhereInput
  }

  export type BlockchainTransactionUpdateToOneWithWhereWithoutTransactionAttemptsInput = {
    where?: BlockchainTransactionWhereInput
    data: XOR<BlockchainTransactionUpdateWithoutTransactionAttemptsInput, BlockchainTransactionUncheckedUpdateWithoutTransactionAttemptsInput>
  }

  export type BlockchainTransactionUpdateWithoutTransactionAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    chainId?: IntFieldUpdateOperationsInput | number
    gasLimit?: NullableStringFieldUpdateOperationsInput | string | null
    gasUsed?: NullableStringFieldUpdateOperationsInput | string | null
    maxFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    maxPriorityFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: StringFieldUpdateOperationsInput | string
    effectiveGasPrice?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: NullableStringFieldUpdateOperationsInput | string | null
    execution?: WorkflowExecutionUpdateOneRequiredWithoutBlockchainTransactionsNestedInput
  }

  export type BlockchainTransactionUncheckedUpdateWithoutTransactionAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    chainId?: IntFieldUpdateOperationsInput | number
    gasLimit?: NullableStringFieldUpdateOperationsInput | string | null
    gasUsed?: NullableStringFieldUpdateOperationsInput | string | null
    maxFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    maxPriorityFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: StringFieldUpdateOperationsInput | string
    effectiveGasPrice?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkflowExecutionCreateWithoutBlockExecutionsInput = {
    id?: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    workflow: WorkflowCreateNestedOneWithoutExecutionsInput
    user: UserCreateNestedOneWithoutWorkflowExecutionsInput
    nodeExecutions?: NodeExecutionCreateNestedManyWithoutExecutionInput
    executionLogs?: ExecutionLogCreateNestedManyWithoutExecutionInput
    blockchainTransactions?: BlockchainTransactionCreateNestedManyWithoutExecutionInput
    workflowPauses?: WorkflowPauseCreateNestedManyWithoutExecutionInput
  }

  export type WorkflowExecutionUncheckedCreateWithoutBlockExecutionsInput = {
    id?: string
    workflowId: string
    userId: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    nodeExecutions?: NodeExecutionUncheckedCreateNestedManyWithoutExecutionInput
    executionLogs?: ExecutionLogUncheckedCreateNestedManyWithoutExecutionInput
    blockchainTransactions?: BlockchainTransactionUncheckedCreateNestedManyWithoutExecutionInput
    workflowPauses?: WorkflowPauseUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type WorkflowExecutionCreateOrConnectWithoutBlockExecutionsInput = {
    where: WorkflowExecutionWhereUniqueInput
    create: XOR<WorkflowExecutionCreateWithoutBlockExecutionsInput, WorkflowExecutionUncheckedCreateWithoutBlockExecutionsInput>
  }

  export type BlockExecutionLogCreateWithoutBlockExecutionInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    timestamp?: Date | string
  }

  export type BlockExecutionLogUncheckedCreateWithoutBlockExecutionInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    timestamp?: Date | string
  }

  export type BlockExecutionLogCreateOrConnectWithoutBlockExecutionInput = {
    where: BlockExecutionLogWhereUniqueInput
    create: XOR<BlockExecutionLogCreateWithoutBlockExecutionInput, BlockExecutionLogUncheckedCreateWithoutBlockExecutionInput>
  }

  export type BlockExecutionLogCreateManyBlockExecutionInputEnvelope = {
    data: BlockExecutionLogCreateManyBlockExecutionInput | BlockExecutionLogCreateManyBlockExecutionInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowExecutionUpsertWithoutBlockExecutionsInput = {
    update: XOR<WorkflowExecutionUpdateWithoutBlockExecutionsInput, WorkflowExecutionUncheckedUpdateWithoutBlockExecutionsInput>
    create: XOR<WorkflowExecutionCreateWithoutBlockExecutionsInput, WorkflowExecutionUncheckedCreateWithoutBlockExecutionsInput>
    where?: WorkflowExecutionWhereInput
  }

  export type WorkflowExecutionUpdateToOneWithWhereWithoutBlockExecutionsInput = {
    where?: WorkflowExecutionWhereInput
    data: XOR<WorkflowExecutionUpdateWithoutBlockExecutionsInput, WorkflowExecutionUncheckedUpdateWithoutBlockExecutionsInput>
  }

  export type WorkflowExecutionUpdateWithoutBlockExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    workflow?: WorkflowUpdateOneRequiredWithoutExecutionsNestedInput
    user?: UserUpdateOneRequiredWithoutWorkflowExecutionsNestedInput
    nodeExecutions?: NodeExecutionUpdateManyWithoutExecutionNestedInput
    executionLogs?: ExecutionLogUpdateManyWithoutExecutionNestedInput
    blockchainTransactions?: BlockchainTransactionUpdateManyWithoutExecutionNestedInput
    workflowPauses?: WorkflowPauseUpdateManyWithoutExecutionNestedInput
  }

  export type WorkflowExecutionUncheckedUpdateWithoutBlockExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    nodeExecutions?: NodeExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    executionLogs?: ExecutionLogUncheckedUpdateManyWithoutExecutionNestedInput
    blockchainTransactions?: BlockchainTransactionUncheckedUpdateManyWithoutExecutionNestedInput
    workflowPauses?: WorkflowPauseUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type BlockExecutionLogUpsertWithWhereUniqueWithoutBlockExecutionInput = {
    where: BlockExecutionLogWhereUniqueInput
    update: XOR<BlockExecutionLogUpdateWithoutBlockExecutionInput, BlockExecutionLogUncheckedUpdateWithoutBlockExecutionInput>
    create: XOR<BlockExecutionLogCreateWithoutBlockExecutionInput, BlockExecutionLogUncheckedCreateWithoutBlockExecutionInput>
  }

  export type BlockExecutionLogUpdateWithWhereUniqueWithoutBlockExecutionInput = {
    where: BlockExecutionLogWhereUniqueInput
    data: XOR<BlockExecutionLogUpdateWithoutBlockExecutionInput, BlockExecutionLogUncheckedUpdateWithoutBlockExecutionInput>
  }

  export type BlockExecutionLogUpdateManyWithWhereWithoutBlockExecutionInput = {
    where: BlockExecutionLogScalarWhereInput
    data: XOR<BlockExecutionLogUpdateManyMutationInput, BlockExecutionLogUncheckedUpdateManyWithoutBlockExecutionInput>
  }

  export type BlockExecutionLogScalarWhereInput = {
    AND?: BlockExecutionLogScalarWhereInput | BlockExecutionLogScalarWhereInput[]
    OR?: BlockExecutionLogScalarWhereInput[]
    NOT?: BlockExecutionLogScalarWhereInput | BlockExecutionLogScalarWhereInput[]
    id?: StringFilter<"BlockExecutionLog"> | string
    blockExecutionId?: StringFilter<"BlockExecutionLog"> | string
    level?: EnumLogLevelFilter<"BlockExecutionLog"> | $Enums.LogLevel
    message?: StringFilter<"BlockExecutionLog"> | string
    timestamp?: DateTimeFilter<"BlockExecutionLog"> | Date | string
  }

  export type BlockExecutionCreateWithoutLogsInput = {
    id?: string
    nodeId: string
    blockType: string
    status: $Enums.BlockStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    execution: WorkflowExecutionCreateNestedOneWithoutBlockExecutionsInput
  }

  export type BlockExecutionUncheckedCreateWithoutLogsInput = {
    id?: string
    executionId: string
    nodeId: string
    blockType: string
    status: $Enums.BlockStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startTime: Date | string
    endTime?: Date | string | null
  }

  export type BlockExecutionCreateOrConnectWithoutLogsInput = {
    where: BlockExecutionWhereUniqueInput
    create: XOR<BlockExecutionCreateWithoutLogsInput, BlockExecutionUncheckedCreateWithoutLogsInput>
  }

  export type BlockExecutionUpsertWithoutLogsInput = {
    update: XOR<BlockExecutionUpdateWithoutLogsInput, BlockExecutionUncheckedUpdateWithoutLogsInput>
    create: XOR<BlockExecutionCreateWithoutLogsInput, BlockExecutionUncheckedCreateWithoutLogsInput>
    where?: BlockExecutionWhereInput
  }

  export type BlockExecutionUpdateToOneWithWhereWithoutLogsInput = {
    where?: BlockExecutionWhereInput
    data: XOR<BlockExecutionUpdateWithoutLogsInput, BlockExecutionUncheckedUpdateWithoutLogsInput>
  }

  export type BlockExecutionUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    status?: EnumBlockStatusFieldUpdateOperationsInput | $Enums.BlockStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    execution?: WorkflowExecutionUpdateOneRequiredWithoutBlockExecutionsNestedInput
  }

  export type BlockExecutionUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    status?: EnumBlockStatusFieldUpdateOperationsInput | $Enums.BlockStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlockLibraryRatingCreateWithoutBlockInput = {
    id?: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type BlockLibraryRatingUncheckedCreateWithoutBlockInput = {
    id?: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type BlockLibraryRatingCreateOrConnectWithoutBlockInput = {
    where: BlockLibraryRatingWhereUniqueInput
    create: XOR<BlockLibraryRatingCreateWithoutBlockInput, BlockLibraryRatingUncheckedCreateWithoutBlockInput>
  }

  export type BlockLibraryRatingCreateManyBlockInputEnvelope = {
    data: BlockLibraryRatingCreateManyBlockInput | BlockLibraryRatingCreateManyBlockInput[]
    skipDuplicates?: boolean
  }

  export type BlockLibraryRatingUpsertWithWhereUniqueWithoutBlockInput = {
    where: BlockLibraryRatingWhereUniqueInput
    update: XOR<BlockLibraryRatingUpdateWithoutBlockInput, BlockLibraryRatingUncheckedUpdateWithoutBlockInput>
    create: XOR<BlockLibraryRatingCreateWithoutBlockInput, BlockLibraryRatingUncheckedCreateWithoutBlockInput>
  }

  export type BlockLibraryRatingUpdateWithWhereUniqueWithoutBlockInput = {
    where: BlockLibraryRatingWhereUniqueInput
    data: XOR<BlockLibraryRatingUpdateWithoutBlockInput, BlockLibraryRatingUncheckedUpdateWithoutBlockInput>
  }

  export type BlockLibraryRatingUpdateManyWithWhereWithoutBlockInput = {
    where: BlockLibraryRatingScalarWhereInput
    data: XOR<BlockLibraryRatingUpdateManyMutationInput, BlockLibraryRatingUncheckedUpdateManyWithoutBlockInput>
  }

  export type BlockLibraryRatingScalarWhereInput = {
    AND?: BlockLibraryRatingScalarWhereInput | BlockLibraryRatingScalarWhereInput[]
    OR?: BlockLibraryRatingScalarWhereInput[]
    NOT?: BlockLibraryRatingScalarWhereInput | BlockLibraryRatingScalarWhereInput[]
    id?: StringFilter<"BlockLibraryRating"> | string
    blockId?: StringFilter<"BlockLibraryRating"> | string
    userId?: StringFilter<"BlockLibraryRating"> | string
    rating?: IntFilter<"BlockLibraryRating"> | number
    comment?: StringNullableFilter<"BlockLibraryRating"> | string | null
    createdAt?: DateTimeFilter<"BlockLibraryRating"> | Date | string
  }

  export type BlockLibraryCreateWithoutRatingsInput = {
    id?: string
    name: string
    description: string
    blockType: string
    category?: string | null
    configuration?: JsonNullValueInput | InputJsonValue
    blockData?: NullableJsonNullValueInput | InputJsonValue
    executionCode?: string | null
    userId: string
    isPublic?: boolean | null
    isVerified?: boolean | null
    rating?: number | null
    usageCount?: number | null
    tags?: BlockLibraryCreatetagsInput | string[]
    version?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BlockLibraryUncheckedCreateWithoutRatingsInput = {
    id?: string
    name: string
    description: string
    blockType: string
    category?: string | null
    configuration?: JsonNullValueInput | InputJsonValue
    blockData?: NullableJsonNullValueInput | InputJsonValue
    executionCode?: string | null
    userId: string
    isPublic?: boolean | null
    isVerified?: boolean | null
    rating?: number | null
    usageCount?: number | null
    tags?: BlockLibraryCreatetagsInput | string[]
    version?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BlockLibraryCreateOrConnectWithoutRatingsInput = {
    where: BlockLibraryWhereUniqueInput
    create: XOR<BlockLibraryCreateWithoutRatingsInput, BlockLibraryUncheckedCreateWithoutRatingsInput>
  }

  export type BlockLibraryUpsertWithoutRatingsInput = {
    update: XOR<BlockLibraryUpdateWithoutRatingsInput, BlockLibraryUncheckedUpdateWithoutRatingsInput>
    create: XOR<BlockLibraryCreateWithoutRatingsInput, BlockLibraryUncheckedCreateWithoutRatingsInput>
    where?: BlockLibraryWhereInput
  }

  export type BlockLibraryUpdateToOneWithWhereWithoutRatingsInput = {
    where?: BlockLibraryWhereInput
    data: XOR<BlockLibraryUpdateWithoutRatingsInput, BlockLibraryUncheckedUpdateWithoutRatingsInput>
  }

  export type BlockLibraryUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    configuration?: JsonNullValueInput | InputJsonValue
    blockData?: NullableJsonNullValueInput | InputJsonValue
    executionCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    usageCount?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: BlockLibraryUpdatetagsInput | string[]
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlockLibraryUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    configuration?: JsonNullValueInput | InputJsonValue
    blockData?: NullableJsonNullValueInput | InputJsonValue
    executionCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    usageCount?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: BlockLibraryUpdatetagsInput | string[]
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    userWallets?: UserWalletCreateNestedManyWithoutUserInput
    workflows?: WorkflowCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    ownedTeams?: TeamCreateNestedManyWithoutOwnerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    userWallets?: UserWalletUncheckedCreateNestedManyWithoutUserInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    ownedTeams?: TeamUncheckedCreateNestedManyWithoutOwnerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    userWallets?: UserWalletUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    ownedTeams?: TeamUpdateManyWithoutOwnerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    userWallets?: UserWalletUncheckedUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedTeams?: TeamUncheckedUpdateManyWithoutOwnerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationPreferencesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    userWallets?: UserWalletCreateNestedManyWithoutUserInput
    workflows?: WorkflowCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    ownedTeams?: TeamCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutNotificationPreferencesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    userWallets?: UserWalletUncheckedCreateNestedManyWithoutUserInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    ownedTeams?: TeamUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutNotificationPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
  }

  export type UserUpsertWithoutNotificationPreferencesInput = {
    update: XOR<UserUpdateWithoutNotificationPreferencesInput, UserUncheckedUpdateWithoutNotificationPreferencesInput>
    create: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationPreferencesInput, UserUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type UserUpdateWithoutNotificationPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    userWallets?: UserWalletUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    ownedTeams?: TeamUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    userWallets?: UserWalletUncheckedUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedTeams?: TeamUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type SubscriptionCreateWithoutTierInput = {
    id?: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    stripeCustomerId?: string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
    invoices?: SubscriptionInvoiceCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutTierInput = {
    id?: string
    userId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    stripeCustomerId?: string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: SubscriptionInvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutTierInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutTierInput, SubscriptionUncheckedCreateWithoutTierInput>
  }

  export type SubscriptionCreateManyTierInputEnvelope = {
    data: SubscriptionCreateManyTierInput | SubscriptionCreateManyTierInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutTierInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutTierInput, SubscriptionUncheckedUpdateWithoutTierInput>
    create: XOR<SubscriptionCreateWithoutTierInput, SubscriptionUncheckedCreateWithoutTierInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutTierInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutTierInput, SubscriptionUncheckedUpdateWithoutTierInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutTierInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutTierInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    tierId?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    stripePriceId?: StringNullableFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type UserCreateWithoutSubscriptionInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    userWallets?: UserWalletCreateNestedManyWithoutUserInput
    workflows?: WorkflowCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    ownedTeams?: TeamCreateNestedManyWithoutOwnerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    userWallets?: UserWalletUncheckedCreateNestedManyWithoutUserInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    ownedTeams?: TeamUncheckedCreateNestedManyWithoutOwnerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type PricingTierCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    workflowLimit: number
    executionLimit: number
    features?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricingTierUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    workflowLimit: number
    executionLimit: number
    features?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricingTierCreateOrConnectWithoutSubscriptionsInput = {
    where: PricingTierWhereUniqueInput
    create: XOR<PricingTierCreateWithoutSubscriptionsInput, PricingTierUncheckedCreateWithoutSubscriptionsInput>
  }

  export type SubscriptionInvoiceCreateWithoutSubscriptionInput = {
    id?: string
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: string
    paidAt?: Date | string | null
    invoiceUrl?: string | null
    createdAt?: Date | string
  }

  export type SubscriptionInvoiceUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: string
    paidAt?: Date | string | null
    invoiceUrl?: string | null
    createdAt?: Date | string
  }

  export type SubscriptionInvoiceCreateOrConnectWithoutSubscriptionInput = {
    where: SubscriptionInvoiceWhereUniqueInput
    create: XOR<SubscriptionInvoiceCreateWithoutSubscriptionInput, SubscriptionInvoiceUncheckedCreateWithoutSubscriptionInput>
  }

  export type SubscriptionInvoiceCreateManySubscriptionInputEnvelope = {
    data: SubscriptionInvoiceCreateManySubscriptionInput | SubscriptionInvoiceCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSubscriptionInput = {
    update: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    userWallets?: UserWalletUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    ownedTeams?: TeamUpdateManyWithoutOwnerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    userWallets?: UserWalletUncheckedUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedTeams?: TeamUncheckedUpdateManyWithoutOwnerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PricingTierUpsertWithoutSubscriptionsInput = {
    update: XOR<PricingTierUpdateWithoutSubscriptionsInput, PricingTierUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<PricingTierCreateWithoutSubscriptionsInput, PricingTierUncheckedCreateWithoutSubscriptionsInput>
    where?: PricingTierWhereInput
  }

  export type PricingTierUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: PricingTierWhereInput
    data: XOR<PricingTierUpdateWithoutSubscriptionsInput, PricingTierUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PricingTierUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workflowLimit?: IntFieldUpdateOperationsInput | number
    executionLimit?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingTierUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workflowLimit?: IntFieldUpdateOperationsInput | number
    executionLimit?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionInvoiceUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: SubscriptionInvoiceWhereUniqueInput
    update: XOR<SubscriptionInvoiceUpdateWithoutSubscriptionInput, SubscriptionInvoiceUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<SubscriptionInvoiceCreateWithoutSubscriptionInput, SubscriptionInvoiceUncheckedCreateWithoutSubscriptionInput>
  }

  export type SubscriptionInvoiceUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: SubscriptionInvoiceWhereUniqueInput
    data: XOR<SubscriptionInvoiceUpdateWithoutSubscriptionInput, SubscriptionInvoiceUncheckedUpdateWithoutSubscriptionInput>
  }

  export type SubscriptionInvoiceUpdateManyWithWhereWithoutSubscriptionInput = {
    where: SubscriptionInvoiceScalarWhereInput
    data: XOR<SubscriptionInvoiceUpdateManyMutationInput, SubscriptionInvoiceUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type SubscriptionInvoiceScalarWhereInput = {
    AND?: SubscriptionInvoiceScalarWhereInput | SubscriptionInvoiceScalarWhereInput[]
    OR?: SubscriptionInvoiceScalarWhereInput[]
    NOT?: SubscriptionInvoiceScalarWhereInput | SubscriptionInvoiceScalarWhereInput[]
    id?: StringFilter<"SubscriptionInvoice"> | string
    subscriptionId?: StringFilter<"SubscriptionInvoice"> | string
    stripeInvoiceId?: StringNullableFilter<"SubscriptionInvoice"> | string | null
    amount?: DecimalFilter<"SubscriptionInvoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"SubscriptionInvoice"> | string
    paidAt?: DateTimeNullableFilter<"SubscriptionInvoice"> | Date | string | null
    invoiceUrl?: StringNullableFilter<"SubscriptionInvoice"> | string | null
    createdAt?: DateTimeFilter<"SubscriptionInvoice"> | Date | string
  }

  export type SubscriptionCreateWithoutInvoicesInput = {
    id?: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    stripeCustomerId?: string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
    tier: PricingTierCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutInvoicesInput = {
    id?: string
    userId: string
    tierId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    stripeCustomerId?: string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutInvoicesInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
  }

  export type SubscriptionUpsertWithoutInvoicesInput = {
    update: XOR<SubscriptionUpdateWithoutInvoicesInput, SubscriptionUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutInvoicesInput, SubscriptionUncheckedUpdateWithoutInvoicesInput>
  }

  export type SubscriptionUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    tier?: PricingTierUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tierId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutOwnedTeamsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    userWallets?: UserWalletCreateNestedManyWithoutUserInput
    workflows?: WorkflowCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedTeamsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    userWallets?: UserWalletUncheckedCreateNestedManyWithoutUserInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedTeamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedTeamsInput, UserUncheckedCreateWithoutOwnedTeamsInput>
  }

  export type TeamMemberCreateWithoutTeamInput = {
    role: string
    joinedAt?: Date | string | null
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    userId: string
    role: string
    joinedAt?: Date | string | null
  }

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnedTeamsInput = {
    update: XOR<UserUpdateWithoutOwnedTeamsInput, UserUncheckedUpdateWithoutOwnedTeamsInput>
    create: XOR<UserCreateWithoutOwnedTeamsInput, UserUncheckedCreateWithoutOwnedTeamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedTeamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedTeamsInput, UserUncheckedUpdateWithoutOwnedTeamsInput>
  }

  export type UserUpdateWithoutOwnedTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    userWallets?: UserWalletUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    userWallets?: UserWalletUncheckedUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    owner: UserCreateNestedOneWithoutOwnedTeamsInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdBy: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutTeamMembershipsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    userWallets?: UserWalletCreateNestedManyWithoutUserInput
    workflows?: WorkflowCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    ownedTeams?: TeamCreateNestedManyWithoutOwnerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamMembershipsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    userWallets?: UserWalletUncheckedCreateNestedManyWithoutUserInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutUserInput
    workflowExecutions?: WorkflowExecutionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    ownedTeams?: TeamUncheckedCreateNestedManyWithoutOwnerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedTeamsNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutTeamMembershipsInput = {
    update: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type UserUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    userWallets?: UserWalletUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    ownedTeams?: TeamUpdateManyWithoutOwnerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    userWallets?: UserWalletUncheckedUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutUserNestedInput
    workflowExecutions?: WorkflowExecutionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    ownedTeams?: TeamUncheckedUpdateManyWithoutOwnerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserWalletCreateManyUserInput = {
    id?: string
    chainId: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walletType?: string | null
    chainType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean | null
    tags?: WorkflowCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: number
    createdBy?: string | null
  }

  export type WorkflowExecutionCreateManyUserInput = {
    id?: string
    workflowId: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type: string
    read?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type TeamMemberCreateManyUserInput = {
    teamId: string
    role: string
    joinedAt?: Date | string | null
  }

  export type TeamCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserWalletUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walletType?: NullableStringFieldUpdateOperationsInput | string | null
    chainType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserWalletUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walletType?: NullableStringFieldUpdateOperationsInput | string | null
    chainType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserWalletUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walletType?: NullableStringFieldUpdateOperationsInput | string | null
    chainType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: WorkflowUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    executions?: WorkflowExecutionUpdateManyWithoutWorkflowNestedInput
    pauses?: WorkflowPauseUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: WorkflowUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    executions?: WorkflowExecutionUncheckedUpdateManyWithoutWorkflowNestedInput
    pauses?: WorkflowPauseUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: NullableJsonNullValueInput | InputJsonValue
    edges?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: WorkflowUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    definition?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkflowExecutionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    workflow?: WorkflowUpdateOneRequiredWithoutExecutionsNestedInput
    nodeExecutions?: NodeExecutionUpdateManyWithoutExecutionNestedInput
    executionLogs?: ExecutionLogUpdateManyWithoutExecutionNestedInput
    blockExecutions?: BlockExecutionUpdateManyWithoutExecutionNestedInput
    blockchainTransactions?: BlockchainTransactionUpdateManyWithoutExecutionNestedInput
    workflowPauses?: WorkflowPauseUpdateManyWithoutExecutionNestedInput
  }

  export type WorkflowExecutionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    nodeExecutions?: NodeExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    executionLogs?: ExecutionLogUncheckedUpdateManyWithoutExecutionNestedInput
    blockExecutions?: BlockExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    blockchainTransactions?: BlockchainTransactionUncheckedUpdateManyWithoutExecutionNestedInput
    workflowPauses?: WorkflowPauseUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type WorkflowExecutionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMemberUpdateWithoutUserInput = {
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowExecutionCreateManyWorkflowInput = {
    id?: string
    userId: string
    status?: $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerType?: string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowPauseCreateManyWorkflowInput = {
    id?: string
    executionId: string
    nodeId: string
    reason: string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowExecutionUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutWorkflowExecutionsNestedInput
    nodeExecutions?: NodeExecutionUpdateManyWithoutExecutionNestedInput
    executionLogs?: ExecutionLogUpdateManyWithoutExecutionNestedInput
    blockExecutions?: BlockExecutionUpdateManyWithoutExecutionNestedInput
    blockchainTransactions?: BlockchainTransactionUpdateManyWithoutExecutionNestedInput
    workflowPauses?: WorkflowPauseUpdateManyWithoutExecutionNestedInput
  }

  export type WorkflowExecutionUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    nodeExecutions?: NodeExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    executionLogs?: ExecutionLogUncheckedUpdateManyWithoutExecutionNestedInput
    blockExecutions?: BlockExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    blockchainTransactions?: BlockchainTransactionUncheckedUpdateManyWithoutExecutionNestedInput
    workflowPauses?: WorkflowPauseUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type WorkflowExecutionUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowPauseUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    execution?: WorkflowExecutionUpdateOneRequiredWithoutWorkflowPausesNestedInput
  }

  export type WorkflowPauseUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowPauseUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodeExecutionCreateManyExecutionInput = {
    id?: string
    nodeId: string
    status: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string
    durationMs?: number | null
    updatedAt?: Date | string | null
    retryCount?: number | null
    finishedAt?: Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionLogCreateManyExecutionInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BlockExecutionCreateManyExecutionInput = {
    id?: string
    nodeId: string
    blockType: string
    status: $Enums.BlockStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    startTime: Date | string
    endTime?: Date | string | null
  }

  export type BlockchainTransactionCreateManyExecutionInput = {
    id?: string
    nodeId: string
    toAddress: string
    value: string
    data?: NullableJsonNullValueInput | InputJsonValue
    chainId: number
    gasLimit?: string | null
    gasUsed?: string | null
    maxFeePerGas?: string | null
    maxPriorityFeePerGas?: string | null
    nonce?: number | null
    status: string
    hash?: string | null
    txHash?: string | null
    blockNumber?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    walletAddress: string
    effectiveGasPrice?: string | null
    error?: string | null
    fromAddress?: string | null
  }

  export type WorkflowPauseCreateManyExecutionInput = {
    id?: string
    workflowId: string
    nodeId: string
    reason: string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NodeExecutionUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    logs?: NodeLogUpdateManyWithoutNodeExecutionNestedInput
    nodeInputs?: NodeInputUpdateManyWithoutNodeExecutionNestedInput
    nodeOutputs?: NodeOutputUpdateManyWithoutNodeExecutionNestedInput
  }

  export type NodeExecutionUncheckedUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
    logs?: NodeLogUncheckedUpdateManyWithoutNodeExecutionNestedInput
    nodeInputs?: NodeInputUncheckedUpdateManyWithoutNodeExecutionNestedInput
    nodeOutputs?: NodeOutputUncheckedUpdateManyWithoutNodeExecutionNestedInput
  }

  export type NodeExecutionUncheckedUpdateManyWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    output?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionLogUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionLogUncheckedUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionLogUncheckedUpdateManyWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BlockExecutionUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    status?: EnumBlockStatusFieldUpdateOperationsInput | $Enums.BlockStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: BlockExecutionLogUpdateManyWithoutBlockExecutionNestedInput
  }

  export type BlockExecutionUncheckedUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    status?: EnumBlockStatusFieldUpdateOperationsInput | $Enums.BlockStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: BlockExecutionLogUncheckedUpdateManyWithoutBlockExecutionNestedInput
  }

  export type BlockExecutionUncheckedUpdateManyWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    status?: EnumBlockStatusFieldUpdateOperationsInput | $Enums.BlockStatus
    input?: NullableJsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlockchainTransactionUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    chainId?: IntFieldUpdateOperationsInput | number
    gasLimit?: NullableStringFieldUpdateOperationsInput | string | null
    gasUsed?: NullableStringFieldUpdateOperationsInput | string | null
    maxFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    maxPriorityFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: StringFieldUpdateOperationsInput | string
    effectiveGasPrice?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: NullableStringFieldUpdateOperationsInput | string | null
    transactionAttempts?: TransactionAttemptUpdateManyWithoutTransactionNestedInput
  }

  export type BlockchainTransactionUncheckedUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    chainId?: IntFieldUpdateOperationsInput | number
    gasLimit?: NullableStringFieldUpdateOperationsInput | string | null
    gasUsed?: NullableStringFieldUpdateOperationsInput | string | null
    maxFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    maxPriorityFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: StringFieldUpdateOperationsInput | string
    effectiveGasPrice?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: NullableStringFieldUpdateOperationsInput | string | null
    transactionAttempts?: TransactionAttemptUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type BlockchainTransactionUncheckedUpdateManyWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    chainId?: IntFieldUpdateOperationsInput | number
    gasLimit?: NullableStringFieldUpdateOperationsInput | string | null
    gasUsed?: NullableStringFieldUpdateOperationsInput | string | null
    maxFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    maxPriorityFeePerGas?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: StringFieldUpdateOperationsInput | string
    effectiveGasPrice?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkflowPauseUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: WorkflowUpdateOneRequiredWithoutPausesNestedInput
  }

  export type WorkflowPauseUncheckedUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowPauseUncheckedUpdateManyWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    resumeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodeLogCreateManyNodeExecutionInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NodeInputCreateManyNodeExecutionInput = {
    id?: string
    inputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type NodeOutputCreateManyNodeExecutionInput = {
    id?: string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type NodeLogUpdateWithoutNodeExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NodeLogUncheckedUpdateWithoutNodeExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NodeLogUncheckedUpdateManyWithoutNodeExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NodeInputUpdateWithoutNodeExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeInputUncheckedUpdateWithoutNodeExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeInputUncheckedUpdateManyWithoutNodeExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeOutputUpdateWithoutNodeExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeOutputUncheckedUpdateWithoutNodeExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeOutputUncheckedUpdateManyWithoutNodeExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionAttemptCreateManyTransactionInput = {
    id?: string
    txHash?: string | null
    status: string
    error?: string | null
    blockNumber?: number | null
    gasUsed?: string | null
    effectiveGasPrice?: string | null
    createdAt?: Date | string
  }

  export type TransactionAttemptUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    gasUsed?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveGasPrice?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionAttemptUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    gasUsed?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveGasPrice?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionAttemptUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    gasUsed?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveGasPrice?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockExecutionLogCreateManyBlockExecutionInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    timestamp?: Date | string
  }

  export type BlockExecutionLogUpdateWithoutBlockExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockExecutionLogUncheckedUpdateWithoutBlockExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockExecutionLogUncheckedUpdateManyWithoutBlockExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockLibraryRatingCreateManyBlockInput = {
    id?: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type BlockLibraryRatingUpdateWithoutBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockLibraryRatingUncheckedUpdateWithoutBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockLibraryRatingUncheckedUpdateManyWithoutBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyTierInput = {
    id?: string
    userId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    stripeCustomerId?: string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateWithoutTierInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    invoices?: SubscriptionInvoiceUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutTierInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: SubscriptionInvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutTierInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionInvoiceCreateManySubscriptionInput = {
    id?: string
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: string
    paidAt?: Date | string | null
    invoiceUrl?: string | null
    createdAt?: Date | string
  }

  export type SubscriptionInvoiceUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionInvoiceUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionInvoiceUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyTeamInput = {
    userId: string
    role: string
    joinedAt?: Date | string | null
  }

  export type TeamMemberUpdateWithoutTeamInput = {
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowCountOutputTypeDefaultArgs instead
     */
    export type WorkflowCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowExecutionCountOutputTypeDefaultArgs instead
     */
    export type WorkflowExecutionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowExecutionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NodeExecutionCountOutputTypeDefaultArgs instead
     */
    export type NodeExecutionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NodeExecutionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockchainTransactionCountOutputTypeDefaultArgs instead
     */
    export type BlockchainTransactionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockchainTransactionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockExecutionCountOutputTypeDefaultArgs instead
     */
    export type BlockExecutionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockExecutionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockLibraryCountOutputTypeDefaultArgs instead
     */
    export type BlockLibraryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockLibraryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PricingTierCountOutputTypeDefaultArgs instead
     */
    export type PricingTierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PricingTierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamCountOutputTypeDefaultArgs instead
     */
    export type TeamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserWalletDefaultArgs instead
     */
    export type UserWalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserWalletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowTemplateDefaultArgs instead
     */
    export type WorkflowTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowDefaultArgs instead
     */
    export type WorkflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowExecutionDefaultArgs instead
     */
    export type WorkflowExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowExecutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NodeExecutionDefaultArgs instead
     */
    export type NodeExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NodeExecutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NodeLogDefaultArgs instead
     */
    export type NodeLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NodeLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NodeInputDefaultArgs instead
     */
    export type NodeInputArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NodeInputDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NodeOutputDefaultArgs instead
     */
    export type NodeOutputArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NodeOutputDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExecutionLogDefaultArgs instead
     */
    export type ExecutionLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExecutionLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowPauseDefaultArgs instead
     */
    export type WorkflowPauseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowPauseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockchainTransactionDefaultArgs instead
     */
    export type BlockchainTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockchainTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionAttemptDefaultArgs instead
     */
    export type TransactionAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionAttemptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AiBlockchainOperationDefaultArgs instead
     */
    export type AiBlockchainOperationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AiBlockchainOperationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockExecutionDefaultArgs instead
     */
    export type BlockExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockExecutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockExecutionLogDefaultArgs instead
     */
    export type BlockExecutionLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockExecutionLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockLibraryDefaultArgs instead
     */
    export type BlockLibraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockLibraryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockLibraryRatingDefaultArgs instead
     */
    export type BlockLibraryRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockLibraryRatingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomBlockDefaultArgs instead
     */
    export type CustomBlockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomBlockDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExecutionQueueDefaultArgs instead
     */
    export type ExecutionQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExecutionQueueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExecutionNodeStatusDefaultArgs instead
     */
    export type ExecutionNodeStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExecutionNodeStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CircuitBreakerStateDefaultArgs instead
     */
    export type CircuitBreakerStateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CircuitBreakerStateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationPreferenceDefaultArgs instead
     */
    export type NotificationPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationPreferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationTemplateDefaultArgs instead
     */
    export type NotificationTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationLogDefaultArgs instead
     */
    export type NotificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PricingTierDefaultArgs instead
     */
    export type PricingTierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PricingTierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionInvoiceDefaultArgs instead
     */
    export type SubscriptionInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionInvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamDefaultArgs instead
     */
    export type TeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamMemberDefaultArgs instead
     */
    export type TeamMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsageLogDefaultArgs instead
     */
    export type UsageLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsageLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WalletTransactionDefaultArgs instead
     */
    export type WalletTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WalletTransactionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}