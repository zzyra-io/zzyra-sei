// Prisma schema for Zyra platform
// This schema represents a migration from Supabase to Prisma

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ================ Enums ================

enum BlockStatus {
  pending
  running
  completed
  failed

  @@map("block_status")
}

enum LogLevel {
  info
  error
  warn

  @@map("log_level")
}

enum WorkflowStatus {
  pending
  running
  completed
  failed
  paused

  @@map("workflow_status")
}

// ================ Authentication & Users ================

model User {
  id        String   @id @default(uuid())
  email     String?  @unique
  phone     String?  @unique
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  profile                 Profile?
  userWallets             UserWallet[]
  workflows               Workflow[]
  workflowExecutions      WorkflowExecution[]
  notifications           Notification[]
  subscription            Subscription?
  teamMemberships         TeamMember[]
  ownedTeams              Team[]                  @relation("TeamOwner")
  notificationPreferences NotificationPreference?

  @@map("users")
}

model Profile {
  id                    String    @id
  email                 String?
  fullName              String?   @map("full_name")
  avatarUrl             String?   @map("avatar_url")
  subscriptionTier      String?   @default("free") @map("subscription_tier")
  subscriptionStatus    String?   @default("inactive") @map("subscription_status")
  subscriptionExpiresAt DateTime? @map("subscription_expires_at")
  monthlyExecutionQuota Int?      @default(100) @map("monthly_execution_quota")
  monthlyExecutionCount Int?      @default(0) @map("monthly_execution_count")
  stripeCustomerId      String?   @map("stripe_customer_id")
  stripeSubscriptionId  String?   @map("stripe_subscription_id")
  createdAt             DateTime? @default(now()) @map("created_at")
  updatedAt             DateTime? @default(now()) @map("updated_at")
  lastSeenAt            DateTime? @default(now()) @map("last_seen_at")
  monthlyExecutionsUsed Int       @default(0) @map("monthly_executions_used")
  telegramChatId        String?   @map("telegram_chat_id")
  discordWebhookUrl     String?   @map("discord_webhook_url")

  // Relations
  user User @relation(fields: [id], references: [id], onDelete: Cascade)

  @@map("profiles")
}

model UserWallet {
  id            String   @id @default(uuid())
  userId        String   @map("user_id")
  chainId       String   @map("chain_id")
  walletAddress String   @map("wallet_address")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @default(now()) @map("updated_at")
  walletType    String?  @map("wallet_type")
  chainType     String?  @map("chain_type")
  metadata      Json?    @default("{}")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([walletAddress])
  @@map("user_wallets")
}

// ================ Workflows & Execution ================

model WorkflowTemplate {
  id          String    @id @default(uuid())
  name        String
  description String?
  category    String?
  nodes       Json?     @default("[]")
  edges       Json?     @default("[]")
  createdAt   DateTime? @default(now()) @map("created_at")
  updatedAt   DateTime? @default(now()) @map("updated_at")

  @@map("workflow_templates")
}

model Workflow {
  id          String    @id @default(uuid())
  userId      String    @map("user_id")
  name        String
  description String?
  nodes       Json?     @default("[]")
  edges       Json?     @default("[]")
  isPublic    Boolean?  @default(false) @map("is_public")
  tags        String[]  @default([])
  createdAt   DateTime? @default(now()) @map("created_at")
  updatedAt   DateTime? @default(now()) @map("updated_at")
  definition  Json      @default("{}")
  version     Int       @default(1)
  createdBy   String?   @map("created_by")

  // Relations
  user       User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  executions WorkflowExecution[]
  pauses     WorkflowPause[]

  @@index([userId])
  @@map("workflows")
}

model WorkflowExecution {
  id          String         @id @default(uuid())
  workflowId  String         @map("workflow_id")
  userId      String         @map("user_id")
  status      WorkflowStatus @default(pending)
  input       Json?          @default("{}")
  output      Json?
  startedAt   DateTime       @default(now()) @map("started_at")
  finishedAt  DateTime?      @map("finished_at")
  error       String?
  metadata    Json?          @default("{}")
  createdAt   DateTime       @default(now()) @map("created_at")
  updatedAt   DateTime       @default(now()) @map("updated_at")
  triggerType String?        @map("trigger_type")
  triggerData Json?          @map("trigger_data")
  lockedBy    String?        @map("locked_by")
  logs        Json?

  // Relations
  workflow               Workflow                @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  user                   User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  nodeExecutions         NodeExecution[]
  executionLogs          ExecutionLog[]
  blockExecutions        BlockExecution[]
  blockchainTransactions BlockchainTransaction[]
  workflowPauses         WorkflowPause[]

  @@index([workflowId])
  @@index([userId])
  @@index([status])
  @@map("workflow_executions")
}

model NodeExecution {
  id          String    @id @default(uuid())
  executionId String    @map("execution_id")
  nodeId      String    @map("node_id")
  status      String
  outputData  Json?     @map("output_data")
  error       String?
  startedAt   DateTime  @default(now()) @map("started_at")
  completedAt DateTime  @default(now()) @map("completed_at")
  durationMs  Int?      @map("duration_ms")
  updatedAt   DateTime? @default(now()) @map("updated_at")
  retryCount  Int?      @default(0) @map("retry_count")
  finishedAt  DateTime? @map("finished_at")
  output      Json?

  // Relations
  execution   WorkflowExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)
  logs        NodeLog[]
  nodeInputs  NodeInput[]
  nodeOutputs NodeOutput[]

  @@unique([executionId, nodeId])
  @@index([executionId])
  @@index([nodeId])
  @@map("node_executions")
}

model NodeLog {
  id              String   @id @default(uuid())
  nodeExecutionId String   @map("node_execution_id")
  level           LogLevel
  message         String
  createdAt       DateTime @default(now()) @map("created_at")
  metadata        Json?    @default("{}")

  // Relations
  nodeExecution NodeExecution @relation(fields: [nodeExecutionId], references: [id], onDelete: Cascade)

  @@index([nodeExecutionId])
  @@map("node_logs")
}

model NodeInput {
  id          String    @id @default(uuid())
  executionId String    @map("execution_id")
  nodeId      String    @map("node_id")
  inputData   Json?     @map("input_data")
  createdAt   DateTime? @default(now()) @map("created_at")

  // Relations
  nodeExecution NodeExecution @relation(fields: [executionId, nodeId], references: [executionId, nodeId], onDelete: Cascade)

  @@index([executionId])
  @@index([nodeId])
  @@map("node_inputs")
}

model NodeOutput {
  id          String    @id @default(uuid())
  executionId String    @map("execution_id")
  nodeId      String    @map("node_id")
  outputData  Json?     @map("output_data")
  createdAt   DateTime? @default(now()) @map("created_at")

  // Relations
  nodeExecution NodeExecution @relation(fields: [executionId, nodeId], references: [executionId, nodeId], onDelete: Cascade)

  @@index([executionId])
  @@index([nodeId])
  @@map("node_outputs")
}

model ExecutionLog {
  id          String   @id @default(uuid())
  executionId String   @map("execution_id")
  level       LogLevel
  message     String
  timestamp   DateTime @default(now())
  metadata    Json?    @default("{}")

  // Relations
  execution WorkflowExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)

  @@index([executionId])
  @@map("execution_logs")
}

model WorkflowPause {
  id          String   @id @default(uuid())
  workflowId  String   @map("workflow_id")
  executionId String   @map("execution_id")
  nodeId      String   @map("node_id")
  reason      String
  resumeData  Json?    @map("resume_data")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @default(now()) @map("updated_at")

  // Relations
  workflow  Workflow          @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  execution WorkflowExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)

  @@index([workflowId])
  @@index([executionId])
  @@map("workflow_pauses")
}

// ================ Blockchain & AI Integration ================

model BlockchainTransaction {
  id                   String   @id @default(uuid())
  nodeId               String   @map("node_id")
  executionId          String   @map("execution_id")
  toAddress            String   @map("to_address")
  value                String
  data                 Json?
  chainId              Int      @map("chain_id")
  gasLimit             String?  @map("gas_limit")
  gasUsed              String?  @map("gas_used")
  maxFeePerGas         String?  @map("max_fee_per_gas")
  maxPriorityFeePerGas String?  @map("max_priority_fee_per_gas")
  nonce                Int?
  status               String
  hash                 String?
  txHash               String?  @map("tx_hash")
  blockNumber          Int?     @map("block_number")
  createdAt            DateTime @default(now()) @map("created_at")
  updatedAt            DateTime @default(now()) @map("updated_at")
  userId               String?  @map("user_id")
  walletAddress        String   @map("wallet_address")
  effectiveGasPrice    String?  @map("effective_gas_price")
  error                String?
  fromAddress          String?  @map("from_address")

  // Relations
  execution           WorkflowExecution    @relation(fields: [executionId], references: [id], onDelete: Cascade)
  transactionAttempts TransactionAttempt[]

  @@index([executionId])
  @@index([nodeId])
  @@map("blockchain_transactions")
}

model TransactionAttempt {
  id                String   @id @default(uuid())
  transactionId     String   @map("transaction_id")
  txHash            String?  @map("tx_hash")
  status            String
  error             String?
  blockNumber       Int?     @map("block_number")
  gasUsed           String?  @map("gas_used")
  effectiveGasPrice String?  @map("effective_gas_price")
  createdAt         DateTime @default(now()) @map("created_at")

  // Relations
  transaction BlockchainTransaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  @@index([transactionId])
  @@map("transaction_attempts")
}

model AiBlockchainOperation {
  id            String   @id @default(uuid())
  userId        String   @map("user_id")
  executionId   String   @map("execution_id")
  nodeId        String   @map("node_id")
  operationType String   @map("operation_type")
  blockchain    String?
  prompt        String?
  result        Json?
  status        String
  error         String?
  createdAt     DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([executionId])
  @@map("ai_blockchain_operations")
}

// ================ Block & Execution Models ================

model BlockExecution {
  id          String      @id @default(uuid())
  executionId String      @map("execution_id")
  nodeId      String      @map("node_id")
  blockType   String      @map("block_type")
  status      BlockStatus
  input       Json?
  output      Json?
  error       String?
  startTime   DateTime    @map("start_time")
  endTime     DateTime?   @map("end_time")

  // Relations
  execution WorkflowExecution   @relation(fields: [executionId], references: [id], onDelete: Cascade)
  logs      BlockExecutionLog[]

  @@index([executionId])
  @@index([nodeId])
  @@map("block_executions")
}

model BlockExecutionLog {
  id               String   @id @default(uuid())
  blockExecutionId String   @map("block_execution_id")
  level            LogLevel
  message          String
  timestamp        DateTime @default(now())

  // Relations
  blockExecution BlockExecution @relation(fields: [blockExecutionId], references: [id], onDelete: Cascade)

  @@index([blockExecutionId])
  @@map("block_execution_logs")
}

model BlockLibrary {
  id            String               @id @default(uuid())
  name          String
  description   String
  blockType     String               @map("block_type")
  category      String?
  configuration Json                 @default("{}")
  blockData     Json?
  executionCode String?
  userId        String               @map("user_id")
  isPublic      Boolean?             @default(false) @map("is_public")
  isVerified    Boolean?             @map("is_verified")
  rating        Float?
  usageCount    Int?                 @map("usage_count")
  tags          String[]             @default([])
  version       String?
  createdAt     DateTime?            @default(now()) @map("created_at")
  updatedAt     DateTime?            @default(now()) @map("updated_at")
  ratings       BlockLibraryRating[]

  @@map("block_library")
}

model BlockLibraryRating {
  id        String   @id @default(uuid())
  blockId   String   @map("block_id")
  userId    String   @map("user_id")
  rating    Int
  comment   String?
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  block BlockLibrary @relation(fields: [blockId], references: [id], onDelete: Cascade)

  @@unique([blockId, userId])
  @@map("block_library_ratings")
}

model CustomBlock {
  id          String    @id @default(uuid())
  userId      String    @map("user_id")
  name        String
  description String?
  blockType   String?   @map("block_type")
  category    String
  code        String
  logic       String
  logicType   String    @map("logic_type")
  blockData   Json?     @default("{}") @map("block_data")
  tags        Json      @default("[]")
  createdBy   String?   @map("created_by")
  icon        String?
  isPublic    Boolean?  @default(false) @map("is_public")
  isVerified  Boolean?  @map("is_verified")
  rating      Float?
  usageCount  Int?      @map("usage_count")
  version     String?
  createdAt   DateTime? @default(now()) @map("created_at")
  updatedAt   DateTime? @default(now()) @map("updated_at")
  updatedBy   String?   @map("updated_by")

  @@index([userId])
  @@map("custom_blocks")
}

// ================ Execution Queue & Status ================

model ExecutionQueue {
  id           String    @id @default(uuid())
  workflowId   String    @map("workflow_id")
  executionId  String    @map("execution_id")
  userId       String?   @map("user_id")
  priority     Int       @default(0)
  status       String    @default("pending")
  payload      Json?
  error        String?
  retryCount   Int       @default(0) @map("retry_count")
  maxRetries   Int       @default(3) @map("max_retries")
  lockedBy     String?   @map("locked_by")
  lockedUntil  DateTime? @map("locked_until")
  scheduledFor DateTime  @default(now()) @map("scheduled_for")
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @default(now()) @map("updated_at")

  @@index([status])
  @@index([userId])
  @@map("execution_queue")
}

model ExecutionNodeStatus {
  id            String   @id @default(uuid())
  nodeId        String   @unique @map("node_id")
  status        String   @default("idle")
  lastHeartbeat DateTime @default(now()) @map("last_heartbeat")
  metadata      Json?    @default("{}")

  @@map("execution_node_status")
}

model CircuitBreakerState {
  id               String    @id @default(uuid())
  circuitId        String    @map("circuit_id")
  state            String    @default("closed")
  failureCount     Int       @default(0) @map("failure_count")
  successCount     Int       @default(0) @map("success_count")
  lastFailureTime  DateTime? @map("last_failure_time")
  lastSuccessTime  DateTime? @map("last_success_time")
  lastHalfOpenTime DateTime? @map("last_half_open_time")
  createdAt        DateTime  @default(now()) @map("created_at")
  updatedAt        DateTime  @default(now()) @map("updated_at")

  @@map("circuit_breaker_state")
}

// ================ Notifications & Subscriptions ================

model Notification {
  id        String    @id @default(uuid())
  userId    String    @map("user_id")
  title     String
  message   String
  type      String
  read      Boolean   @default(false)
  data      Json?
  createdAt DateTime? @default(now()) @map("created_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("notifications")
}

model NotificationPreference {
  id                String    @id @default(uuid())
  userId            String    @unique @map("user_id")
  emailEnabled      Boolean   @default(true) @map("email_enabled")
  pushEnabled       Boolean   @default(true) @map("push_enabled")
  webhookEnabled    Boolean   @default(true) @map("webhook_enabled")
  createdAt         DateTime? @default(now()) @map("created_at")
  updatedAt         DateTime? @default(now()) @map("updated_at")
  telegramChatId    String?   @map("telegram_chat_id")
  discordWebhookUrl String?   @map("discord_webhook_url")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_preferences")
}

model NotificationTemplate {
  id        String   @id @default(uuid())
  type      String
  title     String
  message   String
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @map("updated_at")

  @@unique([type])
  @@map("notification_templates")
}

model NotificationLog {
  id             String   @id @default(uuid())
  userId         String   @map("user_id")
  channel        String
  status         String
  error          String?
  notificationId String?  @map("notification_id")
  createdAt      DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@map("notification_logs")
}

// ================ Subscriptions & Billing ================

model PricingTier {
  id             String   @id @default(uuid())
  name           String
  description    String?
  priceMonthly   Decimal  @map("price_monthly")
  priceYearly    Decimal  @map("price_yearly")
  workflowLimit  Int      @map("workflow_limit")
  executionLimit Int      @map("execution_limit")
  features       Json     @default("{}")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @default(now()) @map("updated_at")

  // Relations
  subscriptions Subscription[]

  @@map("pricing_tiers")
}

model Subscription {
  id                   String    @id @default(uuid())
  userId               String    @unique @map("user_id")
  tierId               String    @map("tier_id")
  status               String
  currentPeriodStart   DateTime  @map("current_period_start")
  currentPeriodEnd     DateTime  @map("current_period_end")
  cancelAtPeriodEnd    Boolean   @default(false) @map("cancel_at_period_end")
  stripeSubscriptionId String?   @map("stripe_subscription_id")
  stripePriceId        String?   @map("stripe_price_id")
  stripeCustomerId     String?   @map("stripe_customer_id")
  canceledAt           DateTime? @map("canceled_at")
  createdAt            DateTime  @default(now()) @map("created_at")
  updatedAt            DateTime  @default(now()) @map("updated_at")

  // Relations
  user     User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  tier     PricingTier           @relation(fields: [tierId], references: [id])
  invoices SubscriptionInvoice[]

  @@map("subscriptions")
}

model SubscriptionInvoice {
  id              String    @id @default(uuid())
  subscriptionId  String    @map("subscription_id")
  stripeInvoiceId String?   @map("stripe_invoice_id")
  amount          Decimal
  status          String
  paidAt          DateTime? @map("paid_at")
  invoiceUrl      String?   @map("invoice_url")
  createdAt       DateTime  @default(now()) @map("created_at")

  // Relations
  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@map("subscription_invoices")
}

// ================ Teams ================

model Team {
  id          String    @id @default(uuid())
  name        String
  description String?
  createdBy   String    @map("created_by")
  createdAt   DateTime? @default(now()) @map("created_at")
  updatedAt   DateTime? @default(now()) @map("updated_at")

  // Relations
  owner   User         @relation("TeamOwner", fields: [createdBy], references: [id], onDelete: Cascade)
  members TeamMember[]

  @@map("teams")
}

model TeamMember {
  teamId   String    @map("team_id")
  userId   String    @map("user_id")
  role     String
  joinedAt DateTime? @default(now()) @map("joined_at")

  // Relations
  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([teamId, userId])
  @@map("team_members")
}

// ================ Auditing & Usage ================

model AuditLog {
  id         String   @id @default(uuid())
  userId     String?  @map("user_id")
  action     String
  resource   String?
  resourceId String?  @map("resource_id")
  metadata   Json?
  createdAt  DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([action])
  @@map("audit_logs")
}

model UsageLog {
  id           String   @id @default(uuid())
  userId       String   @map("user_id")
  resourceType String   @map("resource_type")
  action       String
  quantity     Int      @default(1)
  metadata     Json?
  createdAt    DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([resourceType])
  @@map("usage_logs")
}

// ================ Wallet & Transaction ================

model WalletTransaction {
  id            String   @id @default(uuid())
  userId        String   @map("user_id")
  walletAddress String   @map("wallet_address")
  txHash        String   @map("tx_hash")
  chainId       Int      @map("chain_id")
  value         String
  status        String
  blockNumber   Int?     @map("block_number")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @default(now()) @map("updated_at")

  @@index([userId])
  @@index([walletAddress])
  @@index([txHash])
  @@map("wallet_transactions")
}
