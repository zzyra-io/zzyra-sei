// Prisma schema for Zzyra platform
// This schema represents a migration from Supabase to Prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ================ Enums ================

enum BlockStatus {
  pending
  running
  completed
  failed

  @@map("block_status")
}

enum LogLevel {
  info
  error
  warn

  @@map("log_level")
}

enum WorkflowStatus {
  pending
  running
  completed
  failed
  paused

  @@map("workflow_status")
}

// ================ Authentication & Users ================

model User {
  id                   String        @id @default(uuid())
  email                String?       @unique
  phone                String?       @unique
  createdAt            DateTime      @default(now()) @map("created_at")
  updatedAt            DateTime      @updatedAt @map("updated_at")
  
  // Relations
  profile              Profile?
  userWallets          UserWallet[]
  workflows            Workflow[]
  workflowExecutions   WorkflowExecution[]
  notifications        Notification[]
  subscription         Subscription?
  teamMemberships      TeamMember[]
  ownedTeams           Team[]         @relation("TeamOwner")
  notificationPreferences NotificationPreference?

  @@map("users")
}

model Profile {
  id                   String        @id
  email                String?
  fullName             String?       @map("full_name")
  avatarUrl            String?       @map("avatar_url")
  subscriptionTier     String?       @default("free") @map("subscription_tier")
  subscriptionStatus   String?       @default("inactive") @map("subscription_status")
  subscriptionExpiresAt DateTime?    @map("subscription_expires_at")
  monthlyExecutionQuota Int?         @default(100) @map("monthly_execution_quota")
  monthlyExecutionCount Int?         @default(0) @map("monthly_execution_count")
  stripeCustomerId     String?       @map("stripe_customer_id")
  stripeSubscriptionId String?       @map("stripe_subscription_id")
  createdAt            DateTime?     @default(now()) @map("created_at")
  updatedAt            DateTime?     @default(now()) @map("updated_at")
  lastSeenAt           DateTime?     @default(now()) @map("last_seen_at")
  monthlyExecutionsUsed Int          @default(0) @map("monthly_executions_used")
  telegramChatId       String?       @map("telegram_chat_id")
  discordWebhookUrl    String?       @map("discord_webhook_url")
  
  // Relations
  user                 User          @relation(fields: [id], references: [id], onDelete: Cascade)

  @@map("profiles")
}

model UserWallet {
  id                   String        @id @default(uuid())
  userId               String        @map("user_id")
  chainId              String        @map("chain_id")
  walletAddress        String        @map("wallet_address") @unique
  createdAt            DateTime      @default(now()) @map("created_at")
  updatedAt            DateTime      @default(now()) @map("updated_at")
  walletType           String?       @map("wallet_type")
  chainType            String?       @map("chain_type")
  metadata             Json?         @default("{}")
  
  // Relations
  user                 User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_wallets")
  @@index([userId])
  @@index([walletAddress])
}

// ================ Workflows & Execution ================

model WorkflowTemplate {
  id                   String        @id @default(uuid())
  name                 String
  description          String?
  category             String?
  nodes                Json?         @default("[]")
  edges                Json?         @default("[]")
  createdAt            DateTime?     @default(now()) @map("created_at")
  updatedAt            DateTime?     @default(now()) @map("updated_at")
  
  @@map("workflow_templates")
}

model Workflow {
  id                   String        @id @default(uuid())
  userId               String        @map("user_id")
  name                 String
  description          String?
  nodes                Json?         @default("[]")
  edges                Json?         @default("[]")
  isPublic             Boolean?      @default(false) @map("is_public")
  tags                 String[]      @default([])
  createdAt            DateTime?     @default(now()) @map("created_at")
  updatedAt            DateTime?     @default(now()) @map("updated_at")
  definition           Json          @default("{}")
  version              Int           @default(1)
  createdBy            String?       @map("created_by")
  
  // Relations
  user                 User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  executions           WorkflowExecution[]
  pauses               WorkflowPause[]
  
  @@map("workflows")
  @@index([userId])
}

model WorkflowExecution {
  id                   String          @id @default(uuid())
  workflowId           String          @map("workflow_id")
  userId               String          @map("user_id")
  status               WorkflowStatus  @default(pending)
  input                Json?           @default("{}")
  output               Json?
  startedAt            DateTime        @default(now()) @map("started_at")
  finishedAt           DateTime?       @map("finished_at")
  error                String?
  metadata             Json?           @default("{}")
  createdAt            DateTime        @default(now()) @map("created_at")
  updatedAt            DateTime        @default(now()) @map("updated_at")
  triggerType          String?         @map("trigger_type")
  triggerData          Json?           @map("trigger_data")
  lockedBy             String?         @map("locked_by")
  logs                 Json?           
  
  // Relations
  workflow             Workflow      @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  user                 User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  nodeExecutions       NodeExecution[]
  executionLogs        ExecutionLog[]
  blockExecutions      BlockExecution[]
  blockchainTransactions BlockchainTransaction[]
  workflowPauses       WorkflowPause[]
  
  @@map("workflow_executions")
  @@index([workflowId])
  @@index([userId])
  @@index([status])
}

model NodeExecution {
  id                   String        @id @default(uuid())
  executionId          String        @map("execution_id")
  nodeId               String        @map("node_id")
  status               String
  outputData           Json?         @map("output_data")
  error                String?
  startedAt            DateTime      @default(now()) @map("started_at")
  completedAt          DateTime      @default(now()) @map("completed_at")
  durationMs           Int?          @map("duration_ms")
  updatedAt            DateTime?     @default(now()) @map("updated_at")
  retryCount           Int?          @default(0) @map("retry_count")
  finishedAt           DateTime?     @map("finished_at")
  output               Json?
  
  // Relations
  execution            WorkflowExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)
  logs                 NodeLog[]
  nodeInputs           NodeInput[]
  nodeOutputs          NodeOutput[]
  
  @@map("node_executions")
  @@index([executionId])
  @@index([nodeId])
  @@unique([executionId, nodeId])
}

model NodeLog {
  id                   String        @id @default(uuid())
  nodeExecutionId      String        @map("node_execution_id")
  level                LogLevel
  message              String
  createdAt            DateTime      @default(now()) @map("created_at")
  metadata             Json?         @default("{}")
  
  // Relations
  nodeExecution        NodeExecution @relation(fields: [nodeExecutionId], references: [id], onDelete: Cascade)
  
  @@map("node_logs")
  @@index([nodeExecutionId])
}

model NodeInput {
  id                   String        @id @default(uuid())
  executionId          String        @map("execution_id")
  nodeId               String        @map("node_id")
  inputData            Json?         @map("input_data")
  createdAt            DateTime?     @default(now()) @map("created_at")
  
  // Relations
  nodeExecution        NodeExecution @relation(fields: [executionId, nodeId], references: [executionId, nodeId], onDelete: Cascade)
  
  @@map("node_inputs")
  @@index([executionId])
  @@index([nodeId])
}

model NodeOutput {
  id                   String        @id @default(uuid())
  executionId          String        @map("execution_id")
  nodeId               String        @map("node_id")
  outputData           Json?         @map("output_data")
  createdAt            DateTime?     @default(now()) @map("created_at")
  
  // Relations
  nodeExecution        NodeExecution @relation(fields: [executionId, nodeId], references: [executionId, nodeId], onDelete: Cascade)
  
  @@map("node_outputs")
  @@index([executionId])
  @@index([nodeId])
}

model ExecutionLog {
  id                   String        @id @default(uuid())
  executionId          String        @map("execution_id")
  level                LogLevel
  message              String
  timestamp            DateTime      @default(now())
  metadata             Json?         @default("{}")
  
  // Relations
  execution            WorkflowExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)
  
  @@map("execution_logs")
  @@index([executionId])
}

model WorkflowPause {
  id                   String        @id @default(uuid())
  workflowId           String        @map("workflow_id")
  executionId          String        @map("execution_id")
  nodeId               String        @map("node_id")
  reason               String
  resumeData           Json?         @map("resume_data")
  createdAt            DateTime      @default(now()) @map("created_at")
  updatedAt            DateTime      @default(now()) @map("updated_at")
  
  // Relations
  workflow             Workflow      @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  execution            WorkflowExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)
  
  @@map("workflow_pauses")
  @@index([workflowId])
  @@index([executionId])
}

// ================ Blockchain & AI Integration ================

model BlockchainTransaction {
  id                   String        @id @default(uuid())
  nodeId               String        @map("node_id")
  executionId          String        @map("execution_id")
  toAddress            String        @map("to_address")
  value                String
  data                 Json?
  chainId              Int           @map("chain_id")
  gasLimit             String?       @map("gas_limit")
  gasUsed              String?       @map("gas_used")
  maxFeePerGas         String?       @map("max_fee_per_gas")
  maxPriorityFeePerGas String?       @map("max_priority_fee_per_gas")
  nonce                Int?
  status               String
  hash                 String?       
  txHash               String?       @map("tx_hash")
  blockNumber          Int?          @map("block_number")
  createdAt            DateTime      @default(now()) @map("created_at")
  updatedAt            DateTime      @default(now()) @map("updated_at")
  userId               String?       @map("user_id")
  walletAddress        String        @map("wallet_address")
  effectiveGasPrice    String?       @map("effective_gas_price")
  error                String?
  fromAddress          String?       @map("from_address")
  
  // Relations
  execution            WorkflowExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)
  transactionAttempts  TransactionAttempt[]
  
  @@map("blockchain_transactions")
  @@index([executionId])
  @@index([nodeId])
}

model TransactionAttempt {
  id                   String        @id @default(uuid())
  transactionId        String        @map("transaction_id")
  txHash               String?       @map("tx_hash")
  status               String
  error                String?
  blockNumber          Int?          @map("block_number")
  gasUsed              String?       @map("gas_used")
  effectiveGasPrice    String?       @map("effective_gas_price")
  createdAt            DateTime      @default(now()) @map("created_at")
  
  // Relations
  transaction          BlockchainTransaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  
  @@map("transaction_attempts")
  @@index([transactionId])
}

model AiBlockchainOperation {
  id                   String        @id @default(uuid())
  userId               String        @map("user_id")
  executionId          String        @map("execution_id")
  nodeId               String        @map("node_id")
  operationType        String        @map("operation_type")
  blockchain           String?
  prompt               String?
  result               Json?
  status               String
  error                String?
  createdAt            DateTime      @default(now()) @map("created_at")
  
  @@map("ai_blockchain_operations")
  @@index([userId])
  @@index([executionId])
}

// ================ Block & Execution Models ================

model BlockExecution {
  id                   String        @id @default(uuid())
  executionId          String        @map("execution_id")
  nodeId               String        @map("node_id")
  blockType            String        @map("block_type")
  status               BlockStatus
  input                Json?
  output               Json?
  error                String?
  startTime            DateTime      @map("start_time")
  endTime              DateTime?     @map("end_time")
  
  // Relations
  execution            WorkflowExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)
  logs                 BlockExecutionLog[]
  
  @@map("block_executions")
  @@index([executionId])
  @@index([nodeId])
}

model BlockExecutionLog {
  id                   String        @id @default(uuid())
  blockExecutionId     String        @map("block_execution_id")
  level                LogLevel
  message              String
  timestamp            DateTime      @default(now())
  
  // Relations
  blockExecution       BlockExecution @relation(fields: [blockExecutionId], references: [id], onDelete: Cascade)
  
  @@map("block_execution_logs")
  @@index([blockExecutionId])
}

model BlockLibrary {
  id                   String        @id @default(uuid())
  name                 String
  description          String
  blockType            String        @map("block_type")
  category             String?
  configuration        Json          @default("{}")
  blockData            Json?
  executionCode        String?
  userId               String        @map("user_id")
  isPublic             Boolean?      @default(false) @map("is_public")
  isVerified           Boolean?      @map("is_verified")
  rating               Float?        
  usageCount           Int?          @map("usage_count")
  tags                 String[]      @default([])
  version              String?
  createdAt            DateTime?     @default(now()) @map("created_at")
  updatedAt            DateTime?     @default(now()) @map("updated_at")
  ratings              BlockLibraryRating[]
  
  @@map("block_library")
}

model BlockLibraryRating {
  id                   String        @id @default(uuid())
  blockId              String        @map("block_id")
  userId               String        @map("user_id")
  rating               Int
  comment              String?
  createdAt            DateTime      @default(now()) @map("created_at")
  
  // Relations
  block                BlockLibrary  @relation(fields: [blockId], references: [id], onDelete: Cascade)
  
  @@map("block_library_ratings")
  @@unique([blockId, userId])
}

model CustomBlock {
  id                   String        @id @default(uuid())
  userId               String        @map("user_id")
  name                 String
  description          String?
  blockType            String?       @map("block_type")
  category             String
  code                 String
  logic                String
  logicType            String        @map("logic_type")
  blockData            Json?         @default("{}") @map("block_data")
  tags                 Json          @default("[]")
  createdBy            String?       @map("created_by")
  icon                 String?
  isPublic             Boolean?      @default(false) @map("is_public")
  isVerified           Boolean?      @map("is_verified")
  rating               Float?        
  usageCount           Int?          @map("usage_count")
  version              String?
  createdAt            DateTime?     @default(now()) @map("created_at")
  updatedAt            DateTime?     @default(now()) @map("updated_at")
  updatedBy            String?       @map("updated_by")
  
  @@map("custom_blocks")
  @@index([userId])
}

// ================ Execution Queue & Status ================

model ExecutionQueue {
  id                   String        @id @default(uuid())
  workflowId           String        @map("workflow_id")
  executionId          String        @map("execution_id")
  userId               String?       @map("user_id")
  priority             Int           @default(0)
  status               String        @default("pending")
  payload              Json?         
  error                String?
  retryCount           Int           @default(0) @map("retry_count")
  maxRetries           Int           @default(3) @map("max_retries")
  lockedBy             String?       @map("locked_by")
  lockedUntil          DateTime?     @map("locked_until")
  scheduledFor         DateTime      @default(now()) @map("scheduled_for")
  createdAt            DateTime      @default(now()) @map("created_at")
  updatedAt            DateTime      @default(now()) @map("updated_at")
  
  @@map("execution_queue")
  @@index([status])
  @@index([userId])
}

model ExecutionNodeStatus {
  id                   String        @id @default(uuid())
  nodeId               String        @unique @map("node_id")
  status               String        @default("idle")
  lastHeartbeat        DateTime      @default(now()) @map("last_heartbeat")
  metadata             Json?         @default("{}")
  
  @@map("execution_node_status")
}

model CircuitBreakerState {
  id                   String        @id @default(uuid())
  circuitId            String        @map("circuit_id")
  state                String        @default("closed")
  failureCount         Int           @default(0) @map("failure_count")
  successCount         Int           @default(0) @map("success_count")
  lastFailureTime      DateTime?     @map("last_failure_time")
  lastSuccessTime      DateTime?     @map("last_success_time")
  lastHalfOpenTime     DateTime?     @map("last_half_open_time")
  createdAt            DateTime      @default(now()) @map("created_at")
  updatedAt            DateTime      @default(now()) @map("updated_at")
  
  @@map("circuit_breaker_state")
}

// ================ Notifications & Subscriptions ================

model Notification {
  id                   String        @id @default(uuid())
  userId               String        @map("user_id")
  title                String
  message              String
  type                 String
  read                 Boolean       @default(false)
  data                 Json?
  createdAt            DateTime?     @default(now()) @map("created_at")
  
  // Relations
  user                 User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("notifications")
  @@index([userId])
}

model NotificationPreference {
  id                   String        @id @default(uuid())
  userId               String        @unique @map("user_id")
  emailEnabled         Boolean       @default(true) @map("email_enabled")
  pushEnabled          Boolean       @default(true) @map("push_enabled")
  webhookEnabled       Boolean       @default(true) @map("webhook_enabled")
  createdAt            DateTime?     @default(now()) @map("created_at")
  updatedAt            DateTime?     @default(now()) @map("updated_at")
  telegramChatId       String?       @map("telegram_chat_id")
  discordWebhookUrl    String?       @map("discord_webhook_url")
  
  // Relations
  user                 User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("notification_preferences")
}

model NotificationTemplate {
  id                   String        @id @default(uuid())
  type                 String
  title                String
  message              String
  createdAt            DateTime      @default(now()) @map("created_at")
  updatedAt            DateTime      @default(now()) @map("updated_at")
  
  @@map("notification_templates")
  @@unique([type])
}

model NotificationLog {
  id                   String        @id @default(uuid())
  userId               String        @map("user_id")
  channel              String
  status               String
  error                String?
  notificationId       String?       @map("notification_id")
  createdAt            DateTime      @default(now()) @map("created_at")
  
  @@map("notification_logs")
  @@index([userId])
}

// ================ Subscriptions & Billing ================

model PricingTier {
  id                   String        @id @default(uuid())
  name                 String
  description          String?
  priceMonthly         Decimal       @map("price_monthly")
  priceYearly          Decimal       @map("price_yearly")
  workflowLimit        Int           @map("workflow_limit")
  executionLimit       Int           @map("execution_limit")
  features             Json          @default("{}")
  createdAt            DateTime      @default(now()) @map("created_at")
  updatedAt            DateTime      @default(now()) @map("updated_at")
  
  // Relations
  subscriptions        Subscription[]
  
  @@map("pricing_tiers")
}

model Subscription {
  id                   String        @id @default(uuid())
  userId               String        @unique @map("user_id")
  tierId               String        @map("tier_id")
  status               String
  currentPeriodStart   DateTime      @map("current_period_start")
  currentPeriodEnd     DateTime      @map("current_period_end")
  cancelAtPeriodEnd    Boolean       @default(false) @map("cancel_at_period_end")
  stripeSubscriptionId String?       @map("stripe_subscription_id")
  stripePriceId        String?       @map("stripe_price_id")
  stripeCustomerId     String?       @map("stripe_customer_id")
  canceledAt           DateTime?     @map("canceled_at")
  createdAt            DateTime      @default(now()) @map("created_at")
  updatedAt            DateTime      @default(now()) @map("updated_at")
  
  // Relations
  user                 User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  tier                 PricingTier   @relation(fields: [tierId], references: [id])
  invoices             SubscriptionInvoice[]
  
  @@map("subscriptions")
}

model SubscriptionInvoice {
  id                   String        @id @default(uuid())
  subscriptionId       String        @map("subscription_id")
  stripeInvoiceId      String?       @map("stripe_invoice_id")
  amount               Decimal
  status               String
  paidAt               DateTime?     @map("paid_at")
  invoiceUrl           String?       @map("invoice_url")
  createdAt            DateTime      @default(now()) @map("created_at")
  
  // Relations
  subscription         Subscription  @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  
  @@map("subscription_invoices")
  @@index([subscriptionId])
}

// ================ Teams ================

model Team {
  id                   String        @id @default(uuid())
  name                 String
  description          String?
  createdBy            String        @map("created_by")
  createdAt            DateTime?     @default(now()) @map("created_at")
  updatedAt            DateTime?     @default(now()) @map("updated_at")
  
  // Relations
  owner                User          @relation("TeamOwner", fields: [createdBy], references: [id], onDelete: Cascade)
  members              TeamMember[]
  
  @@map("teams")
}

model TeamMember {
  teamId               String        @map("team_id")
  userId               String        @map("user_id")
  role                 String
  joinedAt             DateTime?     @default(now()) @map("joined_at")
  
  // Relations
  team                 Team          @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user                 User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@id([teamId, userId])
  @@map("team_members")
}

// ================ Auditing & Usage ================

model AuditLog {
  id                   String        @id @default(uuid())
  userId               String?       @map("user_id")
  action               String
  resource             String?
  resourceId           String?       @map("resource_id")
  metadata             Json?
  createdAt            DateTime      @default(now()) @map("created_at")
  
  @@map("audit_logs")
  @@index([userId])
  @@index([action])
}

model RefreshToken {
  id                   String        @id @default(uuid())
  userId               String        @map("user_id")
  token                String        @unique
  expiresAt            DateTime      @map("expires_at")
  createdAt            DateTime      @default(now()) @map("created_at")
  updatedAt            DateTime      @updatedAt @map("updated_at")
  
  @@map("refresh_tokens")
  @@index([userId])
}

model UsageLog {
  id                   String        @id @default(uuid())
  userId               String        @map("user_id")
  resourceType         String        @map("resource_type")
  action               String
  quantity             Int           @default(1)
  metadata             Json?
  createdAt            DateTime      @default(now()) @map("created_at")
  
  @@map("usage_logs")
  @@index([userId])
  @@index([resourceType])
}

// ================ Wallet & Transaction ================

model WalletTransaction {
  id                   String        @id @default(uuid())
  userId               String        @map("user_id")
  walletAddress        String        @map("wallet_address")
  txHash               String        @map("tx_hash")
  chainId              Int           @map("chain_id")
  value                String
  status               String
  blockNumber          Int?          @map("block_number")
  createdAt            DateTime      @default(now()) @map("created_at")
  updatedAt            DateTime      @default(now()) @map("updated_at")
  
  @@map("wallet_transactions")
  @@index([userId])
  @@index([walletAddress])
  @@index([txHash])
}

// ================ Extension Support Models ================

// Rate Limiting Support
model RateLimitBucket {
  id                   String        @id @default(uuid())
  userId               String?       @map("user_id")
  identifier           String        // user_id, ip_address, or other identifier
  operation            String        // operation type (e.g., "workflow_execution", "api_request")
  windowStart          DateTime      @map("window_start")
  windowEnd            DateTime      @map("window_end")
  currentCount         Int           @default(0) @map("current_count")
  limit                Int
  resetAt              DateTime      @map("reset_at")
  createdAt            DateTime      @default(now()) @map("created_at")
  updatedAt            DateTime      @updatedAt @map("updated_at")
  
  @@map("rate_limit_buckets")
  @@unique([identifier, operation, windowStart])
  @@index([userId])
  @@index([identifier])
  @@index([operation])
  @@index([resetAt])
}

model RateLimitViolation {
  id                   String        @id @default(uuid())
  userId               String?       @map("user_id")
  identifier           String
  operation            String
  limit                Int
  attemptedCount       Int           @map("attempted_count")
  windowStart          DateTime      @map("window_start")
  windowEnd            DateTime      @map("window_end")
  ipAddress            String?       @map("ip_address")
  userAgent            String?       @map("user_agent")
  metadata             Json?
  createdAt            DateTime      @default(now()) @map("created_at")
  
  @@map("rate_limit_violations")
  @@index([userId])
  @@index([identifier])
  @@index([operation])
  @@index([createdAt])
}

// Cache Support
model CacheEntry {
  id                   String        @id @default(uuid())
  key                  String        @unique
  namespace            String?
  value                Json
  ttl                  Int?          // TTL in seconds
  expiresAt            DateTime?     @map("expires_at")
  hitCount             Int           @default(0) @map("hit_count")
  lastAccessed         DateTime      @default(now()) @map("last_accessed")
  compressed           Boolean       @default(false)
  size                 Int?          // Size in bytes
  tags                 String[]      @default([])
  createdAt            DateTime      @default(now()) @map("created_at")
  updatedAt            DateTime      @updatedAt @map("updated_at")
  
  @@map("cache_entries")
  @@index([namespace])
  @@index([expiresAt])
  @@index([tags])
  @@index([lastAccessed])
}

model CacheStats {
  id                   String        @id @default(uuid())
  namespace            String?
  operation            String        // hit, miss, set, delete, expire
  count                Int           @default(1)
  totalSize            BigInt?       @map("total_size")
  avgResponseTime      Float?        @map("avg_response_time") // in milliseconds
  hour                 DateTime      // truncated to hour for aggregation
  createdAt            DateTime      @default(now()) @map("created_at")
  
  @@map("cache_stats")
  @@unique([namespace, operation, hour])
  @@index([namespace])
  @@index([operation])
  @@index([hour])
}

// Analytics Support
model QueryPerformance {
  id                   String        @id @default(uuid())
  queryHash            String        @map("query_hash") // hash of the normalized query
  queryType            String        @map("query_type") // SELECT, INSERT, UPDATE, DELETE
  tableName            String?       @map("table_name")
  executionTime        Float         @map("execution_time") // in milliseconds
  rowsAffected         Int?          @map("rows_affected")
  queryPlan            Json?         @map("query_plan")
  stackTrace           String?       @map("stack_trace")
  userId               String?       @map("user_id")
  sessionId            String?       @map("session_id")
  timestamp            DateTime      @default(now())
  
  @@map("query_performance")
  @@index([queryHash])
  @@index([queryType])
  @@index([tableName])
  @@index([executionTime])
  @@index([timestamp])
  @@index([userId])
}

model WorkflowAnalytics {
  id                   String        @id @default(uuid())
  workflowId           String        @map("workflow_id")
  executionId          String?       @map("execution_id")
  userId               String        @map("user_id")
  metric               String        // execution_time, success_rate, error_rate, etc.
  value                Float
  unit                 String?       // ms, percentage, count, etc.
  dimensions           Json?         // additional categorization data
  aggregationPeriod    String        @map("aggregation_period") // hour, day, week, month
  periodStart          DateTime      @map("period_start")
  periodEnd            DateTime      @map("period_end")
  createdAt            DateTime      @default(now()) @map("created_at")
  
  @@map("workflow_analytics")
  @@index([workflowId])
  @@index([userId])
  @@index([metric])
  @@index([aggregationPeriod])
  @@index([periodStart])
}

model SystemMetrics {
  id                   String        @id @default(uuid())
  component            String        // database, cache, queue, worker, etc.
  metric               String        // cpu_usage, memory_usage, response_time, etc.
  value                Float
  unit                 String?       // percentage, ms, bytes, etc.
  hostname             String?
  instanceId           String?       @map("instance_id")
  metadata             Json?
  timestamp            DateTime      @default(now())
  
  @@map("system_metrics")
  @@index([component])
  @@index([metric])
  @@index([hostname])
  @@index([timestamp])
}

// Enhanced Audit Support
model ComplianceAuditLog {
  id                   String        @id @default(uuid())
  userId               String?       @map("user_id")
  sessionId            String?       @map("session_id")
  action               String
  resource             String
  resourceId           String?       @map("resource_id")
  complianceFramework  String        @map("compliance_framework") // GDPR, SOX, HIPAA, etc.
  riskLevel            String        @map("risk_level") // low, medium, high, critical
  dataClassification   String?       @map("data_classification") // public, internal, confidential, restricted
  beforeValue          Json?         @map("before_value")
  afterValue           Json?         @map("after_value")
  reason               String?       // reason for the action
  approvedBy           String?       @map("approved_by")
  ipAddress            String?       @map("ip_address")
  userAgent            String?       @map("user_agent")
  location             Json?         // geographical location data
  metadata             Json?
  retentionPolicy      String?       @map("retention_policy")
  archivedAt           DateTime?     @map("archived_at")
  createdAt            DateTime      @default(now()) @map("created_at")
  
  @@map("compliance_audit_logs")
  @@index([userId])
  @@index([action])
  @@index([resource])
  @@index([complianceFramework])
  @@index([riskLevel])
  @@index([createdAt])
}

model DataChangeLog {
  id                   String        @id @default(uuid())
  tableName            String        @map("table_name")
  recordId             String        @map("record_id")
  operation            String        // INSERT, UPDATE, DELETE
  fieldChanges         Json          @map("field_changes") // {field: {old: value, new: value}}
  userId               String?       @map("user_id")
  sessionId            String?       @map("session_id")
  transactionId        String?       @map("transaction_id")
  changeReason         String?       @map("change_reason")
  applicationVersion   String?       @map("application_version")
  timestamp            DateTime      @default(now())
  
  @@map("data_change_logs")
  @@index([tableName])
  @@index([recordId])
  @@index([operation])
  @@index([userId])
  @@index([timestamp])
}

// Workflow State Enhancement
model WorkflowStateSnapshot {
  id                   String        @id @default(uuid())
  workflowId           String        @map("workflow_id")
  executionId          String        @map("execution_id")
  snapshotType         String        @map("snapshot_type") // checkpoint, failure, pause, resume
  state                Json          // complete workflow state
  nodeStates           Json          @map("node_states") // individual node states
  context              Json?         // additional context data
  version              Int           @default(1)
  parentSnapshotId     String?       @map("parent_snapshot_id") // for state history
  createdBy            String?       @map("created_by") // system, user, or scheduler
  expiresAt            DateTime?     @map("expires_at")
  createdAt            DateTime      @default(now()) @map("created_at")
  
  // Relations
  parentSnapshot       WorkflowStateSnapshot? @relation("SnapshotHistory", fields: [parentSnapshotId], references: [id])
  childSnapshots       WorkflowStateSnapshot[] @relation("SnapshotHistory")
  
  @@map("workflow_state_snapshots")
  @@index([workflowId])
  @@index([executionId])
  @@index([snapshotType])
  @@index([createdAt])
  @@index([expiresAt])
}