# zyra Project Rules

## 1. Purpose

Zyra is an AI-driven, blockchain-focused workflow automation platform. It enables users to build, execute, and monitor complex workflows, integrating AI and blockchain capabilities.

## 2. Monorepo Structure

- All code is organized in a monorepo with `apps/` (frontend, backend) and `packages/` (shared logic, types, database).
- Shared types and logic must be placed in `packages/` and imported via workspace protocol.
- Use workspace protocol (`workspace:*`) for internal dependencies in `package.json`.

## 3. Shared Packages Usage

- All shared types must be defined in `packages/types` and imported via `@zyra/types`. Do not define new types in `apps/ui` or `apps/zyra-worker` unless strictly local and not shared. Confirm type existence before adding new ones.
- All database access, repositories, authentication, and policy logic must be used from `@zyra/database`. Do not access the database directly or define new repositories outside this package. Confirm DB logic existence before adding new ones.
- Any new type or DB logic required by UI or worker must be proposed and added to the relevant shared package before use.

## 4. Worker (Execution Engine) Guidelines

- The worker (`apps/zyra-worker`) acts solely as the execution engine for workflows and blocks.
- It must use types from `@zyra/types` and DB logic from `@zyra/database`.
- Do not add business logic, type definitions, or DB access outside of the shared packages.
- All execution, logging, and workflow logic must be modular, self-contained, and use shared types.

## 5. UI Guidelines

- The UI (`apps/ui`) must use types from `@zyra/types` and DB logic from `@zyra/database`.
- Do not duplicate or redefine types or DB logic in the UI.
- All API routes and server-side logic must use the shared packages for type safety and consistency.

## 6. Integration & Sync

- Any new feature or change must be checked for impact on both UI and worker.
- Both must remain in sync and fully integrated; do not implement a feature in one without considering the other.

## 7. Change Management

- Before adding new types or DB logic, confirm if it already exists in the shared packages.
- If not, propose and add it to the relevant package, then use it in the apps.

## 8. Best Practices (per https://windsurf.com/editor/directory)

- Follow Next.js, Tailwind, and Prisma best practices, including:
  - Airbnb style guide for code formatting.
  - PascalCase for React component file names.
  - Prefer named exports for components.
  - Use Next.js App Router and distinguish server/client components.
  - Use TanStack Query for data fetching.
  - Use React Hook Form for forms.
  - Use Zod for validation.
  - Use React Context for state management.
  - Use functional and declarative programming patterns; avoid classes.
  - Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
  - Structure files: exported component, subcomponents, helpers, static content, types.
  - Use strict TypeScript settings and avoid `any`/enums in favor of explicit types and maps.

## 9. Developer Experience

- All new files must be under 300 lines; split larger features into multiple, self-contained, loosely coupled files.
- Do not create unnecessary files; keep the codebase clean and maintainable.
- If unsure, check the `docs/`, `apps/ui/`, or `apps/zyra-worker/` folders for reference.

## 10. Tech Stack

- **Frontend:** Next.js (App Router), React, TypeScript, Tailwind CSS, PostCSS, Zustand
- **Backend:** Node.js, NestJS, TypeScript
- **Database:** PostgreSQL, managed via Prisma (see `packages/database/prisma/schema.prisma`)
- **Other Integrations:** Web3, Ollama (AI), PostHog (analytics), Netlify (deployment)

## 11. Best Practices & Production-Readiness

### a. Database (Prisma)

- All schema changes must be made in `packages/database/prisma/schema.prisma`.
- Use Prisma CLI for migrations and client generation.
- Follow best practices for model naming, relations, and constraints.
- Supabase is only used for authentication and type generation, not for schema or migrations.

### b. Frontend (Next.js)

- Modular, reusable components colocated with their styles and types.
- Use Tailwind CSS for all styling.
- API routes within Next.js for server-side logic.
- Environment variables managed via `.env` (never commit secrets).
- UI must match the overall theme and be visually striking, following UI/UX best practices.

### c. Backend (NestJS)

- All backend logic lives in `apps/zyra-worker`.
- Follow NestJS module structure: controllers, services, DTOs, and providers.
- Register new services in the appropriate module.
- Use dependency injection and avoid tight coupling between modules.

### d. Security

- Enforce RLS policies in the database where applicable.
- Secrets in `.env`, not in code.
- Auth checks in both frontend and backend where needed.

### e. Testing & Monitoring

- Use Jest for backend and shared logic testing.
- Place test files in `test/` directories or alongside code.
- PostHog for analytics.
- Logs and error handling in both UI and worker.

### f. Deployment

- Netlify for frontend deployments.
- Automated build and deploy pipelines.
- `windsurf_deployment.yaml` for deployment config.

### g. Developer Experience

- TypeScript for type safety everywhere.
- Clear separation between UI, logic, and data layers.
- Docs folder for onboarding and reference.
- All new files must be under 300 lines; split larger features into multiple, self-contained, loosely coupled files.

## 12. How to Get Started

- Run DB migrations: `pnpm run db:push` from the `ui` folder (for Prisma).
- Start frontend: `pnpm run dev` in `apps/ui`.
- Start worker: `pnpm run start` in `apps/zyra-worker`.
- Deploy: Use Netlify or your configured deployment pipeline.

## 13. General Guidelines

- Always check both UI and worker for integration and sync when adding or updating features.
- If unsure, check the `docs/`, `apps/ui/`, or `apps/zyra-worker/` folders for reference.
- Look into the `docs/development-rules.md` for more detailed guidelines.
